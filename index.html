<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Piano Tutor App</title>
  <!-- Tone.js library for professional audio synthesis -->
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background-color: #f8f9fa;
      color: #333;
      overflow-x: hidden;
    }

    .app-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 2.5rem;
      color: #2c3e50;
      margin-bottom: 10px;
    }

    .header p {
      font-size: 1.1rem;
      color: #7f8c8d;
    }

    .staff-container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 0px 0px;
      margin-bottom: 30px;
      position: relative;
      overflow: hidden;
      min-height: 200px;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      touch-action: none;
      -webkit-touch-callout: none;
    }

    .playback-line {
      position: absolute;
      top: 2px;
      bottom: 2px;
      width: 8px;
      border-radius: 8px;
      background-color: #bbbbbb;
      opacity: 0.5;
      left: 120px;
      z-index: 10;
    }

    /* Static staff lines that remain fixed during animation */
    .staff-lines {
      position: absolute;
      top: 59px;
      /* 40px margin + 20px staff top */
      left: 0;
      right: 0;
      height: 82px;
      z-index: 1;
    }

    .staff-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background-color: #dadada;
    }

    /* Animated content container - only this moves */
    .staff {
      position: relative;
      /* make some room to prevent hidden */
      height: 200px;
      /* 186px for notes from A3 to B5 */
      margin-left: 90px;
      overflow-x: hidden;
      overflow-y: visible;
      transition: transform 0.1s linear;
      z-index: 2;
    }

    /* Smooth transitions for notes container during manual interaction */
    .notes-container {
      transition: transform 0.1s linear;
      will-change: transform;
      /* Optimize for transform animations */
    }

    .staff-line:nth-child(1) {
      top: 0;
    }

    .staff-line:nth-child(2) {
      top: 20px;
    }

    .staff-line:nth-child(3) {
      top: 40px;
    }

    .staff-line:nth-child(4) {
      top: 60px;
    }

    .staff-line:nth-child(5) {
      top: 80px;
    }

    .treble-clef {
      position: absolute;
      left: 20px;
      top: 0px;
      font-size: 144px;
      z-index: 4;
    }

    .notes-container {
      position: absolute;
      /*
       * subtract 'margin-left' value of '.staff' from the left value of
       * '.playback-line'
       */
      left: 30px;
      top: 0;
      height: 200px;
    }

    /* Tempo control styles - clean minimal design */
    .tempo-control {
      position: absolute;
      top: 10px;
      left: 25px;
      z-index: 15;
    }

    .tempo-control .tempo-label {
      color: #6c757d;
      font-size: 16px;
      font-weight: 500;
      white-space: nowrap;
    }

    .tempo-selector {
      color: #495057;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      min-width: 80px;
      /* Remove default select styling to look like pure text */
      background: none;
      border: none;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      padding: 0;
      margin: 0;
      font-family: inherit;
    }

    /* Note rectangle styles */
    .note-rectangle {
      position: absolute;
      height: 22px;
      border-radius: 4px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
    }

    /* Note highlighting for current playback */
    .note-rectangle.current {
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(231, 76, 60, 0.6);
      z-index: 5;
    }

    /* Positive feedback for correct note matches */
    .note-rectangle.correct-note {
      box-shadow: 0 0 15px rgba(40, 167, 69, 0.8);
      z-index: 10;
    }

    /* MIDI-specific correct note feedback */
    .note-rectangle.correct-note-midi {
      transform: scale(1.2);
      box-shadow: 0 0 15px rgba(111, 66, 193, 0.8);
      z-index: 10;
    }

    /* Simple Progress Bar Styles */
    .simple-progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background-color: rgba(0, 0, 0, 0.1);
      z-index: 5;
      cursor: pointer;
      transition: height 0.2s ease;
    }

    .simple-progress-bar:hover {
      height: 6px;
      /* Slightly taller on hover for better interaction */
    }

    .simple-progress-fill {
      height: 100%;
      background: #64c83d;
      width: 0%;
      transition: width 0.1s linear;
    }

    /* Interactive states */
    .simple-progress-bar.interacting {
      height: 6px;
    }

    .simple-progress-bar.interacting .simple-progress-fill {
      background: #5cb85c;
      /* Slightly different color during interaction */
    }

    /* Smooth transitions between normal and interaction states */
    .simple-progress-bar.state-transitioning {
      transition: height 0.2s ease, background-color 0.2s ease;
    }

    .simple-progress-bar.state-transitioning .simple-progress-fill {
      transition: background 0.2s ease;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .simple-progress-bar {
        height: 6px;
        /* Larger touch target on mobile */
      }

      .simple-progress-bar:hover {
        height: 8px;
      }
    }

    /* Fingering number display inside note rectangles */
    .fingering-number {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-weight: bold;
      font-size: 11px;
      font-family: Arial, sans-serif;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      pointer-events: none;
      z-index: 6;
      line-height: 1;
    }

    /* Measure bar styles */
    .measure-bar {
      position: absolute;
      top: 59px;
      height: 82px;
      width: 2px;
      background-color: #dadada;
      z-index: 3;
    }

    /* Virtual Piano Keyboard Styles */
    .keyboard-container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 30px;
      display: flex;
      justify-content: flex-start;
      overflow-x: auto;
      padding: 0 5px;
    }

    .keyboard {
      position: relative;
      display: flex;
      align-items: flex-start;
      height: 200px;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      min-width: fit-content;
    }

    /* Piano key container - holds both white and black keys */
    .piano-key-container {
      position: relative;
      display: flex;
      flex-direction: column;
      margin-right: 1px;
    }

    /* Base piano key styles */
    .piano-key {
      cursor: pointer;
      transition: all 0.1s ease;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      font-size: 12px;
      font-weight: 500;
      color: #666;
      padding-bottom: 8px;
      border: 1px solid #333333;
    }

    /* White piano keys */
    .piano-key.white {
      width: 87px;
      height: 200px;
      background-color: #ffffff;
      border-radius: 0 0 6px 6px;
      z-index: 1;
    }

    /* Black piano keys - positioned between white keys */
    .piano-key.black {
      position: absolute;
      top: 0;
      right: -25px; /* Half of black key width (49px/2 ≈ 25px) to center between white keys */
      width: 49px;
      height: 130px;
      background-color: #333333;
      border: 1px solid #000000;
      border-radius: 0 0 3px 3px;
      z-index: 2;
      color: #ffffff;
      font-size: 12px;
    }

    .piano-key.white:hover {
      background-color: #f0f0f0;
    }

    .piano-key.white:active,
    .piano-key.white.pressed {
      background-color: #e0e0e0;
    }



    .piano-key.black:hover {
      background-color: #555555;
    }

    .piano-key.black:active,
    .piano-key.black.pressed {
      background-color: #666666;
    }

    /* Key highlighting states */
    .piano-key.active {
      background-color: #007bff !important;
      color: white;
      box-shadow: 0 0 10px rgba(0, 123, 255);
    }

    .piano-key.correct {
      background-color: #28a745 !important;
      color: white;
      box-shadow: 0 0 10px rgba(40, 167, 69, 0.6);
    }

    .piano-key.incorrect {
      background-color: #dc3545 !important;
      color: white;
      box-shadow: 0 0 10px rgba(220, 53, 69, 0.6);
    }

    /* MIDI-specific feedback classes */
    .piano-key.correct-midi {
      background-color: #6f42c1 !important;
      /* Purple for MIDI correct feedback */
      color: white;
      box-shadow: 0 0 12px rgba(111, 66, 193, 0.8);
    }

    .piano-key.incorrect-midi {
      background-color: #e83e8c !important;
      /* Pink for MIDI incorrect feedback */
      color: white;
      box-shadow: 0 0 10px rgba(232, 62, 140, 0.6);
    }

    /* MIDI-specific key highlighting */
    .piano-key.midi-pressed {
      background-color: #6f42c1 !important;
      /* Purple for MIDI input */
      color: white;
      box-shadow: 0 0 12px rgba(111, 66, 193, 0.8);
      border: 2px solid rgba(111, 66, 193, 0.9);
    }

    .piano-key.midi-pressed.white {
      background-color: #8a63d2 !important;
      /* Lighter purple for white keys */
    }

    .piano-key.midi-pressed.black {
      background-color: #5a3a9a !important;
      /* Darker purple for black keys */
    }

    /*
     * piano key highlight effect for correct press
     */
    .piano-key.correct-C {
      background-color: #CE82FF !important;
      color: white;
    }

    .piano-key.correct-D {
      background-color: #FF9602 !important;
      color: white;
    }

    .piano-key.correct-E {
      background-color: #57CD03 !important;
      color: white;
    }

    .piano-key.correct-F {
      background-color: #CC348E !important;
      color: white;
    }

    .piano-key.correct-G {
      background-color: #7090FF !important;
      color: white;
    }

    .piano-key.correct-A {
      background-color: #FF87D0 !important;
      color: white;
    }

    .piano-key.correct-B {
      background-color: #00CE9C !important;
      color: white;
    }

    .piano-key.incorrect-gray {
      position: relative;
    }

    .piano-key.incorrect-gray::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(204, 204, 204, 0.2);
      border-radius: inherit;
      pointer-events: none;
      z-index: 1;
    }

    /* Intersection line styles */
    .intersection-line {
      position: absolute;
      border-radius: 2px;
      opacity: 0.9;
      background-color: white;
      width: 8px;
      /* the note height */
      height: 22px;
      /* same Y scale as the note */
      transform: scaleY(1.2);
      pointer-events: none;
      z-index: 15;
      transition: opacity 0.3s ease-out;
    }

    /* Incorrect note styles for timing evaluation feedback */
    .note-rectangle.incorrect-note {
      background-color: #cccccc !important;
      opacity: 0.8;
      color: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* Timing feedback styles for piano keys */
    .piano-key.timing-early {
      background-color: #ffc107 !important;
      color: white;
      box-shadow: 0 0 12px rgba(255, 193, 7, 0.8);
    }

    .piano-key.timing-late {
      background-color: #ff5722 !important;
      color: white;
      box-shadow: 0 0 12px rgba(255, 87, 34, 0.8);
    }

    .piano-key.timing-neutral {
      background-color: #6c757d !important;
      color: white;
      box-shadow: 0 0 12px rgba(108, 117, 125, 0.8);
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    /* Learning progress display */
    .learning-progress {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 15px 20px;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
    }

    .progress-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 80px;
    }

    .progress-stat .value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #2c3e50;
      margin-bottom: 5px;
    }

    .progress-stat .label {
      font-size: 0.9rem;
      color: #7f8c8d;
      text-align: center;
    }

    .progress-stat.correct .value {
      color: #27ae60;
    }

    .progress-stat.incorrect .value {
      color: #e74c3c;
    }

    .progress-stat.accuracy .value {
      color: #3498db;
    }

    /* MIDI-specific statistics styling */
    .progress-stat.midi-stat .value {
      color: #6f42c1;
      /* Purple for MIDI stats */
    }

    .progress-stat.midi-stat .label {
      font-size: 0.8rem;
    }

    /* Show MIDI stats when MIDI input is detected */
    .learning-progress.show-midi-stats .midi-stat {
      display: flex !important;
    }

    @media (max-width: 768px) {
      .learning-progress {
        justify-content: center;
        text-align: center;
      }

      .progress-stat {
        min-width: 60px;
      }

      .progress-stat .value {
        font-size: 1.2rem;
      }

      .progress-stat.midi-stat {
        min-width: 70px;
      }

      .progress-stat.midi-stat .value {
        font-size: 1.1rem;
      }

      .progress-stat.midi-stat .label {
        font-size: 0.75rem;
      }
    }

    /* MIDI Device Selection Interface Styles */
    .midi-device-panel {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
      padding: 20px;
    }

    .midi-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .midi-header h3 {
      color: #2c3e50;
      margin: 0;
      font-size: 1.3rem;
    }

    .device-status {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .status-indicator {
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
    }

    .status-indicator.connected {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .status-indicator.disconnected {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .status-indicator.connecting {
      background-color: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }

    .status-indicator.error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .status-indicator.auto-connected {
      background-color: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
      animation: autoConnectPulse 2s ease-in-out;
    }

    @keyframes autoConnectPulse {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }

      100% {
        transform: scale(1);
      }
    }

    .device-name {
      color: #6c757d;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .device-selection {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .device-preferences {
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #dee2e6;
    }

    .preference-item {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      font-size: 0.9rem;
      color: #495057;
    }

    .preference-item input[type="checkbox"] {
      display: none;
    }

    .checkmark {
      width: 18px;
      height: 18px;
      border: 2px solid #6c757d;
      border-radius: 3px;
      position: relative;
      transition: all 0.3s ease;
    }

    .preference-item input[type="checkbox"]:checked+.checkmark {
      background-color: #007bff;
      border-color: #007bff;
    }

    .preference-item input[type="checkbox"]:checked+.checkmark::after {
      content: '✓';
      position: absolute;
      top: -2px;
      left: 2px;
      color: white;
      font-size: 14px;
      font-weight: bold;
    }

    .device-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .device-controls label {
      color: #495057;
      font-weight: 600;
      font-size: 0.95rem;
    }

    .device-select-container {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .device-select {
      flex: 1;
      padding: 10px 12px;
      border: 2px solid #ced4da;
      border-radius: 6px;
      background-color: #ffffff;
      color: #495057;
      font-size: 0.95rem;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .device-select:focus {
      outline: none;
      border-color: #80bdff;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
    }

    .device-select:hover {
      border-color: #adb5bd;
    }

    .device-select option {
      padding: 8px;
    }

    .refresh-btn {
      padding: 10px 12px;
      background-color: #6c757d;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 44px;
    }

    .refresh-btn:hover {
      background-color: #5a6268;
      transform: translateY(-1px);
    }

    .refresh-btn:active {
      transform: translateY(0);
    }

    .refresh-icon {
      font-size: 1.2rem;
      font-weight: bold;
    }

    .connection-help {
      background-color: #f8f9fa;
      border-radius: 6px;
      padding: 15px;
      border-left: 4px solid #007bff;
    }

    .troubleshooting {
      border-top: 1px solid #dee2e6;
      padding-top: 15px;
      margin-top: 15px;
    }

    .troubleshooting h4 {
      color: #dc3545;
      margin-bottom: 10px;
    }

    .troubleshooting li strong {
      color: #495057;
    }

    /* Responsive MIDI interface */
    @media (max-width: 768px) {
      .midi-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 15px;
      }

      .device-status {
        align-self: stretch;
        justify-content: space-between;
      }

      .device-select-container {
        flex-direction: column;
        gap: 10px;
      }

      .device-select {
        width: 100%;
      }

      .refresh-btn {
        align-self: flex-start;
        min-width: 120px;
      }

      .connection-help {
        padding: 12px;
      }
    }

    @media (max-width: 768px) {
      .app-container {
        padding: 10px;
      }

      .header h1 {
        font-size: 2rem;
      }

      /* Responsive tempo control styles */
      .tempo-control {
        top: 10px;
        right: 15px;
        padding: 6px 10px;
        gap: 6px;
      }

      .tempo-control .tempo-label {
        font-size: 12px;
      }

      .tempo-selector {
        min-width: 70px;
        font-size: 12px;
        padding: 3px 6px;
      }

      /* Responsive keyboard styles */
      .keyboard-container {
        padding: 0px 5px;
        overflow-x: auto;
        justify-content: flex-start;
      }

      .keyboard {
        min-width: 500px;
        /* Ensure keyboard doesn't get too small */
      }

      .piano-key.white {
        width: 37px;
        height: 120px;
      }

      .piano-key.black {
        width: 22px;
        height: 80px;
        right: -11px; /* Half of mobile black key width (22px/2 = 11px) to center between white keys */
      }


    }
  </style>
</head>

<body>
  <div class="app-container">
    <header class="header">
      <h1>Piano Tutor App</h1>
      <p>Learn to play "Different Colors" by Walk the Moon</p>
    </header>

    <div class="staff-container">
      <!-- Simple Progress Bar -->
      <div class="simple-progress-bar">
        <div class="simple-progress-fill" id="progressFill"></div>
      </div>

      <div class="playback-line"></div>

      <!-- Static staff lines that don't move -->
      <div class="staff-lines">
        <div class="staff-line"></div>
        <div class="staff-line"></div>
        <div class="staff-line"></div>
        <div class="staff-line"></div>
        <div class="staff-line"></div>
      </div>

      <!-- Static treble clef that doesn't move -->
      <div class="treble-clef">𝄞</div>

      <!-- Animated content container -->
      <div class="staff">
        <div class="notes-container">
          <!-- Notes will be dynamically added here -->
        </div>
      </div>
      <!-- Tempo control - integrated musical design -->
      <div class="tempo-control">
        <label class="tempo-label" for="tempoSelector">♩=</label>
        <select class="tempo-selector" id="tempoSelector">
          <option value="40">40</option>
          <option value="60" selected>60</option>
          <option value="72">72</option>
          <option value="90">90</option>
          <option value="120">120</option>
        </select>
      </div>
    </div>



    <!-- Virtual Piano Keyboard -->
    <div class="keyboard-container">
      <div class="keyboard" id="virtualKeyboard">
        <!-- White keys will be generated here -->
        <!-- Black keys will be generated here -->
      </div>
    </div>

    <!-- MIDI Device Selection Interface -->
    <div class="midi-device-panel" id="midiDevicePanel">
      <div class="midi-header">
        <h3>MIDI Piano Connection</h3>
        <div class="device-status">
          <span class="status-indicator disconnected" id="midiStatus">Disconnected</span>
          <span class="device-name" id="connectedDevice">No device selected</span>
        </div>
      </div>

      <div class="device-selection">
        <div class="device-controls">
          <label for="midiDeviceSelect">Select MIDI Device:</label>
          <div class="device-select-container">
            <select id="midiDeviceSelect" class="device-select">
              <option value="">No MIDI device</option>
            </select>
            <button id="refreshDevices" class="refresh-btn" title="Refresh device list">
              <span class="refresh-icon">⟳</span>
            </button>
          </div>
        </div>

        <div class="device-preferences">
          <label class="preference-item">
            <input type="checkbox" id="autoConnectCheckbox" checked>
            <span class="checkmark"></span>
            Automatically connect to MIDI devices when detected
          </label>
        </div>
      </div>
    </div>

    <!-- Learning Progress Display -->
    <div class="learning-progress" id="learningProgress">
      <div class="progress-stat correct">
        <div class="value" id="correctCount">0</div>
        <div class="label">Correct</div>
      </div>
      <div class="progress-stat incorrect">
        <div class="value" id="incorrectCount">0</div>
        <div class="label">Incorrect</div>
      </div>
      <div class="progress-stat">
        <div class="value" id="totalAttempts">0</div>
        <div class="label">Total</div>
      </div>
      <div class="progress-stat accuracy">
        <div class="value" id="accuracyRate">0%</div>
        <div class="label">Accuracy</div>
      </div>
      <div class="progress-stat">
        <div class="value" id="currentStreak">0</div>
        <div class="label">Streak</div>
      </div>
      <div class="progress-stat midi-stat" id="midiStats" style="display: none;">
        <div class="value" id="midiAccuracy">0%</div>
        <div class="label">MIDI Accuracy</div>
      </div>
      <div class="progress-stat midi-stat" id="virtualStats" style="display: none;">
        <div class="value" id="virtualAccuracy">0%</div>
        <div class="label">Virtual Accuracy</div>
      </div>
    </div>
  </div>

  <script>
    // Hardcoded note data structure for "Different Colors" by Walk the Moon
    const SONG_DATA = {
      title: "Different Colors",
      artist: "Walk the Moon",
      measures: [
        {
          notes: [
            {pitch: "A3", duration: "quarter", fingering: 1},
            {pitch: "rest", duration: "quarter", fingering: null},
            {pitch: "A3", duration: "quarter", fingering: null},
            {pitch: "B3", duration: "quarter", fingering: null}
          ]
        },
        {
          notes: [
            {pitch: "C4", duration: "quarter", fingering: 1},
            {pitch: "D4", duration: "quarter", fingering: null},
            {pitch: "E4", duration: "half", fingering: null},
          ]
        },
        {
          notes: [
            {pitch: "G4", duration: "whole", fingering: 1},
          ]
        },
        {
          notes: [
            {pitch: "D5", duration: "quarter", fingering: 1},
            {pitch: "E5", duration: "quarter", fingering: null},
            {pitch: "F5", duration: "quarter", fingering: null},
            {pitch: "rest", duration: "quarter", fingering: null}
          ]
        },
        {
          notes: [
            {pitch: "D4", duration: "quarter", fingering: 2},
            {pitch: "F4", duration: "quarter", fingering: 4},
            {pitch: "C4", duration: "quarter", fingering: 1},
            {pitch: "rest", duration: "quarter", fingering: null}
          ]
        },
        {
          notes: [
            {pitch: "G4", duration: "quarter", fingering: 5},
            {pitch: "A4", duration: "eighth", fingering: 1},
            {pitch: "G4", duration: "eighth", fingering: 5},
            {pitch: "F4", duration: "quarter", fingering: 4},
            {pitch: "rest", duration: "quarter", fingering: null}
          ]
        },
        {
          notes: [
            {pitch: "D4", duration: "quarter", fingering: 2},
            {pitch: "F4", duration: "quarter", fingering: 4},
            {pitch: "C4", duration: "quarter", fingering: 1},
            {pitch: "rest", duration: "quarter", fingering: null}
          ]
        },
        {
          notes: [
            {pitch: "G4", duration: "quarter", fingering: 5},
            {pitch: "A4", duration: "eighth", fingering: 1},
            {pitch: "G4", duration: "eighth", fingering: 5},
            {pitch: "F4", duration: "quarter", fingering: 4},
            {pitch: "rest", duration: "quarter", fingering: null}
          ]
        },
        {
          notes: [
            {pitch: "A4", duration: "quarter", fingering: 1},
            {pitch: "C5", duration: "quarter", fingering: 3},
            {pitch: "A4", duration: "dotted_quarter", fingering: 1},
            {pitch: "F4", duration: "eighth", fingering: 4}
          ]
        },
        {
          notes: [
            {pitch: "A4", duration: "dotted_quarter", fingering: 1},
            {pitch: "G4", duration: "eighth", fingering: 5},
            {pitch: "F4", duration: "half", fingering: 4}
          ]
        },
        {
          notes: [
            {pitch: "A4", duration: "quarter", fingering: 1},
            {pitch: "C5", duration: "quarter", fingering: 3},
            {pitch: "A4", duration: "dotted_quarter", fingering: 1},
            {pitch: "F4", duration: "eighth", fingering: 4}
          ]
        },
        {
          notes: [
            {pitch: "A4", duration: "dotted_quarter", fingering: 1},
            {pitch: "G4", duration: "eighth", fingering: 5},
            {pitch: "F4", duration: "half", fingering: 4}
          ]
        },
        {
          notes: [
            {pitch: "A4", duration: "quarter", fingering: 1},
            {pitch: "C5", duration: "quarter", fingering: 3},
            {pitch: "A4", duration: "dotted_quarter", fingering: 1},
            {pitch: "F4", duration: "eighth", fingering: 4}
          ]
        },
        {
          notes: [
            {pitch: "A4", duration: "quarter", fingering: 1},
            {pitch: "G4", duration: "quarter", fingering: 5},
            {pitch: "F4", duration: "half", fingering: 4}
          ]
        },
        {
          notes: [
            {pitch: "D4", duration: "quarter", fingering: 2},
            {pitch: "F4", duration: "quarter", fingering: 4},
            {pitch: "C4", duration: "quarter", fingering: 1},
            {pitch: "rest", duration: "quarter", fingering: null}
          ]
        },
        {
          notes: [
            {pitch: "G4", duration: "quarter", fingering: 5},
            {pitch: "A4", duration: "eighth", fingering: 1},
            {pitch: "G4", duration: "eighth", fingering: 5},
            {pitch: "F4", duration: "half", fingering: 4}
          ]
        }
      ]
    };

    // Note duration values in milliseconds (for timing calculations)
    const NOTE_DURATIONS = {
      "eighth": 250,
      "quarter": 500,
      "dotted_quarter": 750,
      "half": 1000
    };

    // Discrete BPM tempo values with corresponding playback speed multipliers
    const TEMPO_MARKINGS = {
      "40": {
        name: "40 BPM",
        bpm: 40,
        speedMultiplier: 0.6 // 40/60 = 0.6
      },
      "60": {
        name: "60 BPM",
        bpm: 60,
        speedMultiplier: 1.0 // 60/60 = 1.0 (reference tempo)
      },
      "72": {
        name: "72 BPM",
        bpm: 72,
        speedMultiplier: 1.2 // 72 / 60 = 1.2
      },
      "90": {
        name: "90 BPM",
        bpm: 90,
        speedMultiplier: 1.5 // 90 / 60 = 1.5
      },
      "120": {
        name: "120 BPM",
        bpm: 120,
        speedMultiplier: 2.0 // 120/60 = 2.0
      },
    };

    // Default tempo setting - 60 BPM as specified in requirements
    const DEFAULT_TEMPO = "60";

    // Base playback speed in pixels per millisecond at default tempo (60 BPM)
    // The algorithm:
    // 60 BMP = 60 beats per minute = 1 beat per second = 1 quarter note per second
    // = 76 pixels per 1000 ms
    //
    // NotePositioning.getNoteWidth("quarter") / 1000
    // => 76 / 1000 = 0.076 pixels/ms
    const BASE_PLAYBACK_SPEED = 0.076;

    // MIDI Device Manager class for UI management
    class MIDIDeviceManager {
      constructor() {
        this.midiController = null;
        this.deviceSelectElement = null;
        this.statusIndicatorElement = null;
        this.deviceNameElement = null;
        this.refreshButtonElement = null;
        this.isInitialized = false;

        console.log('MIDIDeviceManager initialized');
      }

      /**
       * Initialize the MIDI device manager with DOM elements and event handlers
       * @param {MIDIController} midiController - The MIDI controller instance
       */
      initialize(midiController) {
        this.midiController = midiController;

        // Get DOM elements
        this.deviceSelectElement = document.getElementById('midiDeviceSelect');
        this.statusIndicatorElement = document.getElementById('midiStatus');
        this.deviceNameElement = document.getElementById('connectedDevice');
        this.refreshButtonElement = document.getElementById('refreshDevices');

        if (!this.deviceSelectElement || !this.statusIndicatorElement ||
          !this.deviceNameElement || !this.refreshButtonElement) {
          console.error('MIDI UI elements not found in DOM');
          return false;
        }

        // Set up event handlers
        this.setupEventHandlers();

        // Set up MIDI controller callbacks
        this.setupMIDICallbacks();

        this.isInitialized = true;
        console.log('MIDIDeviceManager initialized successfully');

        return true;
      }

      /**
       * Set up event handlers for UI interactions
       */
      setupEventHandlers() {
        // Device selection change handler
        this.deviceSelectElement.addEventListener('change', (event) => {
          this.handleDeviceSelection(event.target.value);
        });

        // Refresh button click handler
        this.refreshButtonElement.addEventListener('click', () => {
          this.handleRefreshDevices();
        });

        // Auto-connect checkbox handler
        const autoConnectCheckbox = document.getElementById('autoConnectCheckbox');
        if (autoConnectCheckbox) {
          // Set initial state from preferences
          if (this.midiController && this.midiController.preferences) {
            autoConnectCheckbox.checked = this.midiController.preferences.preferences.autoConnect;
          }

          autoConnectCheckbox.addEventListener('change', (event) => {
            this.handleAutoConnectToggle(event.target.checked);
          });
        }
      }

      /**
       * Set up callbacks for MIDI controller events
       */
      setupMIDICallbacks() {
        if (!this.midiController) return;

        // Device state change callback
        this.midiController.onDeviceStateChange = (event) => {
          this.handleMIDIDeviceStateChange(event);
        };

        // Error callback
        this.midiController.onError = (error) => {
          this.handleMIDIError(error);
        };
      }

      /**
       * Handle device selection from dropdown
       * @param {string} deviceId - Selected device ID
       */
      async handleDeviceSelection(deviceId) {
        if (!this.midiController) {
          console.error('MIDI controller not available');
          return;
        }

        if (!deviceId) {
          // Disconnect current device
          this.midiController.disconnectDevice();
          this.showConnectionStatus(false, '');
          return;
        }

        try {
          // Show connecting status
          this.showConnectionStatus(false, '', 'connecting');

          // Use connection manager for enhanced connection handling
          const success = await this.midiController.connectionManager.attemptConnection(deviceId);

          if (success) {
            const deviceInfo = this.midiController.availableDevices.get(deviceId);
            const deviceDisplayName = deviceInfo ?
              `${deviceInfo.name} (${deviceInfo.manufacturer})` :
              'Unknown Device';

            this.showConnectionStatus(true, deviceDisplayName);
            console.log(`Successfully connected to MIDI device: ${deviceDisplayName}`);

            // Show connection management info
            const connectionStatus = this.midiController.getConnectionStatus();
            console.log(`Connection state: ${connectionStatus.connectionState}, Auto-reconnect: ${connectionStatus.autoReconnectEnabled}`);

          } else {
            this.showConnectionStatus(false, '', 'error');
            console.error('Failed to connect to MIDI device');

            // Reset selection to "No device"
            this.deviceSelectElement.value = '';
          }
        } catch (error) {
          console.error('Error connecting to MIDI device:', error);
          this.showConnectionStatus(false, '', 'error');
          this.deviceSelectElement.value = '';
        }
      }

      /**
       * Handle refresh devices button click
       */
      handleRefreshDevices() {
        if (!this.midiController) {
          console.error('MIDI controller not available');
          return;
        }

        console.log('Refreshing MIDI device list...');

        // Add visual feedback for refresh action
        this.refreshButtonElement.style.transform = 'rotate(360deg)';
        this.refreshButtonElement.style.transition = 'transform 0.5s ease';

        setTimeout(() => {
          this.refreshButtonElement.style.transform = '';
          this.refreshButtonElement.style.transition = '';
        }, 500);

        // Rescan for devices
        this.midiController.scanForInputDevices();
      }

      /**
       * Handle auto-connect preference toggle
       * @param {boolean} enabled - Whether auto-connect is enabled
       */
      handleAutoConnectToggle(enabled) {
        if (!this.midiController) {
          console.error('MIDI controller not available');
          return;
        }

        console.log(`Auto-connect preference changed: ${enabled}`);

        // Update the preference in the MIDI controller
        this.midiController.preferences.setAutoConnect(enabled);

        // If auto-connect was enabled and no device is connected, try to connect now
        if (enabled && !this.midiController.isConnected && this.midiController.availableDevices.size > 0) {
          console.log('Auto-connect enabled, attempting to connect to available device...');
          setTimeout(async () => {
            await this.midiController.autoConnectToDevice();
          }, 100);
        }
      }

      /**
       * Handle MIDI device state changes
       * @param {Object} event - Device state change event
       */
      handleMIDIDeviceStateChange(event) {
        console.log('MIDI device state change:', event);

        switch (event.type) {
          case 'scan_complete':
            this.updateDeviceList(event.devices);
            break;

          case 'connected':
            this.updateDeviceList(this.midiController.availableDevices);
            break;

          case 'disconnected':
            this.updateDeviceList(this.midiController.availableDevices);
            break;

          case 'device_connected':
            const deviceInfo = event.deviceInfo;
            const displayName = deviceInfo ?
              `${deviceInfo.name} (${deviceInfo.manufacturer})` :
              'Unknown Device';
            this.showConnectionStatus(true, displayName);
            break;

          case 'auto_connected':
            // Handle automatic device connection
            const autoDeviceInfo = event.deviceInfo;
            const autoDisplayName = autoDeviceInfo ?
              `${autoDeviceInfo.name} (${autoDeviceInfo.manufacturer})` :
              'Unknown Device';

            this.showConnectionStatus(true, autoDisplayName, 'auto_connected');

            // Update the dropdown selection to reflect the auto-connected device
            if (event.device && event.device.id) {
              this.deviceSelectElement.value = event.device.id;
            }

            console.log(`Automatically connected to MIDI device: ${autoDisplayName}`);
            break;

          case 'device_disconnected':
            this.showConnectionStatus(false, '');
            this.deviceSelectElement.value = '';
            break;

          case 'device_lost':
            this.showConnectionStatus(false, '', 'error');
            this.deviceSelectElement.value = '';
            console.warn('MIDI device connection lost:', event.message);
            break;

          case 'status_update':
            // Handle status updates instead of errors
            if (event.status === 'error') {
              this.showConnectionStatus(false, '', 'error');
              this.deviceNameElement.textContent = event.message;
            } else if (event.status === 'disconnected') {
              this.showConnectionStatus(false, '');
              this.deviceNameElement.textContent = event.message || 'No device selected';
            } else if (event.status === 'connecting') {
              this.showConnectionStatus(false, '', 'connecting');
              this.deviceNameElement.textContent = event.message || 'Establishing connection...';
            }
            console.log(`MIDI Status: ${event.message}`);
            break;
        }
      }

      /**
       * Handle MIDI errors
       * @param {Object} error - Error event object
       */
      handleMIDIError(error) {
        console.error('MIDI error:', error);
        this.showConnectionStatus(false, '', 'error');

        // Show user-friendly error message based on error type
        let errorMessage = 'MIDI Error';

        if (error.message.includes('not supported')) {
          errorMessage = 'MIDI not supported in this browser';
        } else if (error.message.includes('permission')) {
          errorMessage = 'MIDI access denied';
        } else if (error.message.includes('not found')) {
          errorMessage = 'MIDI device not found';
        } else {
          errorMessage = 'MIDI connection error';
        }

        this.deviceNameElement.textContent = errorMessage;
      }

      /**
       * Update the device selection dropdown with available devices
       * @param {Map} devices - Map of available MIDI devices
       */
      updateDeviceList(devices) {
        if (!this.deviceSelectElement) return;

        // Store current selection
        const currentSelection = this.deviceSelectElement.value;

        // Clear existing options (except "No device")
        while (this.deviceSelectElement.children.length > 1) {
          this.deviceSelectElement.removeChild(this.deviceSelectElement.lastChild);
        }

        // Add available devices
        if (devices && devices.size > 0) {
          devices.forEach((device, deviceId) => {
            const option = document.createElement('option');
            option.value = deviceId;
            option.textContent = `${device.name} (${device.manufacturer})`;
            this.deviceSelectElement.appendChild(option);
          });

          console.log(`Updated device list with ${devices.size} devices`);
        } else {
          console.log('No MIDI devices available');
        }

        // Restore selection if device is still available
        if (currentSelection && devices.has(currentSelection)) {
          this.deviceSelectElement.value = currentSelection;
        } else if (currentSelection) {
          // Previously selected device is no longer available
          this.deviceSelectElement.value = '';
          this.showConnectionStatus(false, '');
        }
      }

      /**
       * Show connection status with appropriate visual indicators
       * @param {boolean} isConnected - Connection status
       * @param {string} deviceName - Name of connected device
       * @param {string} state - Optional state ('connecting', 'error')
       */
      showConnectionStatus(isConnected, deviceName = '', state = '') {
        if (!this.statusIndicatorElement || !this.deviceNameElement) return;

        // Remove all status classes
        this.statusIndicatorElement.classList.remove('connected', 'disconnected', 'connecting', 'error', 'auto-connected');

        if (state === 'connecting') {
          this.statusIndicatorElement.classList.add('connecting');
          this.statusIndicatorElement.textContent = 'Connecting...';
          this.deviceNameElement.textContent = 'Establishing connection...';
        } else if (state === 'error') {
          this.statusIndicatorElement.classList.add('error');
          this.statusIndicatorElement.textContent = 'Error';
          this.deviceNameElement.textContent = 'Connection failed';
        } else if (state === 'auto_connected' && isConnected && deviceName) {
          this.statusIndicatorElement.classList.add('auto-connected');
          this.statusIndicatorElement.textContent = 'Auto-Connected';
          this.deviceNameElement.textContent = `${deviceName} (automatic)`;

          // Add temporary visual feedback for auto-connection
          setTimeout(() => {
            if (this.statusIndicatorElement.classList.contains('auto-connected')) {
              this.statusIndicatorElement.classList.remove('auto-connected');
              this.statusIndicatorElement.classList.add('connected');
              this.statusIndicatorElement.textContent = 'Connected';
              this.deviceNameElement.textContent = deviceName;
            }
          }, 3000); // Show "Auto-Connected" for 3 seconds, then switch to "Connected"
        } else if (isConnected && deviceName) {
          this.statusIndicatorElement.classList.add('connected');
          this.statusIndicatorElement.textContent = 'Connected';
          this.deviceNameElement.textContent = deviceName;
        } else {
          this.statusIndicatorElement.classList.add('disconnected');
          this.statusIndicatorElement.textContent = 'Disconnected';
          this.deviceNameElement.textContent = 'No device selected';
        }
      }

      /**
       * Get available MIDI devices for external access
       * @returns {Map} Map of available devices
       */
      getAvailableDevices() {
        return this.midiController ? this.midiController.getAvailableDevices() : new Map();
      }

      /**
       * Get current connection status
       * @returns {Object} Connection status object
       */
      getConnectionStatus() {
        if (!this.midiController) {
          return {
            isInitialized: false,
            isConnected: false,
            connectedDevice: null,
            availableDeviceCount: 0
          };
        }

        return this.midiController.getConnectionStatus();
      }

      /**
       * Dispose of the device manager and clean up resources
       */
      dispose() {
        console.log('Disposing MIDIDeviceManager...');

        // Remove event listeners
        if (this.deviceSelectElement) {
          this.deviceSelectElement.removeEventListener('change', this.handleDeviceSelection);
        }

        if (this.refreshButtonElement) {
          this.refreshButtonElement.removeEventListener('click', this.handleRefreshDevices);
        }

        // Clear references
        this.midiController = null;
        this.deviceSelectElement = null;
        this.statusIndicatorElement = null;
        this.deviceNameElement = null;
        this.refreshButtonElement = null;
        this.isInitialized = false;

        console.log('MIDIDeviceManager disposed');
      }
      /**
       * Get comprehensive performance metrics
       * @returns {Object} Performance metrics and statistics
       */
      getPerformanceMetrics() {
        const performanceReport = this.performanceMonitor.getPerformanceReport();
        const browserInfo = this.browserCompatibility.getBrowserInfo();
        const compatibilityIssues = this.browserCompatibility.getCompatibilityIssues();

        return {
          // Basic metrics
          bufferSize: this.messageBuffer.getSize(),
          queueSize: this.messageQueue.length,
          messagesProcessed: this.performanceMonitor.getMessageCount(),

          // Performance metrics
          averageLatency: this.latencyCompensator.getAverageLatency(),
          averageProcessingTime: this.performanceMetrics.averageProcessingTime,
          peakProcessingTime: this.performanceMetrics.peakProcessingTime,

          // Error and overflow metrics
          errorCount: this.errorHandler.getErrorCount(),
          messagesDropped: this.performanceMetrics.messagesDropped,
          bufferOverflows: this.performanceMetrics.bufferOverflows,

          // Adaptive settings
          currentBatchSize: this.processingBatchSize,
          targetLatency: this.targetLatency,
          adaptiveBuffering: this.adaptiveBuffering,

          // Browser compatibility
          browserInfo: browserInfo,
          compatibilityIssues: compatibilityIssues,

          // Detailed performance report
          detailedReport: performanceReport,

          // Health status
          healthStatus: performanceReport.health,

          // Buffer status
          isHighFrequencyInput: this.messageBuffer.isHighFrequency(),

          // Connection status
          isConnected: this.isConnected,
          connectedDevice: this.connectedDevice ? {
            name: this.connectedDevice.name,
            manufacturer: this.connectedDevice.manufacturer
          } : null
        };
      }

      /**
       * Get error statistics and recent errors
       * @returns {Object} Error statistics
       */
      getErrorStatistics() {
        return this.errorHandler.getErrorStatistics();
      }

      /**
       * Get recent MIDI message log for debugging
       * @returns {Array} Recent MIDI messages with performance data
       */
      getMessageLog() {
        return [...this.midiMessageLog];
      }

      /**
       * Clear performance metrics and reset counters
       */
      clearPerformanceMetrics() {
        this.performanceMonitor.clear();
        this.errorHandler.clearErrors();
        this.latencyCompensator.reset();
        this.messageBuffer.clear();
        this.messageQueue = [];

        this.performanceMetrics = {
          messagesDropped: 0,
          averageProcessingTime: 0,
          peakProcessingTime: 0,
          bufferOverflows: 0
        };

        console.log('MIDI performance metrics cleared');
      }

      /**
       * Optimize performance settings based on current metrics
       */
      optimizePerformanceSettings() {
        const metrics = this.getPerformanceMetrics();

        // Adjust batch size based on performance
        if (metrics.averageProcessingTime > this.targetLatency * 1.5) {
          this.processingBatchSize = Math.max(1, this.processingBatchSize - 2);
          console.log(`Reduced batch size to ${this.processingBatchSize} due to high processing time`);
        } else if (metrics.averageProcessingTime < this.targetLatency * 0.5 && metrics.queueSize > 0) {
          this.processingBatchSize = Math.min(20, this.processingBatchSize + 1);
          console.log(`Increased batch size to ${this.processingBatchSize} for better throughput`);
        }

        // Adjust processing method based on browser performance
        if (metrics.browserInfo.name === 'Firefox' && metrics.averageProcessingTime > 15) {
          this.useRequestAnimationFrame = false;
          console.log('Switched to interval-based processing for Firefox optimization');
        }

        // Enable adaptive buffering if high error rate
        if (metrics.errorCount > 10 && !this.adaptiveBuffering) {
          this.adaptiveBuffering = true;
          console.log('Enabled adaptive buffering due to high error rate');
        }
      }

      /**
       * Dispose of all performance optimization resources
       */
      disposePerformanceOptimization() {
        // Stop performance monitoring
        if (this.performanceMonitor.isRunning) {
          this.performanceMonitor.stop();
        }

        // Clear processing interval
        if (this.processingInterval) {
          clearInterval(this.processingInterval);
          this.processingInterval = null;
        }

        // Clear all buffers and queues
        this.messageBuffer.clear();
        this.messageQueue = [];

        // Clear error handler
        this.errorHandler.clearErrors();

        // Reset latency compensator
        this.latencyCompensator.reset();

        console.log('MIDI performance optimization resources disposed');
      }

      /**
       * Enhanced dispose method with performance cleanup
       */
      dispose() {
        // Disconnect from device
        if (this.isConnected) {
          this.disconnectDevice();
        }

        // Dispose performance optimization resources
        this.disposePerformanceOptimization();

        // Clear all references
        this.midiAccess = null;
        this.connectedDevice = null;
        this.availableDevices.clear();
        this.isInitialized = false;

        console.log('MIDIController disposed with performance optimization cleanup');
      }
    }

    // MIDI Connection Manager for handling device connections and reconnections
    class MIDIConnectionManager {
      constructor(midiController) {
        this.midiController = midiController;
        this.connectionState = 'disconnected'; // 'disconnected', 'connecting', 'connected', 'error'
        this.connectionHistory = [];
        this.connectionStartTime = null;
        this.lastSuccessfulConnection = null;

        console.log('MIDIConnectionManager initialized');
      }

      async attemptConnection(deviceId, isRetry = false) {
        this.connectionState = 'connecting';
        this.connectionStartTime = Date.now();

        try {
          const success = await this.midiController.connectToDevice(deviceId);

          if (success) {
            this.connectionState = 'connected';
            this.lastSuccessfulConnection = {
              deviceId: deviceId,
              timestamp: Date.now(),
              connectionTime: Date.now() - this.connectionStartTime
            };

            // Save as preferred device if not a retry
            if (!isRetry) {
              this.midiController.preferences.setPreferredDevice(deviceId);
            }

            this.recordConnectionEvent('connected', deviceId, true);
            return true;
          } else {
            this.connectionState = 'error';
            this.recordConnectionEvent('failed', deviceId, false);
            return false;
          }
        } catch (error) {
          this.connectionState = 'error';
          this.recordConnectionEvent('error', deviceId, false, error.message);
          throw error;
        }
      }

      handleDisconnection(deviceId, wasUnexpected = false) {
        this.connectionState = 'disconnected';
        this.recordConnectionEvent(wasUnexpected ? 'lost' : 'disconnected', deviceId, false);

        if (wasUnexpected && this.midiController.autoReconnectEnabled) {
          this.scheduleReconnection(deviceId);
        } else {
          this.activateFallbackMode();
        }
      }

      scheduleReconnection(deviceId) {
        if (this.midiController.reconnectionAttempts >= this.midiController.maxReconnectionAttempts) {
          console.warn('Maximum reconnection attempts reached, activating fallback mode');
          this.activateFallbackMode();
          return;
        }

        this.midiController.retryManager.scheduleRetry(() => {
          return this.attemptReconnection(deviceId);
        });
      }

      async attemptReconnection(deviceId) {
        console.log(`Attempting to reconnect to MIDI device: ${deviceId}`);
        this.midiController.reconnectionAttempts++;

        try {
          const success = await this.attemptConnection(deviceId, true);

          if (success) {
            console.log('MIDI device reconnected successfully');
            this.midiController.reconnectionAttempts = 0;
            this.deactivateFallbackMode();
            return true;
          } else {
            console.warn('MIDI device reconnection failed');
            return false;
          }
        } catch (error) {
          console.error('MIDI device reconnection error:', error);
          return false;
        }
      }

      activateFallbackMode() {
        if (!this.midiController.fallbackActive) {
          console.log('Activating fallback to virtual keyboard mode');
          this.midiController.fallbackActive = true;

          if (this.midiController.onFallbackToVirtual) {
            this.midiController.onFallbackToVirtual({
              reason: 'midi_connection_lost',
              timestamp: Date.now(),
              canRetry: this.midiController.reconnectionAttempts < this.midiController.maxReconnectionAttempts
            });
          }
        }
      }

      deactivateFallbackMode() {
        if (this.midiController.fallbackActive) {
          console.log('Deactivating fallback mode - MIDI connection restored');
          this.midiController.fallbackActive = false;
        }
      }

      recordConnectionEvent(type, deviceId, success, errorMessage = null) {
        const event = {
          type: type,
          deviceId: deviceId,
          success: success,
          timestamp: Date.now(),
          errorMessage: errorMessage,
          connectionTime: this.connectionStartTime ? Date.now() - this.connectionStartTime : null
        };

        this.connectionHistory.push(event);

        // Keep only last 50 events
        if (this.connectionHistory.length > 50) {
          this.connectionHistory.shift();
        }

        console.log(`MIDI connection event: ${type} - ${success ? 'Success' : 'Failed'}`, event);
      }

      getConnectionStatus() {
        return {
          state: this.connectionState,
          lastSuccessfulConnection: this.lastSuccessfulConnection,
          reconnectionAttempts: this.midiController.reconnectionAttempts,
          maxReconnectionAttempts: this.midiController.maxReconnectionAttempts,
          fallbackActive: this.midiController.fallbackActive,
          connectionHistory: this.connectionHistory.slice(-10) // Last 10 events
        };
      }
    }

    // MIDI Preferences Manager for persistent device preferences
    class MIDIPreferences {
      constructor() {
        this.storageKey = 'pianoTutorMIDIPreferences';
        this.preferences = this.loadPreferences();

        console.log('MIDIPreferences initialized', this.preferences);
      }

      loadPreferences() {
        try {
          const stored = localStorage.getItem(this.storageKey);
          if (stored) {
            const parsed = JSON.parse(stored);
            return {
              preferredDeviceId: parsed.preferredDeviceId || null,
              preferredDeviceName: parsed.preferredDeviceName || null,
              autoConnect: parsed.autoConnect !== undefined ? parsed.autoConnect : true,
              autoReconnect: parsed.autoReconnect !== undefined ? parsed.autoReconnect : true,
              maxReconnectionAttempts: parsed.maxReconnectionAttempts || 5,
              velocitySensitivity: parsed.velocitySensitivity || 1.0,
              channelFilter: parsed.channelFilter || null,
              lastConnected: parsed.lastConnected || null,
              connectionHistory: parsed.connectionHistory || []
            };
          }
        } catch (error) {
          console.warn('Failed to load MIDI preferences:', error);
        }

        return this.getDefaultPreferences();
      }

      getDefaultPreferences() {
        return {
          preferredDeviceId: null,
          preferredDeviceName: null,
          autoConnect: true,
          autoReconnect: true,
          maxReconnectionAttempts: 5,
          velocitySensitivity: 1.0,
          channelFilter: null,
          lastConnected: null,
          connectionHistory: []
        };
      }

      savePreferences() {
        try {
          localStorage.setItem(this.storageKey, JSON.stringify(this.preferences));
          console.log('MIDI preferences saved successfully');
          return true;
        } catch (error) {
          console.error('Failed to save MIDI preferences:', error);
          return false;
        }
      }

      setPreferredDevice(deviceId, deviceName = null) {
        this.preferences.preferredDeviceId = deviceId;
        this.preferences.preferredDeviceName = deviceName;
        this.preferences.lastConnected = Date.now();

        // Add to connection history
        this.preferences.connectionHistory.unshift({
          deviceId: deviceId,
          deviceName: deviceName,
          timestamp: Date.now()
        });

        // Keep only last 10 connections
        if (this.preferences.connectionHistory.length > 10) {
          this.preferences.connectionHistory = this.preferences.connectionHistory.slice(0, 10);
        }

        this.savePreferences();
        console.log(`Preferred MIDI device set: ${deviceId} (${deviceName})`);
      }

      getPreferredDevice() {
        return {
          deviceId: this.preferences.preferredDeviceId,
          deviceName: this.preferences.preferredDeviceName,
          lastConnected: this.preferences.lastConnected
        };
      }

      setAutoConnect(enabled) {
        this.preferences.autoConnect = enabled;
        this.savePreferences();
      }

      setAutoReconnect(enabled) {
        this.preferences.autoReconnect = enabled;
        this.savePreferences();
      }

      setMaxReconnectionAttempts(attempts) {
        this.preferences.maxReconnectionAttempts = Math.max(1, Math.min(10, attempts));
        this.savePreferences();
      }

      setVelocitySensitivity(sensitivity) {
        this.preferences.velocitySensitivity = Math.max(0.1, Math.min(2.0, sensitivity));
        this.savePreferences();
      }

      getConnectionHistory() {
        return this.preferences.connectionHistory.slice();
      }

      clearPreferences() {
        this.preferences = this.getDefaultPreferences();
        this.savePreferences();
        console.log('MIDI preferences cleared');
      }

      exportPreferences() {
        return JSON.stringify(this.preferences, null, 2);
      }

      importPreferences(preferencesJson) {
        try {
          const imported = JSON.parse(preferencesJson);
          this.preferences = {...this.getDefaultPreferences(), ...imported};
          this.savePreferences();
          console.log('MIDI preferences imported successfully');
          return true;
        } catch (error) {
          console.error('Failed to import MIDI preferences:', error);
          return false;
        }
      }
    }

    // MIDI Retry Manager for exponential backoff reconnection logic
    class MIDIRetryManager {
      constructor(midiController) {
        this.midiController = midiController;
        this.retryTimeouts = new Map();
        this.baseDelay = 1000; // 1 second base delay
        this.maxDelay = 30000; // 30 seconds maximum delay
        this.backoffMultiplier = 2;
        this.jitterFactor = 0.1; // 10% jitter to avoid thundering herd

        console.log('MIDIRetryManager initialized');
      }

      scheduleRetry(retryFunction, attempt = 1) {
        const retryId = `retry_${Date.now()}_${Math.random()}`;

        // Calculate delay with exponential backoff
        const baseDelayMs = Math.min(
          this.baseDelay * Math.pow(this.backoffMultiplier, attempt - 1),
          this.maxDelay
        );

        // Add jitter to prevent synchronized retries
        const jitter = baseDelayMs * this.jitterFactor * (Math.random() - 0.5);
        const delayMs = Math.max(100, baseDelayMs + jitter);

        console.log(`Scheduling retry attempt ${attempt} in ${Math.round(delayMs)}ms`);

        const timeoutId = setTimeout(async () => {
          this.retryTimeouts.delete(retryId);

          try {
            const success = await retryFunction();

            if (!success && attempt < this.midiController.maxReconnectionAttempts) {
              // Schedule next retry with increased delay
              this.scheduleRetry(retryFunction, attempt + 1);
            } else if (!success) {
              console.warn('Maximum retry attempts reached, giving up');
              this.midiController.connectionManager.activateFallbackMode();
            }
          } catch (error) {
            console.error(`Retry attempt ${attempt} failed:`, error);

            if (attempt < this.midiController.maxReconnectionAttempts) {
              this.scheduleRetry(retryFunction, attempt + 1);
            } else {
              this.midiController.connectionManager.activateFallbackMode();
            }
          }
        }, delayMs);

        this.retryTimeouts.set(retryId, {
          timeoutId: timeoutId,
          attempt: attempt,
          scheduledTime: Date.now(),
          delayMs: delayMs
        });

        return retryId;
      }

      cancelRetry(retryId) {
        const retry = this.retryTimeouts.get(retryId);
        if (retry) {
          clearTimeout(retry.timeoutId);
          this.retryTimeouts.delete(retryId);
          console.log(`Cancelled retry attempt ${retry.attempt}`);
          return true;
        }
        return false;
      }

      cancelAllRetries() {
        console.log(`Cancelling ${this.retryTimeouts.size} pending retry attempts`);

        for (const [retryId, retry] of this.retryTimeouts) {
          clearTimeout(retry.timeoutId);
        }

        this.retryTimeouts.clear();
      }

      getRetryStatus() {
        const activeRetries = Array.from(this.retryTimeouts.values()).map(retry => ({
          attempt: retry.attempt,
          scheduledTime: retry.scheduledTime,
          delayMs: retry.delayMs,
          timeRemaining: Math.max(0, (retry.scheduledTime + retry.delayMs) - Date.now())
        }));

        return {
          activeRetries: activeRetries,
          totalActiveRetries: activeRetries.length,
          nextRetryIn: activeRetries.length > 0 ? Math.min(...activeRetries.map(r => r.timeRemaining)) : null
        };
      }
    }

    // MIDI Controller class for device management and message handling
    class MIDIController {
      constructor() {
        this.midiAccess = null;
        this.connectedDevice = null;
        this.availableDevices = new Map();
        this.isConnected = false;
        this.isInitialized = false;
        this.onNotePressed = null;
        this.onNoteReleased = null;
        this.onDeviceStateChange = null;
        this.onError = null;

        // MIDI message parsing constants
        this.MIDI_NOTE_ON = 0x90;
        this.MIDI_NOTE_OFF = 0x80;
        this.MIDI_CONTROL_CHANGE = 0xB0;
        this.MIDI_PROGRAM_CHANGE = 0xC0;
        this.MIDI_PITCH_BEND = 0xE0;

        // Enhanced MIDI processing settings
        this.channelFilter = null; // null = accept all channels, array = specific channels
        this.velocitySensitivity = 1.0; // 1.0 = linear, <1.0 = more sensitive, >1.0 = less sensitive
        this.debugMode = false; // Enable detailed logging
        this.midiMessageLog = []; // Store recent MIDI messages for debugging

        // Statistics tracking
        this.statistics = {
          messagesReceived: 0,
          notesPressed: 0,
          notesReleased: 0,
          controlChanges: 0,
          errors: 0,
          lastActivity: null
        };

        // Connection management and preferences
        this.connectionManager = new MIDIConnectionManager(this);
        this.preferences = new MIDIPreferences();
        this.retryManager = new MIDIRetryManager(this);

        // Auto-reconnection settings
        this.autoReconnectEnabled = true;
        this.reconnectionAttempts = 0;
        this.maxReconnectionAttempts = 5;
        this.lastConnectedDeviceId = null;

        // Graceful fallback handling
        this.onFallbackToVirtual = null;
        this.fallbackActive = false;

        // PERFORMANCE OPTIMIZATION COMPONENTS
        this.messageBuffer = new MIDIMessageBuffer();
        this.latencyCompensator = new MIDILatencyCompensator();
        this.errorHandler = new MIDIErrorHandler();
        this.browserCompatibility = new MIDIBrowserCompatibility();
        this.performanceMonitor = new MIDIPerformanceMonitor();

        // High-frequency message handling
        this.messageQueue = [];
        this.processingInterval = null;
        this.maxQueueSize = 1000;
        this.processingBatchSize = 10;

        // Real-time processing settings
        this.useRequestAnimationFrame = true;
        this.targetLatency = 10; // milliseconds
        this.adaptiveBuffering = true;

        // Performance metrics
        this.performanceMetrics = {
          messagesDropped: 0,
          averageProcessingTime: 0,
          peakProcessingTime: 0,
          bufferOverflows: 0
        };

        console.log('MIDIController initialized with enhanced message processing, connection management, and performance optimization');
      }

      /**
       * Initialize Web MIDI API with browser compatibility checks and performance optimization
       * @returns {Promise<boolean>} Success status
       */
      async initializeMIDI() {
        try {
          // Apply browser-specific compatibility workarounds
          await this.browserCompatibility.applyWorkarounds();

          // Enhanced MIDI API support check
          if (!this.browserCompatibility.isMIDISupported()) {
            const error = new Error('Web MIDI API not supported or blocked in this browser');
            this.updateMIDIStatus('error', 'MIDI not supported in this browser');
            this.errorHandler.handleInitializationError(error);
            return false;
          }

          console.log('Requesting MIDI access with performance optimizations...');

          // Request MIDI access with optimized settings
          this.midiAccess = await navigator.requestMIDIAccess({
            sysex: false, // We don't need system exclusive messages
            software: true // Allow software MIDI devices
          });

          // Set up device state change monitoring for hot-plugging
          this.midiAccess.onstatechange = (event) => {
            console.log('MIDI device state changed:', event);
            this.handleDeviceStateChange(event);
          };

          // Initialize performance monitoring
          this.performanceMonitor.start();

          // Start optimized message processing loop
          this.startOptimizedMessageProcessing();

          // Scan for available input devices
          this.scanForInputDevices();

          this.isInitialized = true;
          this.initTime = Date.now(); // Track initialization time for statistics

          // Load user preferences
          this.autoReconnectEnabled = this.preferences.preferences.autoReconnect;
          this.maxReconnectionAttempts = this.preferences.preferences.maxReconnectionAttempts;
          this.velocitySensitivity = this.preferences.preferences.velocitySensitivity;

          // Set up error handler user notification
          this.errorHandler.setUserNotificationCallback((message) => {
            console.warn(`MIDI User Notification: ${message}`);
            // Could dispatch event for UI to handle
            window.dispatchEvent(new CustomEvent('midiUserNotification', {detail: message}));
          });

          console.log('MIDI system initialized successfully with performance optimization');
          console.log(`Found ${this.availableDevices.size} MIDI input devices`);
          console.log(`Browser: ${this.browserCompatibility.getBrowserInfo().name} ${this.browserCompatibility.getBrowserInfo().version}`);

          // Attempt auto-connection to preferred device if enabled
          if (this.preferences.preferences.autoConnect) {
            await this.attemptAutoConnection();
          }

          return true;
        } catch (error) {
          console.error('MIDI initialization failed:', error);
          this.updateMIDIStatus('error', 'MIDI initialization failed');
          this.errorHandler.handleInitializationError(error);
          return false;
        }
      }

      /**
       * Start optimized message processing loop with adaptive performance
       */
      startOptimizedMessageProcessing() {
        if (this.useRequestAnimationFrame) {
          // Use requestAnimationFrame for smooth, frame-synchronized processing
          const processMessages = () => {
            this.processOptimizedMessageQueue();
            if (this.isInitialized) {
              requestAnimationFrame(processMessages);
            }
          };
          requestAnimationFrame(processMessages);
        } else {
          // Use high-frequency interval for maximum responsiveness
          this.processingInterval = setInterval(() => {
            this.processOptimizedMessageQueue();
          }, 1); // 1ms interval for real-time processing
        }

        console.log(`Started optimized MIDI message processing (${this.useRequestAnimationFrame ? 'RAF' : 'Interval'} mode)`);
      }

      /**
       * Process message queue with performance optimization and adaptive batching
       */
      processOptimizedMessageQueue() {
        if (this.messageQueue.length === 0) return;

        const startTime = performance.now();
        const batchSize = Math.min(this.processingBatchSize, this.messageQueue.length);

        // Process messages in batches for optimal performance
        for (let i = 0; i < batchSize; i++) {
          const message = this.messageQueue.shift();
          if (message) {
            try {
              this.processOptimizedMIDIMessage(message);
            } catch (error) {
              this.errorHandler.handleProcessingError(error, message);
            }
          }
        }

        const processingTime = performance.now() - startTime;
        this.performanceMonitor.recordProcessingTime(processingTime);

        // Update performance metrics
        this.performanceMetrics.averageProcessingTime = this.performanceMonitor.getAverageProcessingTime();
        if (processingTime > this.performanceMetrics.peakProcessingTime) {
          this.performanceMetrics.peakProcessingTime = processingTime;
        }

        // Adaptive batch size adjustment for optimal performance
        if (this.adaptiveBuffering) {
          this.adjustBatchSizeForPerformance(processingTime);
        }
      }

      /**
       * Adjust batch size based on processing performance
       * @param {number} processingTime - Time taken to process current batch
       */
      adjustBatchSizeForPerformance(processingTime) {
        if (processingTime > this.targetLatency) {
          // Reduce batch size if processing is too slow
          this.processingBatchSize = Math.max(1, this.processingBatchSize - 1);
        } else if (processingTime < this.targetLatency / 2 && this.messageQueue.length > this.processingBatchSize) {
          // Increase batch size if we can handle more without exceeding target latency
          this.processingBatchSize = Math.min(50, this.processingBatchSize + 1);
        }
      }

      /**
       * Process individual MIDI message with full optimization pipeline
       * @param {Object} message - Enhanced MIDI message with optimization data
       */
      processOptimizedMIDIMessage(message) {
        try {
          // Apply latency compensation
          const compensatedMessage = this.latencyCompensator.applyCompensation(message);

          // Record performance metrics
          this.performanceMonitor.recordMessage();
          this.performanceMonitor.recordLatency(message.receivedAt - message.timeStamp);

          // Standard MIDI message processing with enhanced error handling
          const [command, note, velocity] = compensatedMessage.data;
          const commandType = command & 0xF0;
          const channel = command & 0x0F;

          // Enhanced MIDI message logging
          this.logOptimizedMIDIMessage(compensatedMessage, commandType, channel);

          // Process message based on command type
          switch (commandType) {
            case this.MIDI_NOTE_ON:
              if (velocity > 0) {
                this.handleOptimizedNoteOn(note, velocity, channel, compensatedMessage);
                this.updateStatistics('note_on');
              } else {
                // Note on with velocity 0 is equivalent to note off
                this.handleOptimizedNoteOff(note, 0, channel, compensatedMessage);
                this.updateStatistics('note_off');
              }
              break;

            case this.MIDI_NOTE_OFF:
              this.handleOptimizedNoteOff(note, velocity, channel, compensatedMessage);
              this.updateStatistics('note_off');
              break;

            case this.MIDI_CONTROL_CHANGE:
              this.handleControlChange(note, velocity, channel, compensatedMessage.timeStamp);
              this.updateStatistics('control_change');
              break;

            case this.MIDI_PROGRAM_CHANGE:
              this.handleProgramChange(note, channel, compensatedMessage.timeStamp);
              this.updateStatistics('program_change');
              break;

            case this.MIDI_PITCH_BEND:
              this.handlePitchBend(note, velocity, channel, compensatedMessage.timeStamp);
              this.updateStatistics('pitch_bend');
              break;

            default:
              this.logDebug(`Unhandled MIDI command: 0x${commandType.toString(16).toUpperCase()}`);
              this.updateStatistics('unknown');
              break;
          }
        } catch (error) {
          this.errorHandler.handleProcessingError(error, message);
          this.updateStatistics('error');
        }
      }

      /**
       * Handle optimized MIDI note on with enhanced processing
       * @param {number} note - MIDI note number
       * @param {number} velocity - Note velocity
       * @param {number} channel - MIDI channel
       * @param {Object} message - Enhanced message object
       */
      handleOptimizedNoteOn(note, velocity, channel, message) {
        if (!this.isChannelAllowed(channel)) {
          this.logDebug(`Filtered MIDI Note On: Channel ${channel} not allowed`);
          return;
        }

        const noteName = this.convertMIDINoteToName(note);
        const normalizedVelocity = this.applyVelocitySensitivity(velocity / 127);

        // Create enhanced note data with performance metrics
        const noteData = {
          note: noteName,
          velocity: normalizedVelocity,
          rawVelocity: velocity,
          channel: channel,
          source: 'midi',
          timestamp: message.timeStamp,
          latency: message.originalLatency || 0,
          compensated: message.latencyCompensated || false,
          deviceName: this.connectedDevice ? this.connectedDevice.name : 'Unknown Device'
        };

        // Forward to application with enhanced data
        if (this.onNotePressed) {
          this.onNotePressed(noteData);
        }

        this.logDebug(`🎹 Optimized MIDI Note ON: ${noteName} (${note}) vel=${velocity} ch=${channel} latency=${noteData.latency.toFixed(1)}ms`);
      }

      /**
       * Handle optimized MIDI note off with enhanced processing
       * @param {number} note - MIDI note number
       * @param {number} velocity - Release velocity
       * @param {number} channel - MIDI channel
       * @param {Object} message - Enhanced message object
       */
      handleOptimizedNoteOff(note, velocity, channel, message) {
        if (!this.isChannelAllowed(channel)) {
          this.logDebug(`Filtered MIDI Note Off: Channel ${channel} not allowed`);
          return;
        }

        const noteName = this.convertMIDINoteToName(note);

        // Create enhanced note release data
        const noteData = {
          note: noteName,
          velocity: velocity / 127,
          rawVelocity: velocity,
          channel: channel,
          source: 'midi',
          timestamp: message.timeStamp,
          latency: message.originalLatency || 0,
          compensated: message.latencyCompensated || false,
          deviceName: this.connectedDevice ? this.connectedDevice.name : 'Unknown Device'
        };

        // Forward to application
        if (this.onNoteReleased) {
          this.onNoteReleased(noteData);
        }

        this.logDebug(`🎹 Optimized MIDI Note OFF: ${noteName} (${note}) vel=${velocity} ch=${channel} latency=${noteData.latency.toFixed(1)}ms`);
      }

      /**
       * Enhanced MIDI message logging with performance data
       * @param {Object} message - Enhanced MIDI message
       * @param {number} commandType - Parsed command type
       * @param {number} channel - MIDI channel
       */
      logOptimizedMIDIMessage(message, commandType, channel) {
        if (!this.debugMode) return;

        const [command, note, velocity] = message.data;
        const timestamp = new Date(message.timeStamp || Date.now()).toISOString();

        // Create detailed log entry with performance data
        const logEntry = {
          timestamp: timestamp,
          rawData: Array.from(message.data).map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' '),
          command: `0x${commandType.toString(16).toUpperCase()}`,
          channel: channel,
          note: note,
          velocity: velocity,
          noteName: (commandType === this.MIDI_NOTE_ON || commandType === this.MIDI_NOTE_OFF)
            ? this.convertMIDINoteToName(note) : null,
          latency: message.originalLatency || 0,
          compensated: message.latencyCompensated || false,
          buffered: message.bufferedAt ? (message.timeStamp - message.bufferedAt) : 0
        };

        // Store detailed log entry for debugging
        if (!this.midiMessageLog) {
          this.midiMessageLog = [];
        }
        this.midiMessageLog.push(logEntry);

        // Keep only last 100 messages to prevent memory issues
        if (this.midiMessageLog.length > 100) {
          this.midiMessageLog.shift();
        }
      }

      /**
       * Scan for and enumerate available MIDI input devices
       */
      scanForInputDevices() {
        if (!this.midiAccess) {
          console.warn('MIDI access not available for device scanning');
          return;
        }

        // Clear existing device list
        this.availableDevices.clear();

        console.log('Scanning for MIDI input devices...');

        // Iterate through all MIDI inputs
        for (let input of this.midiAccess.inputs.values()) {
          if (input.state === 'connected') {
            const deviceInfo = {
              id: input.id,
              name: input.name || 'Unknown Device',
              manufacturer: input.manufacturer || 'Unknown Manufacturer',
              type: input.type || 'input',
              connection: input.connection,
              state: input.state,
              version: input.version || 'Unknown'
            };

            this.availableDevices.set(input.id, deviceInfo);
            console.log(`Found MIDI device: ${deviceInfo.name} (${deviceInfo.manufacturer})`);
          }
        }

        console.log(`Device scan complete. Found ${this.availableDevices.size} available devices`);

        // Notify listeners about device list update
        if (this.onDeviceStateChange) {
          this.onDeviceStateChange({
            type: 'scan_complete',
            devices: this.availableDevices
          });
        }

        // Attempt automatic connection if devices were found and no device is currently connected
        if (!this.isConnected && this.availableDevices.size > 0 && this.preferences.preferences.autoConnect) {
          console.log('MIDI devices found during scan, attempting automatic connection...');
          setTimeout(async () => {
            await this.autoConnectToDevice();
          }, 200); // Small delay to ensure UI is updated first
        }
      }

      /**
       * Handle MIDI device state changes (hot-plugging support)
       * @param {MIDIConnectionEvent} event - MIDI connection event
       */
      handleDeviceStateChange(event) {
        const port = event.port;
        console.log(`MIDI device ${port.state}: ${port.name} (${port.manufacturer})`);

        if (port.type === 'input') {
          if (port.state === 'connected') {
            // Device connected
            const deviceInfo = {
              id: port.id,
              name: port.name || 'Unknown Device',
              manufacturer: port.manufacturer || 'Unknown Manufacturer',
              type: port.type,
              connection: port.connection,
              state: port.state,
              version: port.version || 'Unknown'
            };

            this.availableDevices.set(port.id, deviceInfo);
            console.log(`MIDI device connected: ${deviceInfo.name}`);

            // Attempt automatic connection if no device is currently connected and auto-connect is enabled
            if (!this.isConnected && this.preferences.preferences.autoConnect) {
              console.log('New MIDI device detected, attempting automatic connection...');
              setTimeout(async () => {
                await this.autoConnectToDevice();
              }, 100); // Small delay to ensure device is fully ready
            }

          } else if (port.state === 'disconnected') {
            // Device disconnected
            this.availableDevices.delete(port.id);
            console.log(`MIDI device disconnected: ${port.name}`);

            // If this was our connected device, handle disconnection
            if (this.connectedDevice && this.connectedDevice.id === port.id) {
              this.handleDeviceDisconnection();
            }
          }

          // Notify listeners about device state change
          if (this.onDeviceStateChange) {
            this.onDeviceStateChange({
              type: port.state,
              device: port,
              devices: this.availableDevices
            });
          }
        }
      }

      /**
       * Attempt automatic connection to preferred device
       */
      async attemptAutoConnection() {
        const preferredDevice = this.preferences.getPreferredDevice();

        if (!preferredDevice.deviceId) {
          console.log('No preferred MIDI device set, attempting auto-connection to first available device');
          return await this.autoConnectToDevice();
        }

        // Check if preferred device is available
        if (this.availableDevices.has(preferredDevice.deviceId)) {
          console.log(`Attempting auto-connection to preferred device: ${preferredDevice.deviceName}`);

          try {
            const success = await this.connectionManager.attemptConnection(preferredDevice.deviceId);
            if (success) {
              console.log('Auto-connection successful');
              return true;
            } else {
              console.warn('Auto-connection failed, device may not be available');
            }
          } catch (error) {
            console.error('Auto-connection error:', error);
          }
        }

        // If preferred device connection failed, try auto-connecting to first available device
        console.log('Preferred device not available, attempting auto-connection to first available device');
        return await this.autoConnectToDevice();
      }

      /**
       * Automatically connect to the first available MIDI device
       * @returns {Promise<boolean>} Connection success status
       */
      async autoConnectToDevice() {
        if (!this.preferences.preferences.autoConnect) {
          console.log('Automatic MIDI device connection is disabled in preferences');
          return false;
        }

        if (this.isConnected) {
          console.log('MIDI device already connected, skipping auto-connection');
          return true;
        }

        if (this.availableDevices.size === 0) {
          console.log('No MIDI devices available for auto-connection');
          return false;
        }

        // Get the first available device
        const firstDeviceId = this.availableDevices.keys().next().value;
        const firstDevice = this.availableDevices.get(firstDeviceId);

        console.log(`Auto-connecting to first available MIDI device: ${firstDevice.name} (${firstDevice.manufacturer})`);

        try {
          const success = await this.connectToDevice(firstDeviceId);

          if (success) {
            console.log(`Successfully auto-connected to MIDI device: ${firstDevice.name}`);

            // Notify UI about automatic connection
            if (this.onDeviceStateChange) {
              this.onDeviceStateChange({
                type: 'auto_connected',
                device: this.connectedDevice,
                deviceInfo: firstDevice,
                message: `Automatically connected to ${firstDevice.name}`
              });
            }

            return true;
          } else {
            console.warn(`Failed to auto-connect to device: ${firstDevice.name}`);
            return false;
          }
        } catch (error) {
          console.error('Auto-connection error:', error);
          this.handleError(error);
          return false;
        }
      }

      /**
       * Connect to a specific MIDI device
       * @param {string} deviceId - MIDI device ID
       * @returns {Promise<boolean>} Connection success status
       */
      async connectToDevice(deviceId) {
        try {
          if (!this.midiAccess) {
            console.warn('MIDI system not initialized');
            this.updateMIDIStatus('error', 'MIDI system not initialized');
            return false;
          }

          const device = this.midiAccess.inputs.get(deviceId);

          if (!device) {
            console.warn(`MIDI device ${deviceId} not found`);
            this.updateMIDIStatus('error', 'MIDI device not found');
            return false;
          }

          if (device.state !== 'connected') {
            console.warn(`MIDI device ${device.name} is not connected`);
            this.updateMIDIStatus('error', `Device ${device.name} is not connected`);
            return false;
          }

          // Disconnect from previous device if connected
          if (this.connectedDevice) {
            this.disconnectDevice();
          }

          // Set up MIDI message handler
          device.onmidimessage = (message) => {
            this.handleMIDIMessage(message);
          };

          // Handle device disconnection
          device.onstatechange = (event) => {
            if (event.port.state === 'disconnected') {
              this.handleDeviceDisconnection(true); // Mark as unexpected
            }
          };

          this.connectedDevice = device;
          this.isConnected = true;
          this.lastConnectedDeviceId = deviceId;
          this.reconnectionAttempts = 0; // Reset retry counter on successful connection

          // Store device info in preferences
          const deviceInfo = this.availableDevices.get(deviceId);
          if (deviceInfo) {
            this.preferences.setPreferredDevice(deviceId, deviceInfo.name);
          }

          console.log(`Connected to MIDI device: ${device.name} (${device.manufacturer})`);

          // Notify listeners about successful connection
          if (this.onDeviceStateChange) {
            this.onDeviceStateChange({
              type: 'device_connected',
              device: device,
              deviceInfo: this.availableDevices.get(deviceId)
            });
          }

          return true;
        } catch (error) {
          console.error('Failed to connect to MIDI device:', error);
          this.handleError(error);
          return false;
        }
      }

      /**
       * Disconnect from current MIDI device
       */
      disconnectDevice() {
        if (this.connectedDevice) {
          console.log(`Disconnecting from MIDI device: ${this.connectedDevice.name}`);

          // Remove message handler
          this.connectedDevice.onmidimessage = null;
          this.connectedDevice.onstatechange = null;

          const deviceId = this.connectedDevice.id;
          const deviceName = this.connectedDevice.name;

          this.connectedDevice = null;
          this.isConnected = false;

          // Cancel any pending retry attempts
          this.retryManager.cancelAllRetries();

          // Handle disconnection through connection manager
          this.connectionManager.handleDisconnection(deviceId, false);

          // Notify listeners about disconnection
          if (this.onDeviceStateChange) {
            this.onDeviceStateChange({
              type: 'device_disconnected',
              deviceName: deviceName
            });
          }

          console.log('MIDI device disconnected');
        }
      }

      /**
       * Handle unexpected device disconnection
       * @param {boolean} wasUnexpected - Whether the disconnection was unexpected
       */
      handleDeviceDisconnection(wasUnexpected = true) {
        if (this.isConnected) {
          console.warn('MIDI device unexpectedly disconnected');
          const deviceId = this.connectedDevice ? this.connectedDevice.id : null;
          const deviceName = this.connectedDevice ? this.connectedDevice.name : 'Unknown Device';

          this.connectedDevice = null;
          this.isConnected = false;

          // Handle disconnection through connection manager
          if (deviceId) {
            this.connectionManager.handleDisconnection(deviceId, wasUnexpected);
          }

          // Notify listeners about unexpected disconnection
          if (this.onDeviceStateChange) {
            this.onDeviceStateChange({
              type: 'device_lost',
              deviceName: deviceName,
              message: 'MIDI device connection lost. Please reconnect your device.'
            });
          }
        }
      }

      /**
       * Handle incoming MIDI messages with performance optimization pipeline
       * @param {MIDIMessageEvent} message - MIDI message event
       */
      handleMIDIMessage(message) {
        try {
          // Validate message data with enhanced error handling
          if (!this.validateMIDIMessage(message)) {
            return;
          }

          // Create enhanced message with performance tracking
          // Explicitly copy all MIDI message properties to ensure nothing is lost
          const enhancedMessage = {
            data: message.data,
            timeStamp: message.timeStamp,
            target: message.target,
            type: message.type,
            // Add any additional properties from the original message
            ...message,
            // Override with our enhanced properties
            receivedAt: performance.now(),
            compensatedTimestamp: this.latencyCompensator.compensateLatency(message.timeStamp || performance.now())
          };

          // Update statistics
          this.updateStatistics('message_received');

          // Check for high-frequency input and apply buffering if needed
          if (this.messageBuffer.shouldBuffer(enhancedMessage)) {
            this.messageBuffer.addMessage(enhancedMessage);
            return;
          }

          // Add to processing queue with overflow protection
          if (this.messageQueue.length < this.maxQueueSize) {
            this.messageQueue.push(enhancedMessage);
          } else {
            // Handle queue overflow
            this.errorHandler.handleQueueOverflow();
            this.performanceMetrics.bufferOverflows++;

            // Drop oldest message and add new one (FIFO with overflow protection)
            const droppedMessage = this.messageQueue.shift();
            this.messageQueue.push(enhancedMessage);
            this.performanceMetrics.messagesDropped++;

            console.warn('MIDI message queue overflow - dropped message:', droppedMessage);
          }

        } catch (error) {
          this.errorHandler.handleMessageError(error, message);
          this.updateStatistics('error');
        }
      }

      /**
       * Validate MIDI message data for malformed messages
       * @param {MIDIMessageEvent} message - MIDI message event
       * @returns {boolean} True if message is valid
       */
      validateMIDIMessage(message) {
        if (!message || !message.data) {
          this.logError('Invalid MIDI message: missing data');
          return false;
        }

        if (message.data.length < 2) {
          this.logError(`Invalid MIDI message: insufficient data length (${message.data.length})`);
          return false;
        }

        const [command, note, velocity] = message.data;

        // Validate command byte
        if (command < 0x80 || command > 0xFF) {
          this.logError(`Invalid MIDI command byte: 0x${command.toString(16)}`);
          return false;
        }

        // Validate note number for note messages
        const commandType = command & 0xF0;
        if (commandType === this.MIDI_NOTE_ON || commandType === this.MIDI_NOTE_OFF) {
          if (note < 0 || note > 127) {
            this.logError(`Invalid MIDI note number: ${note} (must be 0-127)`);
            return false;
          }

          if (velocity < 0 || velocity > 127) {
            this.logError(`Invalid MIDI velocity: ${velocity} (must be 0-127)`);
            return false;
          }
        }

        // Validate control change messages
        if (commandType === this.MIDI_CONTROL_CHANGE) {
          if (note < 0 || note > 127) {
            this.logError(`Invalid MIDI controller number: ${note} (must be 0-127)`);
            return false;
          }

          if (velocity < 0 || velocity > 127) {
            this.logError(`Invalid MIDI controller value: ${velocity} (must be 0-127)`);
            return false;
          }
        }

        return true;
      }

      /**
       * Enhanced MIDI message logging with debugging capabilities
       * @param {MIDIMessageEvent} message - MIDI message event
       * @param {number} commandType - Parsed command type
       * @param {number} channel - MIDI channel
       */
      logMIDIMessage(message, commandType, channel) {
        const [command, note, velocity] = message.data;
        const timestamp = new Date(message.timeStamp || Date.now()).toISOString();

        // Create detailed log entry
        const logEntry = {
          timestamp: timestamp,
          rawData: Array.from(message.data).map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' '),
          command: `0x${commandType.toString(16).toUpperCase()}`,
          channel: channel,
          note: note,
          velocity: velocity,
          noteName: (commandType === this.MIDI_NOTE_ON || commandType === this.MIDI_NOTE_OFF)
            ? this.convertMIDINoteToName(note) : null
        };

        // Log based on message type
        switch (commandType) {
          case this.MIDI_NOTE_ON:
            if (velocity > 0) {
              this.logDebug(`🎹 MIDI Note ON: ${logEntry.noteName} (${note}) vel=${velocity} ch=${channel}`);
            } else {
              this.logDebug(`🎹 MIDI Note OFF (vel=0): ${logEntry.noteName} (${note}) ch=${channel}`);
            }
            break;
          case this.MIDI_NOTE_OFF:
            this.logDebug(`🎹 MIDI Note OFF: ${logEntry.noteName} (${note}) vel=${velocity} ch=${channel}`);
            break;
          case this.MIDI_CONTROL_CHANGE:
            this.logDebug(`🎛️ MIDI CC: Controller=${note} Value=${velocity} ch=${channel}`);
            break;
          default:
            this.logDebug(`📨 MIDI Message: ${logEntry.rawData}`);
            break;
        }

        // Store detailed log entry for debugging
        if (!this.midiMessageLog) {
          this.midiMessageLog = [];
        }
        this.midiMessageLog.push(logEntry);

        // Keep only last 100 messages to prevent memory issues
        if (this.midiMessageLog.length > 100) {
          this.midiMessageLog.shift();
        }
      }

      /**
       * Handle MIDI message processing errors
       * @param {Error} error - Error that occurred
       * @param {MIDIMessageEvent} message - Original MIDI message
       */
      handleMIDIMessageError(error, message) {
        const errorInfo = {
          error: error.message,
          timestamp: Date.now(),
          messageData: message ? Array.from(message.data || []) : null,
          rawMessage: message ? message.data : null
        };

        this.logError(`MIDI message processing error: ${error.message}`);
        console.error('MIDI Message Error Details:', errorInfo);

        // Notify error handler
        if (this.onError) {
          this.onError({
            type: 'midi_message_error',
            error: error,
            message: error.message,
            messageData: errorInfo.messageData,
            timestamp: errorInfo.timestamp
          });
        }
      }

      /**
       * Handle MIDI note on messages with enhanced velocity processing
       * @param {number} midiNote - MIDI note number (0-127)
       * @param {number} velocity - Note velocity (0-127)
       * @param {number} channel - MIDI channel (0-15)
       * @param {number} timestamp - Message timestamp
       */
      handleNoteOn(midiNote, velocity, channel, timestamp) {
        // Skip processing if channel filtering is active and channel doesn't match
        if (!this.isChannelAllowed(channel)) {
          this.logDebug(`Filtered MIDI Note On: Channel ${channel} not allowed`);
          return;
        }

        const noteName = this.convertMIDINoteToName(midiNote);
        if (noteName === 'INVALID') {
          return; // Skip invalid notes
        }

        // Enhanced velocity processing with sensitivity curve
        const processedVelocity = this.processVelocity(velocity);

        this.logDebug(`MIDI Note On: ${noteName} (MIDI ${midiNote}), Raw Velocity: ${velocity}, Processed: ${processedVelocity.toFixed(3)}, Channel: ${channel}`);

        // Forward to main application with enhanced data
        if (this.onNotePressed) {
          this.onNotePressed({
            note: noteName,
            midiNote: midiNote,
            velocity: processedVelocity,
            rawVelocity: velocity,
            channel: channel,
            source: 'midi',
            timestamp: timestamp,
            deviceName: this.connectedDevice ? this.connectedDevice.name : 'Unknown'
          });
        }
      }

      /**
       * Handle MIDI note off messages with enhanced velocity processing
       * @param {number} midiNote - MIDI note number (0-127)
       * @param {number} velocity - Release velocity (0-127)
       * @param {number} channel - MIDI channel (0-15)
       * @param {number} timestamp - Message timestamp
       */
      handleNoteOff(midiNote, velocity, channel, timestamp) {
        // Skip processing if channel filtering is active and channel doesn't match
        if (!this.isChannelAllowed(channel)) {
          this.logDebug(`Filtered MIDI Note Off: Channel ${channel} not allowed`);
          return;
        }

        const noteName = this.convertMIDINoteToName(midiNote);
        if (noteName === 'INVALID') {
          return; // Skip invalid notes
        }

        // Process release velocity (less common but some keyboards support it)
        const processedVelocity = this.processVelocity(velocity);

        this.logDebug(`MIDI Note Off: ${noteName} (MIDI ${midiNote}), Raw Velocity: ${velocity}, Processed: ${processedVelocity.toFixed(3)}, Channel: ${channel}`);

        // Forward to main application with enhanced data
        if (this.onNoteReleased) {
          this.onNoteReleased({
            note: noteName,
            midiNote: midiNote,
            velocity: processedVelocity,
            rawVelocity: velocity,
            channel: channel,
            source: 'midi',
            timestamp: timestamp,
            deviceName: this.connectedDevice ? this.connectedDevice.name : 'Unknown'
          });
        }
      }

      /**
       * Process and normalize MIDI velocity with sensitivity curve
       * @param {number} rawVelocity - Raw MIDI velocity (0-127)
       * @returns {number} Processed velocity (0-1)
       */
      processVelocity(rawVelocity) {
        // Validate velocity range
        if (rawVelocity < 0 || rawVelocity > 127) {
          this.logError(`Invalid velocity value: ${rawVelocity}`);
          return 0.5; // Default to medium velocity
        }

        // Basic normalization (0-127 to 0-1)
        let normalizedVelocity = rawVelocity / 127;

        // Apply velocity sensitivity curve (configurable)
        const sensitivity = this.velocitySensitivity || 1.0;

        if (sensitivity !== 1.0) {
          // Apply exponential curve for velocity sensitivity
          normalizedVelocity = Math.pow(normalizedVelocity, 1 / sensitivity);
        }

        // Ensure minimum velocity for very soft touches
        const minVelocity = 0.1;
        if (normalizedVelocity > 0 && normalizedVelocity < minVelocity) {
          normalizedVelocity = minVelocity;
        }

        // Clamp to valid range
        return Math.max(0, Math.min(1, normalizedVelocity));
      }

      /**
       * Check if MIDI channel is allowed based on filtering settings
       * @param {number} channel - MIDI channel (0-15)
       * @returns {boolean} True if channel is allowed
       */
      isChannelAllowed(channel) {
        // If no channel filter is set, allow all channels
        if (!this.channelFilter || this.channelFilter.length === 0) {
          return true;
        }

        // Check if channel is in allowed list
        return this.channelFilter.includes(channel);
      }

      /**
       * Set MIDI channel filter for multi-channel support
       * @param {number[]|null} channels - Array of allowed channels (0-15) or null for all
       */
      setChannelFilter(channels) {
        if (channels === null || channels === undefined) {
          this.channelFilter = null;
          this.logDebug('MIDI channel filter disabled - accepting all channels');
        } else if (Array.isArray(channels)) {
          // Validate channel numbers
          const validChannels = channels.filter(ch =>
            typeof ch === 'number' && ch >= 0 && ch <= 15
          );

          this.channelFilter = validChannels;
          this.logDebug(`MIDI channel filter set to: [${validChannels.join(', ')}]`);
        } else {
          this.logError('Invalid channel filter: must be array of numbers or null');
        }
      }

      /**
       * Set velocity sensitivity curve
       * @param {number} sensitivity - Sensitivity value (0.1 to 3.0, default 1.0)
       */
      setVelocitySensitivity(sensitivity) {
        if (typeof sensitivity !== 'number' || sensitivity < 0.1 || sensitivity > 3.0) {
          this.logError('Invalid velocity sensitivity: must be between 0.1 and 3.0');
          return;
        }

        this.velocitySensitivity = sensitivity;
        this.logDebug(`Velocity sensitivity set to: ${sensitivity}`);
      }

      /**
       * Handle MIDI control change messages with enhanced processing
       * @param {number} controller - Controller number
       * @param {number} value - Controller value
       * @param {number} channel - MIDI channel
       * @param {number} timestamp - Message timestamp
       */
      handleControlChange(controller, value, channel, timestamp) {
        // Skip processing if channel filtering is active and channel doesn't match
        if (!this.isChannelAllowed(channel)) {
          this.logDebug(`Filtered MIDI CC: Channel ${channel} not allowed`);
          return;
        }

        this.logDebug(`MIDI Control Change: Controller=${controller}, Value=${value}, Channel=${channel}`);

        // Handle common controllers with enhanced processing
        switch (controller) {
          case 64: // Sustain pedal
            const sustainState = value > 63 ? 'On' : 'Off';
            this.logDebug(`Sustain pedal: ${sustainState} (value: ${value})`);
            this.handleSustainPedal(value > 63, value, channel, timestamp);
            break;
          case 11: // Expression pedal
            this.logDebug(`Expression: ${value}`);
            this.handleExpression(value, channel, timestamp);
            break;
          case 1: // Modulation wheel
            this.logDebug(`Modulation: ${value}`);
            break;
          case 7: // Volume
            this.logDebug(`Volume: ${value}`);
            break;
          case 10: // Pan
            this.logDebug(`Pan: ${value}`);
            break;
          default:
            this.logDebug(`Unhandled controller: ${controller} (value: ${value})`);
            break;
        }

        // Forward control change to application if callback is set
        if (this.onControlChange) {
          this.onControlChange({
            controller: controller,
            value: value,
            normalizedValue: value / 127,
            channel: channel,
            timestamp: timestamp,
            source: 'midi'
          });
        }
      }

      /**
       * Handle MIDI program change messages
       * @param {number} program - Program number (0-127)
       * @param {number} channel - MIDI channel
       * @param {number} timestamp - Message timestamp
       */
      handleProgramChange(program, channel, timestamp) {
        if (!this.isChannelAllowed(channel)) {
          this.logDebug(`Filtered MIDI Program Change: Channel ${channel} not allowed`);
          return;
        }

        this.logDebug(`MIDI Program Change: Program=${program}, Channel=${channel}`);

        if (this.onProgramChange) {
          this.onProgramChange({
            program: program,
            channel: channel,
            timestamp: timestamp,
            source: 'midi'
          });
        }
      }

      /**
       * Handle MIDI pitch bend messages
       * @param {number} lsb - Pitch bend LSB
       * @param {number} msb - Pitch bend MSB
       * @param {number} channel - MIDI channel
       * @param {number} timestamp - Message timestamp
       */
      handlePitchBend(lsb, msb, channel, timestamp) {
        if (!this.isChannelAllowed(channel)) {
          this.logDebug(`Filtered MIDI Pitch Bend: Channel ${channel} not allowed`);
          return;
        }

        // Calculate 14-bit pitch bend value
        const pitchBendValue = (msb << 7) | lsb;
        const normalizedValue = (pitchBendValue - 8192) / 8192; // -1 to +1 range

        this.logDebug(`MIDI Pitch Bend: Value=${pitchBendValue}, Normalized=${normalizedValue.toFixed(3)}, Channel=${channel}`);

        if (this.onPitchBend) {
          this.onPitchBend({
            value: pitchBendValue,
            normalizedValue: normalizedValue,
            channel: channel,
            timestamp: timestamp,
            source: 'midi'
          });
        }
      }

      /**
       * Handle sustain pedal events
       * @param {boolean} isPressed - Whether sustain pedal is pressed
       * @param {number} value - Raw controller value
       * @param {number} channel - MIDI channel
       * @param {number} timestamp - Message timestamp
       */
      handleSustainPedal(isPressed, value, channel, timestamp) {
        if (this.onSustainPedal) {
          this.onSustainPedal({
            isPressed: isPressed,
            value: value,
            channel: channel,
            timestamp: timestamp,
            source: 'midi'
          });
        }
      }

      /**
       * Handle expression pedal events
       * @param {number} value - Expression value (0-127)
       * @param {number} channel - MIDI channel
       * @param {number} timestamp - Message timestamp
       */
      handleExpression(value, channel, timestamp) {
        if (this.onExpression) {
          this.onExpression({
            value: value,
            normalizedValue: value / 127,
            channel: channel,
            timestamp: timestamp,
            source: 'midi'
          });
        }
      }

      /**
       * Apply velocity sensitivity curve to normalize MIDI velocity
       * @param {number} normalizedVelocity - Velocity value between 0 and 1
       * @returns {number} Processed velocity with applied sensitivity curve
       */
      applyVelocitySensitivity(normalizedVelocity) {
        // Validate input range
        if (typeof normalizedVelocity !== 'number' || normalizedVelocity < 0 || normalizedVelocity > 1) {
          this.logError(`Invalid velocity value: ${normalizedVelocity} (must be 0-1)`);
          return Math.max(0, Math.min(1, normalizedVelocity || 0.5));
        }

        // Apply velocity curve for more natural feel
        // Using a slight exponential curve to make soft touches more responsive
        // while preserving strong velocity for loud playing
        const sensitivity = this.midiPreferences?.velocitySensitivity || 1.0;
        const curve = Math.pow(normalizedVelocity, 0.8) * sensitivity;

        // Ensure minimum velocity for audible notes
        const minVelocity = 0.1;
        const processedVelocity = Math.max(minVelocity, Math.min(1.0, curve));

        // Log velocity processing for debugging (only in debug mode)
        if (this.debugMode) {
          this.logDebug(`Velocity Processing: ${normalizedVelocity.toFixed(3)} → ${processedVelocity.toFixed(3)} (sensitivity: ${sensitivity})`);
        }

        return processedVelocity;
      }

      /**
       * Convert MIDI note number to standard note name with enhanced validation
       * @param {number} midiNote - MIDI note number (0-127)
       * @returns {string} Note name with octave (e.g., "C4", "D#5")
       */
      convertMIDINoteToName(midiNote) {
        // Validate MIDI note range
        if (typeof midiNote !== 'number' || midiNote < 0 || midiNote > 127) {
          this.logError(`Invalid MIDI note number: ${midiNote} (must be 0-127)`);
          return 'INVALID';
        }

        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const octave = Math.floor(midiNote / 12) - 1;
        const noteIndex = midiNote % 12;

        const noteName = `${noteNames[noteIndex]}${octave}`;

        // Log conversion for debugging (only in debug mode)
        if (this.debugMode) {
          this.logDebug(`MIDI Note Conversion: ${midiNote} → ${noteName}`);
        }

        return noteName;
      }

      /**
       * Convert note name to MIDI note number (reverse conversion)
       * @param {string} noteName - Note name with octave (e.g., "C4", "D#5")
       * @returns {number} MIDI note number (0-127) or -1 if invalid
       */
      convertNoteNameToMIDI(noteName) {
        if (typeof noteName !== 'string' || noteName.length < 2) {
          this.logError(`Invalid note name: ${noteName}`);
          return -1;
        }

        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        // Parse note name and octave
        const match = noteName.match(/^([A-G]#?)(-?\d+)$/);
        if (!match) {
          this.logError(`Invalid note name format: ${noteName}`);
          return -1;
        }

        const [, note, octaveStr] = match;
        const octave = parseInt(octaveStr, 10);

        const noteIndex = noteNames.indexOf(note);
        if (noteIndex === -1) {
          this.logError(`Invalid note name: ${note}`);
          return -1;
        }

        const midiNote = (octave + 1) * 12 + noteIndex;

        if (midiNote < 0 || midiNote > 127) {
          this.logError(`Note ${noteName} is outside MIDI range (0-127): ${midiNote}`);
          return -1;
        }

        return midiNote;
      }

      /**
       * Get list of available MIDI devices
       * @returns {Map} Map of device IDs to device info objects
       */
      getAvailableDevices() {
        return new Map(this.availableDevices);
      }

      /**
       * Get current connection status
       * @returns {Object} Connection status information
       */
      getConnectionStatus() {
        const baseStatus = {
          isInitialized: this.isInitialized,
          isConnected: this.isConnected,
          connectedDevice: this.connectedDevice ? {
            id: this.connectedDevice.id,
            name: this.connectedDevice.name,
            manufacturer: this.connectedDevice.manufacturer,
            state: this.connectedDevice.state
          } : null,
          availableDeviceCount: this.availableDevices.size
        };

        // Add connection management status
        if (this.connectionManager) {
          const connectionStatus = this.connectionManager.getConnectionStatus();
          return {
            ...baseStatus,
            connectionState: connectionStatus.state,
            reconnectionAttempts: connectionStatus.reconnectionAttempts,
            maxReconnectionAttempts: connectionStatus.maxReconnectionAttempts,
            fallbackActive: connectionStatus.fallbackActive,
            autoReconnectEnabled: this.autoReconnectEnabled,
            lastSuccessfulConnection: connectionStatus.lastSuccessfulConnection
          };
        }

        return baseStatus;
      }

      /**
       * Get MIDI preferences and settings
       */
      getPreferences() {
        return {
          ...this.preferences.preferences,
          connectionStatus: this.getConnectionStatus(),
          retryStatus: this.retryManager.getRetryStatus()
        };
      }

      /**
       * Update MIDI preferences
       */
      updatePreferences(newPreferences) {
        if (newPreferences.autoConnect !== undefined) {
          this.preferences.setAutoConnect(newPreferences.autoConnect);
        }

        if (newPreferences.autoReconnect !== undefined) {
          this.preferences.setAutoReconnect(newPreferences.autoReconnect);
          this.autoReconnectEnabled = newPreferences.autoReconnect;
        }

        if (newPreferences.maxReconnectionAttempts !== undefined) {
          this.preferences.setMaxReconnectionAttempts(newPreferences.maxReconnectionAttempts);
          this.maxReconnectionAttempts = newPreferences.maxReconnectionAttempts;
        }

        if (newPreferences.velocitySensitivity !== undefined) {
          this.preferences.setVelocitySensitivity(newPreferences.velocitySensitivity);
          this.velocitySensitivity = newPreferences.velocitySensitivity;
        }

        console.log('MIDI preferences updated', this.preferences.preferences);
      }

      /**
       * Manually trigger reconnection attempt
       */
      async manualReconnect() {
        if (this.lastConnectedDeviceId && this.availableDevices.has(this.lastConnectedDeviceId)) {
          console.log('Manual reconnection attempt initiated');
          return await this.connectionManager.attemptReconnection(this.lastConnectedDeviceId);
        } else {
          console.warn('No previous device to reconnect to');
          return false;
        }
      }

      /**
       * Reset connection attempts and retry fallback mode
       */
      resetConnectionState() {
        this.reconnectionAttempts = 0;
        this.retryManager.cancelAllRetries();
        this.connectionManager.deactivateFallbackMode();
        console.log('MIDI connection state reset');
      }

      /**
       * Get connection history and statistics
       */
      getConnectionHistory() {
        return {
          preferences: this.preferences.getConnectionHistory(),
          manager: this.connectionManager.connectionHistory,
          statistics: this.statistics
        };
      }

      /**
       * Export MIDI preferences for backup
       */
      exportPreferences() {
        return this.preferences.exportPreferences();
      }

      /**
       * Import MIDI preferences from backup
       */
      importPreferences(preferencesJson) {
        const success = this.preferences.importPreferences(preferencesJson);
        if (success) {
          // Apply imported preferences
          this.autoReconnectEnabled = this.preferences.preferences.autoReconnect;
          this.maxReconnectionAttempts = this.preferences.preferences.maxReconnectionAttempts;
          this.velocitySensitivity = this.preferences.preferences.velocitySensitivity;
        }
        return success;
      }

      /**
       * Handle errors and notify listeners
       * @param {Error} error - Error object
       */
      handleError(error) {
        console.error('MIDI Error:', error);

        // Update status instead of throwing error
        let statusMessage = 'MIDI connection error';
        if (error.message.includes('not supported')) {
          statusMessage = 'MIDI not supported in this browser';
        } else if (error.message.includes('permission')) {
          statusMessage = 'MIDI access denied';
        } else if (error.message.includes('not found')) {
          statusMessage = 'MIDI device not found';
        } else if (error.message.includes('not connected')) {
          statusMessage = 'MIDI device not connected';
        } else if (error.message.includes('not initialized')) {
          statusMessage = 'MIDI system not initialized';
        }

        this.updateMIDIStatus('error', statusMessage);

        if (this.onError) {
          this.onError({
            type: 'midi_error',
            error: error,
            message: error.message,
            timestamp: Date.now()
          });
        }
      }

      /**
       * Update MIDI status in UI instead of throwing errors
       * @param {string} status - Status type ('error', 'disconnected', 'connecting')
       * @param {string} message - Status message to display
       */
      updateMIDIStatus(status, message) {
        console.log(`MIDI Status Update: ${status} - ${message}`);

        // Notify UI about status change through device state change callback
        if (this.onDeviceStateChange) {
          this.onDeviceStateChange({
            type: 'status_update',
            status: status,
            message: message,
            timestamp: Date.now()
          });
        }
      }

      /**
       * Enable or disable debug mode for detailed logging
       * @param {boolean} enabled - Whether to enable debug mode
       */
      setDebugMode(enabled) {
        this.debugMode = !!enabled;
        this.logDebug(`Debug mode ${enabled ? 'enabled' : 'disabled'}`);
      }

      /**
       * Get MIDI message log for debugging
       * @param {number} count - Number of recent messages to return (default: all)
       * @returns {Array} Array of MIDI message log entries
       */
      getMIDIMessageLog(count = null) {
        if (count && count > 0) {
          return this.midiMessageLog.slice(-count);
        }
        return [...this.midiMessageLog];
      }

      /**
       * Clear MIDI message log
       */
      clearMIDIMessageLog() {
        this.midiMessageLog = [];
        this.logDebug('MIDI message log cleared');
      }

      /**
       * Get MIDI processing statistics
       * @returns {Object} Statistics object
       */
      getStatistics() {
        return {
          ...this.statistics,
          uptime: this.isInitialized ? Date.now() - (this.initTime || Date.now()) : 0,
          messagesPerSecond: this.calculateMessagesPerSecond()
        };
      }

      /**
       * Reset MIDI processing statistics
       */
      resetStatistics() {
        this.statistics = {
          messagesReceived: 0,
          notesPressed: 0,
          notesReleased: 0,
          controlChanges: 0,
          errors: 0,
          lastActivity: null
        };
        this.initTime = Date.now();
        this.logDebug('MIDI statistics reset');
      }

      /**
       * Calculate messages per second based on recent activity
       * @returns {number} Messages per second
       */
      calculateMessagesPerSecond() {
        if (this.midiMessageLog.length < 2) {
          return 0;
        }

        const recentMessages = this.midiMessageLog.slice(-10);
        if (recentMessages.length < 2) {
          return 0;
        }

        const timeSpan = new Date(recentMessages[recentMessages.length - 1].timestamp).getTime() -
          new Date(recentMessages[0].timestamp).getTime();

        if (timeSpan === 0) {
          return 0;
        }

        return (recentMessages.length / timeSpan) * 1000; // Convert to per second
      }

      /**
       * Log debug messages (only when debug mode is enabled)
       * @param {string} message - Debug message
       */
      logDebug(message) {
        if (this.debugMode) {
          console.log(`[MIDI Debug] ${message}`);
        }
      }

      /**
       * Log error messages
       * @param {string} message - Error message
       */
      logError(message) {
        console.error(`[MIDI Error] ${message}`);
        this.statistics.errors++;
      }

      /**
       * Log info messages
       * @param {string} message - Info message
       */
      logInfo(message) {
        console.log(`[MIDI Info] ${message}`);
      }

      /**
       * Update statistics for message processing
       * @param {string} messageType - Type of message processed
       */
      updateStatistics(messageType) {
        this.statistics.messagesReceived++;
        this.statistics.lastActivity = Date.now();

        switch (messageType) {
          case 'note_on':
            this.statistics.notesPressed++;
            break;
          case 'note_off':
            this.statistics.notesReleased++;
            break;
          case 'control_change':
            this.statistics.controlChanges++;
            break;
        }
      }

      /**
       * Dispose of MIDI resources
       */
      dispose() {
        this.logInfo('Disposing MIDI controller...');

        // Disconnect from current device
        this.disconnectDevice();

        // Clear device list
        this.availableDevices.clear();

        // Remove MIDI access handlers
        if (this.midiAccess) {
          this.midiAccess.onstatechange = null;
          this.midiAccess = null;
        }

        // Clear callbacks
        this.onNotePressed = null;
        this.onNoteReleased = null;
        this.onDeviceStateChange = null;
        this.onError = null;

        // Clear logs and statistics
        this.midiMessageLog = [];
        this.resetStatistics();

        this.isInitialized = false;
        this.isConnected = false;

        this.logInfo('MIDI controller disposed');
      }
    }

    // Note positioning system for treble clef staff
    class NotePositioning {
      constructor() {
        // Staff configuration
        this.staffTop = 59; // Top of staff lines container
        this.staffLineSpacing = 20; // Distance between staff lines
        this.staffHeight = 80; // Total height of staff lines area
        this.noteHeight = 22;
        this.staffLineHeight = 2;
        let halfHeight = (this.noteHeight - this.staffLineHeight) / 2;

        // Note pitch to position mapping
        this.notePositions = {
          "A3": this.staffTop + 6 * this.staffLineSpacing - halfHeight,
          "B3": this.staffTop + 5 * this.staffLineSpacing,
          "C4": this.staffTop + 5 * this.staffLineSpacing - halfHeight,
          "D4": this.staffTop + 4 * this.staffLineSpacing,
          "E4": this.staffTop + 4 * this.staffLineSpacing - halfHeight,
          "F4": this.staffTop + 3 * this.staffLineSpacing,
          "G4": this.staffTop + 3 * this.staffLineSpacing - halfHeight,
          "A4": this.staffTop + 2 * this.staffLineSpacing,
          "B4": this.staffTop + 2 * this.staffLineSpacing - halfHeight,
          "C5": this.staffTop + 1 * this.staffLineSpacing,
          "D5": this.staffTop + 1 * this.staffLineSpacing - halfHeight,
          "E5": this.staffTop + 0 * this.staffLineSpacing,
          "F5": this.staffTop + 0 * this.staffLineSpacing - halfHeight, // F5 - first line
          "G5": this.staffTop + -1 * this.staffLineSpacing,
          "A5": this.staffTop + -1 * this.staffLineSpacing - halfHeight,
          "B5": this.staffTop + -2 * this.staffLineSpacing,
        };
      }

      /**
       * Get the vertical position for a note on the staff
       * @param {string} pitch - Note pitch (e.g., "D", "F", "C", "G", "A", "C5")
       * @returns {number} Y-coordinate position from top of staff container
       */
      getVerticalPosition(pitch) {
        if (pitch == "rest") {
          // TODO: calculate 'rest' note position by its duration
          return 99; // Default to middle line
        }
        return this.notePositions[pitch];
      }

      /**
       * Get note width based on duration
       * @param {string} duration - Note duration type
       * @returns {number} Width in pixels for the note rectangle
       */
      getNoteWidth(duration) {
        const widthMap = {
          "eighth": 38,
          "quarter": 76,
          "dotted_quarter": 114,
          "half": 152,
          "whole": 304,
        };
        return widthMap[duration] || widthMap["quarter"];
      }

      getNoteColor(pitch) {
        const colorMap = {
          "C": "#CE82FF",
          "D": "#FF9602",
          "E": "#57CD03",
          "F": "#CC348E",
          "G": "#7090FF",
          "A": "#FF87D0",
          "B": "#00CE9C",
        };
        return colorMap[pitch[0]] || null;
      }

      /**
       * Calculate positions for all notes in the song
       * @param {Array} measures - Array of measure objects with notes
       * @returns {Array} Array of positioned note objects
       */
      calculateAllNotePositions(measures) {
        const positionedNotes = [];
        let noteIndex = 0;
        let cumulativeX = 0;
        const noteSpacing = 12; // pixels between notes
        const measureBarMargin = 6; // pixels from measure bar to notes
        this.measurePositions = []; // Track measure start positions

        measures.forEach((measure, measureIndex) => {
          // Record the start position of this measure
          this.measurePositions.push(cumulativeX);

          // Add margin after measure bar for first note in measure
          if (measureIndex > 0) {
            cumulativeX += measureBarMargin;
          }

          measure.notes.forEach((note, noteInMeasureIndex) => {
            const noteWidth = this.getNoteWidth(note.duration);
            const noteColor = this.getNoteColor(note.pitch);

            const positionData = {
              ...note,
              measureIndex: measureIndex,
              noteIndex: noteIndex,
              x: cumulativeX,
              y: this.getVerticalPosition(note.pitch),
              width: noteWidth,
              color: noteColor,
            };

            positionedNotes.push(positionData);

            // Move to next note position
            cumulativeX += noteWidth + noteSpacing;
            noteIndex++;
          });

          // Remove the last note spacing and add margin before next measure bar
          cumulativeX -= noteSpacing;
          cumulativeX += measureBarMargin;
        });

        return positionedNotes;
      }

      /**
       * Get measure bar positions
       * @returns {Array} Array of x-positions for measure bars
       */
      getMeasureBarPositions() {
        return this.measurePositions || [];
      }
    }

    // ToneJS Audio Engine class for professional piano sound synthesis
    class ToneJSAudioEngine {
      constructor() {
        this.synth = null;
        this.reverb = null;
        this.compressor = null;
        this.masterVolume = null;
        this.sustainedNotes = new Map(); // Track held notes for polyphonic support
        this.naturalDecayTimers = new Map(); // Track natural decay timers for realistic piano behavior
        this.isInitialized = false;
        this.isAudioEnabled = true;

        // Enhanced audio configuration for realistic piano sound with natural decay
        this.config = {
          masterVolumeDb: 0,       // Master volume in dB
          noteLength: 1.0,          // Default note duration in seconds
          polyphony: 32,            // Maximum simultaneous notes
          envelope: {
            attack: 0.02,         // Realistic piano attack time
            decay: 0.8,           // Extended decay for natural piano sound
            sustain: 0.2,         // Lower sustain level for realistic decay
            release: 2.0          // Longer release for natural piano tail
          },
          oscillator: {
            type: "triangle",     // Base oscillator type
            harmonicity: 2,       // Harmonic ratio for realistic piano timbre
            modulationType: "sine", // Modulation type for complex waveforms
            modulationIndex: 0.5  // Modulation depth
          },
          effects: {
            reverb: {
              decay: 3.0,       // Extended reverb decay for piano realism
              wet: 0.25         // Balanced reverb mix
            },
            compressor: {
              threshold: -24,   // Compression threshold in dB
              ratio: 6,         // Gentler compression for piano dynamics
              attack: 0.005,    // Fast compressor attack
              release: 0.15     // Compressor release time
            }
          },
          // Realistic piano decay characteristics based on acoustic research
          pianoDecay: {
            // Natural decay durations by frequency range (in seconds)
            bassNotes: {          // C2-C3 (low frequencies)
              sustainTime: 8.0, // Bass notes sustain longest
              decayRate: 0.15   // Slower decay rate
            },
            midNotes: {           // C3-C5 (middle frequencies)
              sustainTime: 5.0, // Medium sustain time
              decayRate: 0.25   // Medium decay rate
            },
            trebleNotes: {        // C5-C7 (high frequencies)
              sustainTime: 2.5, // Treble notes decay fastest
              decayRate: 0.4    // Faster decay rate
            },
            // Volume decay curve parameters
            decayCurve: {
              initialVolume: 1.0,     // Starting volume
              sustainThreshold: 0.1,  // Volume level considered "silent"
              decayFunction: 'exponential' // Type of decay curve
            }
          }
        };

        console.log('ToneJSAudioEngine initialized');
      }

      /**
       * Initialize Tone.js audio context and synthesizers
       * @returns {Promise<boolean>} True if initialization successful
       */
      async initializeAudio() {
        try {
          // Check if Tone.js is available
          if (typeof Tone === 'undefined') {
            throw new Error('Tone.js library not loaded');
          }

          // Start Tone.js audio context (required for user interaction)
          await Tone.start();
          console.log('Tone.js audio context started');

          // Create polyphonic piano synthesizer
          this.synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: {
              type: this.config.oscillator.type,
              harmonicity: this.config.oscillator.harmonicity,
              modulationType: this.config.oscillator.modulationType,
              modulationIndex: this.config.oscillator.modulationIndex
            },
            envelope: {
              attack: this.config.envelope.attack,
              decay: this.config.envelope.decay,
              sustain: this.config.envelope.sustain,
              release: this.config.envelope.release
            }
          }).set({
            volume: -12 // Set synth volume to allow headroom for effects
          });

          // Create realistic piano effects
          this.reverb = new Tone.Reverb({
            decay: this.config.effects.reverb.decay,
            wet: this.config.effects.reverb.wet
          });

          this.compressor = new Tone.Compressor({
            threshold: this.config.effects.compressor.threshold,
            ratio: this.config.effects.compressor.ratio,
            attack: this.config.effects.compressor.attack,
            release: this.config.effects.compressor.release
          });

          this.masterVolume = new Tone.Volume(this.config.masterVolumeDb);

          // Connect audio chain: synth → compressor → reverb → masterVolume → destination
          this.synth.chain(this.compressor, this.reverb, this.masterVolume, Tone.Destination);

          // Wait for reverb to be ready (it needs time to generate impulse response)
          await this.reverb.ready;

          this.isInitialized = true;
          console.log('ToneJS audio engine initialized successfully');
          console.log('Audio context state:', Tone.context.state);
          console.log('Sample rate:', Tone.context.sampleRate);
          console.log('Polyphony:', this.config.polyphony);

          return true;
        } catch (error) {
          console.error('Failed to initialize ToneJS audio engine:', error);
          this.handleAudioInitializationError(error);
          return false;
        }
      }

      /**
       * Handle audio initialization errors and implement fallback
       * @param {Error} error - The initialization error
       */
      handleAudioInitializationError(error) {
        console.warn('ToneJS audio engine not available, implementing fallback strategy');

        if (error.message.includes('Tone.js library not loaded')) {
          console.error('Tone.js library is required but not loaded');
          this.isAudioEnabled = false;
        } else if (error.name === 'NotAllowedError') {
          console.warn('Audio blocked by browser - user interaction required');
          this.isAudioEnabled = true; // Keep enabled, will retry on user interaction
        } else {
          console.warn('Unknown audio error - running in silent mode');
          this.isAudioEnabled = false;
        }

        this.isInitialized = false;
      }

      /**
       * Resume audio context if suspended (required for user interaction)
       * @returns {Promise<boolean>} True if audio context is ready
       */
      async resumeAudioContext() {
        try {
          // Initialize if not already done
          if (!this.isInitialized) {
            const initialized = await this.initializeAudio();
            if (!initialized) {
              return false;
            }
          }

          // Resume Tone.js context if suspended
          if (Tone.context.state === 'suspended') {
            await Tone.start();
            console.log('Tone.js audio context resumed successfully');
          }

          // Check if context is now running
          const isReady = Tone.context.state === 'running' && this.isInitialized;
          return isReady;
        } catch (error) {
          console.error('Error in resumeAudioContext:', error);
          this.handleAudioInitializationError(error);
          return false;
        }
      }

      /**
       * Calculate realistic piano decay characteristics based on note frequency
       * @param {string} note - Note name (e.g., 'C4', 'D4')
       * @returns {Object} Decay parameters for the note
       */
      calculatePianoDecayParams(note) {
        // Extract octave number from note name (e.g., 'C4' -> 4)
        const octaveMatch = note.match(/(\d+)$/);
        const octave = octaveMatch ? parseInt(octaveMatch[1]) : 4;

        // Calculate frequency range category
        let decayParams;
        if (octave <= 3) {
          // Bass notes (low frequencies) - sustain longest
          decayParams = this.config.pianoDecay.bassNotes;
        } else if (octave <= 5) {
          // Mid notes (middle frequencies) - medium sustain
          decayParams = this.config.pianoDecay.midNotes;
        } else {
          // Treble notes (high frequencies) - decay fastest
          decayParams = this.config.pianoDecay.trebleNotes;
        }

        return {
          sustainTime: decayParams.sustainTime,
          decayRate: decayParams.decayRate,
          octave: octave,
          category: octave <= 3 ? 'bass' : (octave <= 5 ? 'mid' : 'treble')
        };
      }

      /**
       * Start natural piano decay for a sustained note
       * @param {string} note - Note name
       * @param {number} velocity - Initial velocity
       * @param {Object} decayParams - Decay parameters for the note
       */
      startNaturalDecay(note, velocity, decayParams) {
        // Clear any existing decay timer for this note
        if (this.naturalDecayTimers.has(note)) {
          clearInterval(this.naturalDecayTimers.get(note));
        }

        const startTime = Date.now();
        const initialVolume = velocity;
        const {sustainTime, decayRate} = decayParams;

        console.log(`🎹 [PIANO-DECAY] Starting natural decay for ${note} (${decayParams.category}): ${sustainTime}s sustain, ${decayRate} decay rate`);

        // Create decay timer that gradually reduces volume
        const decayInterval = setInterval(() => {
          const elapsedTime = (Date.now() - startTime) / 1000; // Convert to seconds

          // Calculate current volume using exponential decay
          const decayFactor = Math.exp(-decayRate * elapsedTime);
          const currentVolume = initialVolume * decayFactor;

          // Check if note should be considered "silent"
          if (elapsedTime >= sustainTime || currentVolume < this.config.pianoDecay.decayCurve.sustainThreshold) {
            // Natural decay complete - release the note
            console.log(`🎹 [PIANO-DECAY] Natural decay complete for ${note} after ${elapsedTime.toFixed(2)}s`);
            this.releaseNoteNaturally(note);
            return;
          }

          // Update note volume to simulate decay (placeholder for future enhancement)
          // ToneJS doesn't allow easy real-time volume changes on individual notes
          // In a more advanced implementation, we could use individual Tone.js Volume nodes per note
        }, 100); // Update every 100ms for smooth decay

        this.naturalDecayTimers.set(note, decayInterval);
      }

      /**
       * Release a note naturally due to piano decay
       * @param {string} note - Note name to release
       */
      async releaseNoteNaturally(note) {
        try {
          // Clear the decay timer
          if (this.naturalDecayTimers.has(note)) {
            clearInterval(this.naturalDecayTimers.get(note));
            this.naturalDecayTimers.delete(note);
          }

          // Release the note with a gentle fade
          if (this.sustainedNotes.has(note)) {
            this.synth.triggerRelease(note);
            this.sustainedNotes.delete(note);
            console.log(`🎹 [PIANO-DECAY] Released note naturally: ${note}`);
          }
        } catch (error) {
          console.error(`🎹 [PIANO-DECAY] Error releasing note naturally: ${note}`, error);
        }
      }

      /**
       * Enhanced play note method with realistic piano decay
       * @param {string} note - Note name in Tone.js format (e.g., 'C4', 'D4')
       * @param {number} velocity - Note velocity (0.0 to 1.0)
       * @param {string|number} duration - Note duration (Tone.js time format or seconds)
       * @returns {Promise<void>}
       */
      async playNote(note, velocity = 0.8, duration = null) {
        if (!this.isAudioEnabled) {
          console.log(`Audio disabled - would play ${note}`);
          return;
        }

        try {
          console.log(`🎹 [TONEJS] playNote called: ${note}, velocity: ${velocity}, duration: ${duration}`);

          // Ensure audio context is ready
          const audioReady = await this.resumeAudioContext();
          if (!audioReady) {
            console.warn('🎹 [TONEJS] Audio context not ready');
            return;
          }

          if (duration) {
            // Trigger note for specific duration
            this.synth.triggerAttackRelease(note, duration, undefined, velocity);
            console.log(`🎹 [TONEJS] Playing note: ${note} for ${duration} with velocity ${velocity}`);
          } else {
            // Start sustained note with realistic piano decay
            this.synth.triggerAttack(note, undefined, velocity);
            this.sustainedNotes.set(note, Date.now());

            // Calculate and start natural piano decay
            const decayParams = this.calculatePianoDecayParams(note);
            this.startNaturalDecay(note, velocity, decayParams);

            console.log(`🎹 [TONEJS] Starting sustained note with realistic decay: ${note} (${decayParams.category} range, ${decayParams.sustainTime}s sustain)`);
          }
        } catch (error) {
          console.error('Error playing note with ToneJS:', error);
          this.handlePlaybackError(error);
        }
      }

      /**
       * Release a sustained note (manual release before natural decay)
       * @param {string} note - Note name to release
       * @returns {Promise<void>}
       */
      async releaseNote(note) {
        if (!this.isAudioEnabled || !this.isInitialized) {
          return;
        }

        try {
          // Clear any natural decay timer for this note
          if (this.naturalDecayTimers.has(note)) {
            clearInterval(this.naturalDecayTimers.get(note));
            this.naturalDecayTimers.delete(note);
            console.log(`🎹 [PIANO-DECAY] Cleared natural decay timer for manual release: ${note}`);
          }

          if (this.sustainedNotes.has(note)) {
            this.synth.triggerRelease(note);
            this.sustainedNotes.delete(note);
            console.log(`🎹 [TONEJS] Released sustained note manually: ${note}`);
          }
        } catch (error) {
          console.error('Error releasing note with ToneJS:', error);
        }
      }

      /**
       * Play a note by name (compatibility with existing interface)
       * @param {string} noteName - Name of the note to play
       * @param {number} duration - Note duration in seconds (optional)
       * @returns {Promise<void>}
       */
      async playNoteByName(noteName, duration = null) {
        console.log(`🎼 [TONEJS] playNoteByName called: ${noteName}, duration: ${duration}`);

        // Convert duration to Tone.js time format if provided
        const toneJSDuration = duration ? `${duration}s` : null;

        await this.playNote(noteName, 0.8, toneJSDuration);
        console.log(`🎼 [TONEJS] playNoteByName completed for ${noteName}`);
      }

      /**
       * Start sustained note (for key press and hold)
       * @param {string} note - Note name to sustain
       * @param {number} velocity - Note velocity (0.0 to 1.0)
       * @returns {Promise<void>}
       */
      async sustainNote(note, velocity = 0.8) {
        await this.playNote(note, velocity, null);
      }

      /**
       * Handle playback errors with graceful degradation
       * @param {Error} error - The playback error
       */
      handlePlaybackError(error) {
        console.error('ToneJS audio playback error:', error);

        // Implement fallback strategies
        if (error.name === 'NotAllowedError') {
          console.warn('Audio playback blocked - user interaction required');
        } else if (error.name === 'NotSupportedError') {
          console.warn('Audio format not supported - trying fallback');
          this.tryFallbackAudio();
        } else {
          console.warn('Unknown ToneJS audio error - continuing with visual-only feedback');
        }
      }

      /**
       * Implement fallback audio using basic Web Audio API
       */
      tryFallbackAudio() {
        console.log('Attempting Web Audio API fallback from ToneJS');
        // Could implement basic Web Audio API fallback here
        console.log('Fallback: Would use basic Web Audio API or pre-recorded samples');
      }

      /**
       * Set master volume
       * @param {number} volume - Volume level (0.0 to 1.0)
       */
      setMasterVolume(volume) {
        // Convert linear volume to dB scale
        const volumeDb = volume > 0 ? 20 * Math.log10(volume) : -60;
        this.config.masterVolumeDb = Math.max(-60, Math.min(0, volumeDb));

        if (this.masterVolume) {
          this.masterVolume.volume.value = this.config.masterVolumeDb;
        }

        console.log(`Master volume set to: ${volume} (${this.config.masterVolumeDb.toFixed(1)} dB)`);
      }

      /**
       * Enable or disable audio playback
       * @param {boolean} enabled - True to enable, false to disable
       */
      setAudioEnabled(enabled) {
        this.isAudioEnabled = enabled;
        console.log(`ToneJS audio playback ${enabled ? 'enabled' : 'disabled'}`);
      }

      /**
       * Get current audio engine status
       * @returns {Object} Status information
       */
      getStatus() {
        return {
          isInitialized: this.isInitialized,
          isAudioEnabled: this.isAudioEnabled,
          audioContextState: typeof Tone !== 'undefined' ? Tone.context.state : 'Tone.js not loaded',
          masterVolume: this.config.masterVolumeDb,
          sustainedNotes: this.sustainedNotes.size,
          polyphony: this.config.polyphony,
          toneJSLoaded: typeof Tone !== 'undefined',
          synthReady: !!this.synth,
          effectsReady: !!(this.reverb && this.compressor && this.masterVolume)
        };
      }

      /**
       * Clean up audio resources
       */
      dispose() {
        try {
          // Clear all natural decay timers
          this.naturalDecayTimers.forEach((timer, note) => {
            clearInterval(timer);
            console.log(`🎹 [PIANO-DECAY] Cleared decay timer for ${note} during disposal`);
          });
          this.naturalDecayTimers.clear();

          // Release all sustained notes
          this.sustainedNotes.forEach((timestamp, note) => {
            this.releaseNote(note);
          });
          this.sustainedNotes.clear();

          // Dispose of Tone.js objects
          if (this.synth) {
            this.synth.dispose();
            this.synth = null;
          }
          if (this.reverb) {
            this.reverb.dispose();
            this.reverb = null;
          }
          if (this.compressor) {
            this.compressor.dispose();
            this.compressor = null;
          }
          if (this.masterVolume) {
            this.masterVolume.dispose();
            this.masterVolume = null;
          }

          this.isInitialized = false;
          console.log('🎹 [PIANO-DECAY] ToneJS audio engine disposed with decay cleanup');
        } catch (error) {
          console.error('Error disposing ToneJS audio engine:', error);
        }
      }
    }

    // MIDI Performance Optimization Components

    /**
     * MIDI Message Buffer for high-frequency data handling
     * Buffers rapid MIDI messages to prevent processing bottlenecks
     */
    class MIDIMessageBuffer {
      constructor() {
        this.buffer = [];
        this.maxSize = 100;
        this.bufferThreshold = 10; // messages per 10ms
        this.lastFlush = performance.now();
        this.flushInterval = 10; // ms
        this.highFrequencyDetected = false;
      }

      /**
       * Determine if message should be buffered based on frequency
       * @param {Object} message - Enhanced MIDI message
       * @returns {boolean} True if message should be buffered
       */
      shouldBuffer(message) {
        const now = performance.now();
        const timeSinceFlush = now - this.lastFlush;

        // Detect high-frequency input
        if (timeSinceFlush < this.flushInterval) {
          this.highFrequencyDetected = true;
          return this.buffer.length < this.bufferThreshold;
        }

        this.highFrequencyDetected = false;
        return false;
      }

      /**
       * Add message to buffer with overflow protection
       * @param {Object} message - MIDI message to buffer
       */
      addMessage(message) {
        if (this.buffer.length >= this.maxSize) {
          // Remove oldest message to prevent memory issues
          this.buffer.shift();
        }
        this.buffer.push({
          ...message,
          bufferedAt: performance.now()
        });
      }

      /**
       * Flush buffered messages and return them
       * @returns {Array} Array of buffered messages
       */
      flush() {
        const messages = [...this.buffer];
        this.buffer = [];
        this.lastFlush = performance.now();
        return messages;
      }

      /**
       * Get current buffer size
       * @returns {number} Number of buffered messages
       */
      getSize() {
        return this.buffer.length;
      }

      /**
       * Clear all buffered messages
       */
      clear() {
        this.buffer = [];
        this.lastFlush = performance.now();
      }

      /**
       * Check if high-frequency input is detected
       * @returns {boolean} True if high-frequency input detected
       */
      isHighFrequency() {
        return this.highFrequencyDetected;
      }
    }

    /**
     * MIDI Latency Compensation System
     * Compensates for input latency to improve timing accuracy
     */
    class MIDILatencyCompensator {
      constructor() {
        this.latencyHistory = [];
        this.maxHistorySize = 100;
        this.baseLatency = 5; // Base compensation in ms
        this.adaptiveCompensation = true;
        this.targetLatency = 10; // Target latency in ms
        this.compensationFactor = 0.8; // Compensation strength (0-1)
      }

      /**
       * Compensate timestamp for latency
       * @param {number} originalTimestamp - Original message timestamp
       * @returns {number} Compensated timestamp
       */
      compensateLatency(originalTimestamp) {
        const now = performance.now();
        const measuredLatency = now - originalTimestamp;

        // Record latency for adaptive compensation
        this.recordLatency(measuredLatency);

        // Apply compensation
        const compensationOffset = this.getCompensationOffset();
        return originalTimestamp + compensationOffset;
      }

      /**
       * Record latency measurement for adaptive compensation
       * @param {number} latency - Measured latency in ms
       */
      recordLatency(latency) {
        // Filter out unrealistic latency values
        if (latency >= 0 && latency <= 1000) {
          this.latencyHistory.push(latency);

          if (this.latencyHistory.length > this.maxHistorySize) {
            this.latencyHistory.shift();
          }
        }
      }

      /**
       * Calculate compensation offset based on recent latency
       * @returns {number} Compensation offset in ms
       */
      getCompensationOffset() {
        if (!this.adaptiveCompensation || this.latencyHistory.length === 0) {
          return this.baseLatency;
        }

        // Calculate adaptive compensation based on recent latency
        const recentLatencies = this.latencyHistory.slice(-20);
        const avgLatency = recentLatencies.reduce((sum, lat) => sum + lat, 0) / recentLatencies.length;

        // Apply compensation factor and cap maximum compensation
        const compensation = Math.min(avgLatency * this.compensationFactor, 50);
        return Math.max(compensation, this.baseLatency);
      }

      /**
       * Get average latency from recent measurements
       * @returns {number} Average latency in ms
       */
      getAverageLatency() {
        if (this.latencyHistory.length === 0) return 0;

        const recentLatencies = this.latencyHistory.slice(-10);
        return Math.round(recentLatencies.reduce((sum, lat) => sum + lat, 0) / recentLatencies.length);
      }

      /**
       * Apply compensation to message
       * @param {Object} message - MIDI message with compensation data
       * @returns {Object} Message with applied compensation
       */
      applyCompensation(message) {
        return {
          ...message,
          timeStamp: message.compensatedTimestamp || message.timeStamp,
          latencyCompensated: true,
          originalLatency: message.receivedAt - message.timeStamp
        };
      }

      /**
       * Reset latency history
       */
      reset() {
        this.latencyHistory = [];
      }
    }

    /**
     * Enhanced MIDI Error Handler
     * Provides comprehensive error handling and user-friendly messages
     */
    class MIDIErrorHandler {
      constructor() {
        this.errorCount = 0;
        this.errorLog = [];
        this.maxLogSize = 50;
        this.errorTypes = {
          INITIALIZATION: 'initialization',
          MESSAGE_PROCESSING: 'message_processing',
          QUEUE_OVERFLOW: 'queue_overflow',
          DEVICE_CONNECTION: 'device_connection',
          BROWSER_COMPATIBILITY: 'browser_compatibility',
          PERFORMANCE: 'performance'
        };
        this.userNotificationCallback = null;
      }

      /**
       * Handle MIDI initialization errors
       * @param {Error} error - Initialization error
       */
      handleInitializationError(error) {
        this.logError(this.errorTypes.INITIALIZATION, error, {
          userAgent: navigator.userAgent,
          midiSupport: !!navigator.requestMIDIAccess,
          timestamp: Date.now()
        });

        console.error('MIDI Initialization Error:', error);
        this.notifyUser('Unable to initialize MIDI. Please check your browser settings and ensure MIDI devices are connected.');
      }

      /**
       * Handle MIDI message processing errors
       * @param {Error} error - Processing error
       * @param {Object} message - Original MIDI message
       */
      handleMessageError(error, message) {
        this.logError(this.errorTypes.MESSAGE_PROCESSING, error, {
          messageData: message ? Array.from(message.data || []) : null,
          timestamp: message ? message.timeStamp : null,
          processingStage: 'initial'
        });

        console.warn('MIDI Message Error:', error.message);
      }

      /**
       * Handle optimized message processing errors
       * @param {Error} error - Processing error
       * @param {Object} message - Enhanced MIDI message
       */
      handleProcessingError(error, message) {
        this.logError(this.errorTypes.MESSAGE_PROCESSING, error, {
          processingStage: 'optimization',
          messageData: message ? Array.from(message.data || []) : null,
          hasCompensation: message ? !!message.compensatedTimestamp : false
        });

        console.warn('MIDI Processing Error:', error.message);
      }

      /**
       * Handle MIDI message queue overflow
       */
      handleQueueOverflow() {
        this.logError(this.errorTypes.QUEUE_OVERFLOW, new Error('MIDI message queue overflow'), {
          timestamp: performance.now(),
          recommendation: 'Consider reducing MIDI input frequency or increasing processing capacity'
        });

        console.warn('MIDI Queue Overflow: Some messages may be dropped');
        this.notifyUser('MIDI input is too fast. Some messages may be dropped. Consider reducing input frequency.');
      }

      /**
       * Handle device connection errors
       * @param {Error} error - Connection error
       * @param {string} deviceId - Device identifier
       */
      handleConnectionError(error, deviceId) {
        this.logError(this.errorTypes.DEVICE_CONNECTION, error, {
          deviceId: deviceId,
          timestamp: Date.now()
        });

        console.error('MIDI Connection Error:', error);
        this.notifyUser('MIDI device connection issue. Please check your device connection and try again.');
      }

      /**
       * Handle browser compatibility issues
       * @param {Error} error - Compatibility error
       * @param {string} browserInfo - Browser information
       */
      handleCompatibilityError(error, browserInfo) {
        this.logError(this.errorTypes.BROWSER_COMPATIBILITY, error, {
          browserInfo: browserInfo,
          timestamp: Date.now()
        });

        console.warn('MIDI Compatibility Issue:', error);
        this.notifyUser('Your browser may have limited MIDI support. Consider using Chrome or Edge for best results.');
      }

      /**
       * Handle performance-related errors
       * @param {Error} error - Performance error
       * @param {Object} metrics - Performance metrics
       */
      handlePerformanceError(error, metrics) {
        this.logError(this.errorTypes.PERFORMANCE, error, {
          metrics: metrics,
          timestamp: Date.now()
        });

        console.warn('MIDI Performance Issue:', error);
      }

      /**
       * Log error with detailed context
       * @param {string} type - Error type
       * @param {Error} error - Error object
       * @param {Object} context - Additional context
       */
      logError(type, error, context = {}) {
        this.errorCount++;

        const errorEntry = {
          id: this.generateErrorId(),
          type: type,
          message: error.message,
          timestamp: new Date().toISOString(),
          context: context,
          stack: error.stack,
          severity: this.getErrorSeverity(type)
        };

        this.errorLog.push(errorEntry);

        // Maintain log size
        if (this.errorLog.length > this.maxLogSize) {
          this.errorLog.shift();
        }

        // Dispatch error event for external handling
        this.dispatchErrorEvent(errorEntry);
      }

      /**
       * Generate unique error ID
       * @returns {string} Unique error identifier
       */
      generateErrorId() {
        return `midi_error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }

      /**
       * Determine error severity
       * @param {string} type - Error type
       * @returns {string} Severity level
       */
      getErrorSeverity(type) {
        switch (type) {
          case this.errorTypes.INITIALIZATION:
          case this.errorTypes.DEVICE_CONNECTION:
            return 'high';
          case this.errorTypes.QUEUE_OVERFLOW:
          case this.errorTypes.BROWSER_COMPATIBILITY:
            return 'medium';
          case this.errorTypes.MESSAGE_PROCESSING:
          case this.errorTypes.PERFORMANCE:
            return 'low';
          default:
            return 'medium';
        }
      }

      /**
       * Dispatch error event for external handling
       * @param {Object} errorEntry - Error entry object
       */
      dispatchErrorEvent(errorEntry) {
        window.dispatchEvent(new CustomEvent('midiError', {
          detail: errorEntry
        }));
      }

      /**
       * Notify user of error with friendly message
       * @param {string} message - User-friendly error message
       */
      notifyUser(message) {
        if (this.userNotificationCallback) {
          this.userNotificationCallback(message);
        } else {
          console.warn(`MIDI Error: ${message}`);
        }
      }

      /**
       * Set user notification callback
       * @param {Function} callback - Notification callback function
       */
      setUserNotificationCallback(callback) {
        this.userNotificationCallback = callback;
      }

      /**
       * Get total error count
       * @returns {number} Total number of errors
       */
      getErrorCount() {
        return this.errorCount;
      }

      /**
       * Get error log
       * @returns {Array} Array of error entries
       */
      getErrorLog() {
        return [...this.errorLog];
      }

      /**
       * Get errors by type
       * @param {string} type - Error type to filter
       * @returns {Array} Filtered error entries
       */
      getErrorsByType(type) {
        return this.errorLog.filter(error => error.type === type);
      }

      /**
       * Clear all errors
       */
      clearErrors() {
        this.errorCount = 0;
        this.errorLog = [];
      }

      /**
       * Get error statistics
       * @returns {Object} Error statistics
       */
      getErrorStatistics() {
        const stats = {};

        Object.values(this.errorTypes).forEach(type => {
          stats[type] = this.getErrorsByType(type).length;
        });

        return {
          total: this.errorCount,
          byType: stats,
          recentErrors: this.errorLog.slice(-5)
        };
      }
    }

    /**
     * MIDI Browser Compatibility Handler
     * Handles browser-specific MIDI compatibility issues and workarounds
     */
    class MIDIBrowserCompatibility {
      constructor() {
        this.browserInfo = this.detectBrowser();
        this.workarounds = new Map();
        this.setupWorkarounds();
        this.compatibilityIssues = [];
      }

      /**
       * Detect current browser and version
       * @returns {Object} Browser information
       */
      detectBrowser() {
        const userAgent = navigator.userAgent;

        if (userAgent.includes('Chrome') && !userAgent.includes('Edge')) {
          return {
            name: 'Chrome',
            version: this.extractVersion(userAgent, 'Chrome/'),
            engine: 'Blink'
          };
        } else if (userAgent.includes('Firefox')) {
          return {
            name: 'Firefox',
            version: this.extractVersion(userAgent, 'Firefox/'),
            engine: 'Gecko'
          };
        } else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
          return {
            name: 'Safari',
            version: this.extractVersion(userAgent, 'Version/'),
            engine: 'WebKit'
          };
        } else if (userAgent.includes('Edge')) {
          return {
            name: 'Edge',
            version: this.extractVersion(userAgent, 'Edge/'),
            engine: 'Blink'
          };
        } else if (userAgent.includes('Opera')) {
          return {
            name: 'Opera',
            version: this.extractVersion(userAgent, 'Opera/'),
            engine: 'Blink'
          };
        }

        return {name: 'Unknown', version: '0', engine: 'Unknown'};
      }

      /**
       * Extract version number from user agent string
       * @param {string} userAgent - User agent string
       * @param {string} prefix - Version prefix to search for
       * @returns {string} Version number
       */
      extractVersion(userAgent, prefix) {
        const index = userAgent.indexOf(prefix);
        if (index === -1) return '0';

        const versionString = userAgent.substring(index + prefix.length);
        const version = versionString.split(' ')[0].split('.')[0];
        return version || '0';
      }

      /**
       * Setup browser-specific workarounds
       */
      setupWorkarounds() {
        // Chrome-specific workarounds
        this.workarounds.set('Chrome', {
          requiresUserGesture: true,
          supportsHighResolutionTime: true,
          midiAccessDelay: 100,
          maxConcurrentConnections: 16,
          supportsHotPlugging: true,
          timestampAccuracy: 'high'
        });

        // Firefox-specific workarounds
        this.workarounds.set('Firefox', {
          requiresUserGesture: false,
          supportsHighResolutionTime: false,
          midiAccessDelay: 200,
          maxConcurrentConnections: 8,
          supportsHotPlugging: false,
          timestampAccuracy: 'medium',
          limitedMIDISupport: true,
          requiresPolling: true
        });

        // Safari-specific workarounds
        this.workarounds.set('Safari', {
          requiresUserGesture: true,
          supportsHighResolutionTime: false,
          midiAccessDelay: 300,
          maxConcurrentConnections: 4,
          supportsHotPlugging: false,
          timestampAccuracy: 'low',
          limitedMIDISupport: true,
          requiresPolyfill: true,
          webMIDIDisabled: parseInt(this.browserInfo.version) < 14
        });

        // Edge-specific workarounds
        this.workarounds.set('Edge', {
          requiresUserGesture: true,
          supportsHighResolutionTime: true,
          midiAccessDelay: 150,
          maxConcurrentConnections: 12,
          supportsHotPlugging: true,
          timestampAccuracy: 'high'
        });

        // Opera-specific workarounds
        this.workarounds.set('Opera', {
          requiresUserGesture: true,
          supportsHighResolutionTime: true,
          midiAccessDelay: 120,
          maxConcurrentConnections: 10,
          supportsHotPlugging: true,
          timestampAccuracy: 'high'
        });
      }

      /**
       * Apply browser-specific workarounds
       * @returns {Promise<void>}
       */
      async applyWorkarounds() {
        const workaround = this.workarounds.get(this.browserInfo.name);

        if (!workaround) {
          console.warn(`No specific workarounds for browser: ${this.browserInfo.name}`);
          this.compatibilityIssues.push(`Untested browser: ${this.browserInfo.name}`);
          return;
        }

        // Apply browser-specific delays
        if (workaround.midiAccessDelay) {
          await new Promise(resolve => setTimeout(resolve, workaround.midiAccessDelay));
        }

        // Handle user gesture requirements
        if (workaround.requiresUserGesture && !this.hasUserGesture()) {
          console.warn('Browser requires user gesture for MIDI access');
          this.compatibilityIssues.push('User gesture required for MIDI access');
        }

        // Apply performance optimizations based on browser capabilities
        if (!workaround.supportsHighResolutionTime) {
          console.warn('Browser has limited high-resolution time support');
          this.compatibilityIssues.push('Limited timestamp accuracy');
        }

        // Handle limited MIDI support
        if (workaround.limitedMIDISupport) {
          console.warn(`${this.browserInfo.name} has limited MIDI support`);
          this.compatibilityIssues.push('Limited MIDI API support');
        }

        // Handle WebKit-specific issues
        if (this.browserInfo.engine === 'WebKit' && workaround.webMIDIDisabled) {
          throw new Error('Web MIDI API is disabled in this version of Safari');
        }

        console.log(`Applied workarounds for ${this.browserInfo.name} ${this.browserInfo.version}`);
      }

      /**
       * Check if Web MIDI API is supported
       * @returns {boolean} True if MIDI is supported
       */
      isMIDISupported() {
        if (!navigator.requestMIDIAccess) {
          return false;
        }

        const workaround = this.workarounds.get(this.browserInfo.name);
        if (workaround && workaround.webMIDIDisabled) {
          return false;
        }

        return true;
      }

      /**
       * Check if user gesture is available
       * @returns {boolean} True if user gesture detected
       */
      hasUserGesture() {
        // Check for user activation (modern browsers)
        if (navigator.userActivation) {
          return navigator.userActivation.hasBeenActive;
        }

        // Fallback check
        return document.hasStoredUserActivation || false;
      }

      /**
       * Get browser-specific performance settings
       * @returns {Object} Performance settings
       */
      getPerformanceSettings() {
        const workaround = this.workarounds.get(this.browserInfo.name);

        if (!workaround) {
          return {
            maxConcurrentConnections: 8,
            timestampAccuracy: 'medium',
            supportsHotPlugging: false
          };
        }

        return {
          maxConcurrentConnections: workaround.maxConcurrentConnections,
          timestampAccuracy: workaround.timestampAccuracy,
          supportsHotPlugging: workaround.supportsHotPlugging,
          requiresPolling: workaround.requiresPolling || false
        };
      }

      /**
       * Get browser information
       * @returns {Object} Browser information
       */
      getBrowserInfo() {
        return this.browserInfo;
      }

      /**
       * Get compatibility issues
       * @returns {Array} Array of compatibility issues
       */
      getCompatibilityIssues() {
        return [...this.compatibilityIssues];
      }

      /**
       * Check if browser supports specific MIDI feature
       * @param {string} feature - Feature to check
       * @returns {boolean} True if feature is supported
       */
      supportsFeature(feature) {
        const workaround = this.workarounds.get(this.browserInfo.name);
        if (!workaround) return false;

        switch (feature) {
          case 'hotPlugging':
            return workaround.supportsHotPlugging;
          case 'highResolutionTime':
            return workaround.supportsHighResolutionTime;
          case 'userGesture':
            return workaround.requiresUserGesture;
          default:
            return false;
        }
      }
    }

    /**
     * MIDI Performance Monitor
     * Monitors and tracks MIDI performance metrics
     */
    class MIDIPerformanceMonitor {
      constructor() {
        this.messageCount = 0;
        this.processingTimes = [];
        this.latencyMeasurements = [];
        this.startTime = null;
        this.isRunning = false;
        this.maxHistorySize = 1000;

        // Performance thresholds
        this.thresholds = {
          maxProcessingTime: 10, // ms
          maxLatency: 50, // ms
          maxQueueSize: 100
        };

        // Performance alerts
        this.alerts = [];
        this.alertCallback = null;
      }

      /**
       * Start performance monitoring
       */
      start() {
        this.startTime = performance.now();
        this.isRunning = true;
        this.messageCount = 0;
        this.processingTimes = [];
        this.latencyMeasurements = [];
        this.alerts = [];

        console.log('MIDI Performance monitoring started');
      }

      /**
       * Stop performance monitoring
       */
      stop() {
        this.isRunning = false;
        console.log('MIDI Performance monitoring stopped');

        // Generate final report
        const report = this.getPerformanceReport();
        console.log('Final Performance Report:', report);
      }

      /**
       * Record processed message
       */
      recordMessage() {
        if (this.isRunning) {
          this.messageCount++;
        }
      }

      /**
       * Record message processing time
       * @param {number} time - Processing time in ms
       */
      recordProcessingTime(time) {
        if (this.isRunning) {
          this.processingTimes.push(time);

          // Maintain history size
          if (this.processingTimes.length > this.maxHistorySize) {
            this.processingTimes.shift();
          }

          // Check for performance issues
          if (time > this.thresholds.maxProcessingTime) {
            this.recordAlert('high_processing_time', `Processing time ${time.toFixed(2)}ms exceeds threshold`);
          }
        }
      }

      /**
       * Record latency measurement
       * @param {number} latency - Latency in ms
       */
      recordLatency(latency) {
        if (this.isRunning) {
          this.latencyMeasurements.push(latency);

          // Maintain history size
          if (this.latencyMeasurements.length > this.maxHistorySize) {
            this.latencyMeasurements.shift();
          }

          // Check for latency issues
          if (latency > this.thresholds.maxLatency) {
            this.recordAlert('high_latency', `Latency ${latency.toFixed(2)}ms exceeds threshold`);
          }
        }
      }

      /**
       * Record performance alert
       * @param {string} type - Alert type
       * @param {string} message - Alert message
       */
      recordAlert(type, message) {
        const alert = {
          type: type,
          message: message,
          timestamp: Date.now(),
          count: 1
        };

        // Check if similar alert exists
        const existingAlert = this.alerts.find(a => a.type === type && a.message === message);
        if (existingAlert) {
          existingAlert.count++;
          existingAlert.timestamp = Date.now();
        } else {
          this.alerts.push(alert);
        }

        // Notify callback if set
        if (this.alertCallback) {
          this.alertCallback(alert);
        }
      }

      /**
       * Get current message count
       * @returns {number} Number of processed messages
       */
      getMessageCount() {
        return this.messageCount;
      }

      /**
       * Get average processing time
       * @returns {number} Average processing time in ms
       */
      getAverageProcessingTime() {
        if (this.processingTimes.length === 0) return 0;
        return this.processingTimes.reduce((sum, time) => sum + time, 0) / this.processingTimes.length;
      }

      /**
       * Get average latency
       * @returns {number} Average latency in ms
       */
      getAverageLatency() {
        if (this.latencyMeasurements.length === 0) return 0;
        return this.latencyMeasurements.reduce((sum, lat) => sum + lat, 0) / this.latencyMeasurements.length;
      }

      /**
       * Get comprehensive performance report
       * @returns {Object} Performance report
       */
      getPerformanceReport() {
        const runtime = this.isRunning && this.startTime ? performance.now() - this.startTime : 0;

        return {
          runtime: runtime,
          messagesProcessed: this.messageCount,
          messagesPerSecond: runtime > 0 ? (this.messageCount / (runtime / 1000)) : 0,

          processing: {
            averageTime: this.getAverageProcessingTime(),
            maxTime: this.processingTimes.length > 0 ? Math.max(...this.processingTimes) : 0,
            minTime: this.processingTimes.length > 0 ? Math.min(...this.processingTimes) : 0,
            samples: this.processingTimes.length
          },

          latency: {
            average: this.getAverageLatency(),
            max: this.latencyMeasurements.length > 0 ? Math.max(...this.latencyMeasurements) : 0,
            min: this.latencyMeasurements.length > 0 ? Math.min(...this.latencyMeasurements) : 0,
            samples: this.latencyMeasurements.length
          },

          alerts: {
            total: this.alerts.length,
            byType: this.getAlertsByType(),
            recent: this.alerts.slice(-5)
          },

          health: this.getHealthStatus()
        };
      }

      /**
       * Get alerts grouped by type
       * @returns {Object} Alerts grouped by type
       */
      getAlertsByType() {
        const grouped = {};
        this.alerts.forEach(alert => {
          if (!grouped[alert.type]) {
            grouped[alert.type] = 0;
          }
          grouped[alert.type] += alert.count;
        });
        return grouped;
      }

      /**
       * Get overall health status
       * @returns {string} Health status (good, warning, critical)
       */
      getHealthStatus() {
        const avgProcessingTime = this.getAverageProcessingTime();
        const avgLatency = this.getAverageLatency();
        const alertCount = this.alerts.length;

        if (avgProcessingTime > this.thresholds.maxProcessingTime * 2 ||
          avgLatency > this.thresholds.maxLatency * 2 ||
          alertCount > 10) {
          return 'critical';
        } else if (avgProcessingTime > this.thresholds.maxProcessingTime ||
          avgLatency > this.thresholds.maxLatency ||
          alertCount > 5) {
          return 'warning';
        } else {
          return 'good';
        }
      }

      /**
       * Set alert callback
       * @param {Function} callback - Alert callback function
       */
      setAlertCallback(callback) {
        this.alertCallback = callback;
      }

      /**
       * Clear all performance data
       */
      clear() {
        this.messageCount = 0;
        this.processingTimes = [];
        this.latencyMeasurements = [];
        this.alerts = [];
      }
    }

    // IntersectionLineRenderer class for managing visual intersection feedback
    class IntersectionLineRenderer {
      constructor(staffContainer) {
        this.staffContainer = staffContainer;
        this.activeLines = new Map(); // note -> lineElement
        this.keyPressStates = new Map(); // note -> { isPressed: boolean, lineElement: Element }
      }

      /**
       * Show intersection line when correct key is played
       * @param {HTMLElement} noteElement - The staff note element
       * @param {string} noteName - The note name (C, D, F, G, A, C5)
       * @param {number} noteDuration - Duration of the note in milliseconds
       * @returns {HTMLElement} The created intersection line element
       */
      showIntersectionLine(noteElement, noteName, noteDuration) {
        if (!noteElement || !noteName) {
          console.warn('IntersectionLineRenderer: Invalid parameters for showIntersectionLine');
          return null;
        }

        // Calculate position based on note rectangle and playback line
        const linePosition = this.calculateLinePosition(noteElement);
        if (!linePosition) {
          console.warn('IntersectionLineRenderer: Could not calculate line position');
          return null;
        }

        // Create intersection line element
        const lineElement = this.createIntersectionLine(noteName, linePosition, noteDuration);

        // Track the line for this note
        this.activeLines.set(noteName, lineElement);

        // Track key press state
        this.keyPressStates.set(noteName, {
          isPressed: true,
          lineElement: lineElement
        });

        return lineElement;
      }

      /**
       * Hide intersection line immediately when key is released
       * @param {string} noteName - The note name
       */
      hideIntersectionLine(noteName) {
        const keyState = this.keyPressStates.get(noteName);
        if (keyState && keyState.lineElement) {
          console.log(`🎨 Hiding intersection line for ${noteName} (key released)`);
          this.removeIntersectionLine(keyState.lineElement);
          this.keyPressStates.delete(noteName);
          this.activeLines.delete(noteName);
        }
      }

      /**
       * Handle key press event to track state
       * @param {string} noteName - The note name
       */
      trackKeyPress(noteName) {
        const existingState = this.keyPressStates.get(noteName);
        if (existingState) {
          existingState.isPressed = true;
        } else {
          this.keyPressStates.set(noteName, {isPressed: true, lineElement: null});
        }
      }

      /**
       * Handle key release event
       * @param {string} noteName - The note name
       */
      handleKeyRelease(noteName) {
        const keyState = this.keyPressStates.get(noteName);
        if (keyState) {
          keyState.isPressed = false;

          // If there's an active line, hide it immediately
          if (keyState.lineElement) {
            this.hideIntersectionLine(noteName);
          }
        }
      }

      /**
       * Create intersection line element
       * @param {string} noteName - The note name
       * @param {string} color - The color for the line
       * @param {Object} position - Position data {x, y, width, height}
       * @param {number} maxDuration - Maximum duration in milliseconds
       * @returns {HTMLElement} The created line element
       */
      createIntersectionLine(noteName, position, maxDuration) {
        console.log(`........playing-hint line will sustain for duration ${maxDuration}`);
        const lineElement = document.createElement('div');
        lineElement.className = 'intersection-line';
        lineElement.setAttribute('data-note', noteName);

        // Style the intersection line
        lineElement.style.position = 'absolute';
        lineElement.style.left = `${position.x}px`;
        lineElement.style.top = `${position.y}px`;

        // Add to staff container
        this.staffContainer.appendChild(lineElement);

        // Set up automatic fade-out when note duration completes
        setTimeout(() => {
          const keyState = this.keyPressStates.get(noteName);
          if (keyState && keyState.isPressed && keyState.lineElement === lineElement) {
            console.log(`🎨 Auto-fading intersection line for ${noteName} (duration complete)`);
            this.fadeOutIntersectionLine(lineElement);
            this.keyPressStates.delete(noteName);
            this.activeLines.delete(noteName);
          }
        }, maxDuration);

        return lineElement;
      }

      /**
       * Calculate intersection line position based on note element and playback line
       * @param {HTMLElement} noteElement - The staff note element
       * @returns {Object|null} Position data {x, y, width, height}
       */
      calculateLinePosition(noteElement) {
        if (!noteElement) return null;

        const noteRect = noteElement.getBoundingClientRect();
        const staffRect = this.staffContainer.getBoundingClientRect();

        // Get playback line position
        const playbackLine = document.querySelector('.playback-line');
        if (!playbackLine) return null;

        const playbackRect = playbackLine.getBoundingClientRect();

        // Position relative to staff container
        const x = playbackRect.left - staffRect.left;
        const y = noteRect.top - staffRect.top;

        return {
          x: x,
          y: y
        };
      }

      /**
       * Fade out intersection line with smooth animation
       * @param {HTMLElement} lineElement - The line element to fade out
       */
      fadeOutIntersectionLine(lineElement) {
        if (!lineElement || !lineElement.parentNode) return;

        lineElement.style.opacity = '0';

        setTimeout(() => {
          this.removeIntersectionLine(lineElement);
        }, 300); // Match transition duration
      }

      /**
       * Remove intersection line from DOM
       * @param {HTMLElement} lineElement - The line element to remove
       */
      removeIntersectionLine(lineElement) {
        if (lineElement && lineElement.parentNode) {
          lineElement.parentNode.removeChild(lineElement);
        }
      }

      /**
       * Clean up expired lines (maintenance method)
       */
      cleanupExpiredLines() {
        this.activeLines.forEach((lineElement, noteName) => {
          if (!lineElement.parentNode) {
            this.activeLines.delete(noteName);
            this.keyPressStates.delete(noteName);
          }
        });
      }

      /**
       * Dispose of all resources
       */
      dispose() {
        // Remove all active lines
        this.activeLines.forEach(lineElement => {
          this.removeIntersectionLine(lineElement);
        });

        // Clear all tracking data
        this.activeLines.clear();
        this.keyPressStates.clear();

        console.log('IntersectionLineRenderer disposed');
      }
    }

    // Virtual Piano Keyboard class
    class VirtualPianoKeyboard {
      constructor() {
        this.keyboardContainer = null;
        this.keys = new Map(); // Store key elements by note name
        this.activeKeys = new Set(); // Currently highlighted keys
        this.pressedKeys = new Set(); // Currently pressed keys

        // Initialize ToneJS audio engine for note playback
        this.audioEngine = new ToneJSAudioEngine();
        this.audioInitialized = false;

        // Track pending operations to handle async event ordering
        this.pendingOperations = new Map(); // note -> Promise
        this.keyStates = new Map(); // note -> { isPressed: boolean, pendingRelease: boolean }

        // Define the keyboard layout with note names and frequencies
        this.keyLayout = [
          // white keys
          {note: 'A3', label: 'A'},
          {note: 'B3', label: 'B'},
          {note: 'C4', label: 'C'},
          {note: 'D4', label: 'D'},
          {note: 'E4', label: 'E'},
          {note: 'F4', label: 'F'},
          {note: 'G4', label: 'G'},
          {note: 'A4', label: 'A'},
          {note: 'B4', label: 'B'},
          {note: 'C5', label: 'C'},
          {note: 'D5', label: 'D'},
          {note: 'E5', label: 'E'},
          {note: 'F5', label: 'F'},

          // black keys
          {note: 'A#3', label: 'A#'},
          {note: 'C#4', label: 'C#'},
          {note: 'D#4', label: 'D#'},
          {note: 'F#4', label: 'F#'},
          {note: 'G#4', label: 'G#'},
          {note: 'A#4', label: 'A#'},
          {note: 'C#5', label: 'C#'},
          {note: 'D#5', label: 'D#'},
        ];

        console.log('VirtualPianoKeyboard initialized with audio engine');
      }

      isBlackKey(key) {
        return key.note.includes('#');
      }



      /**
       * Initialize audio engine (called on first user interaction)
       * @returns {Promise<boolean>} True if audio is ready
       */
      async initializeAudio() {
        if (this.audioInitialized) {
          // Verify ToneJS audio context is still working
          const audioReady = await this.audioEngine.resumeAudioContext();
          return audioReady;
        }

        try {
          console.log('🎵 [TONEJS-INIT] Initializing ToneJS keyboard audio on user interaction...');

          // Initialize ToneJS audio engine
          const success = await this.audioEngine.initializeAudio();
          console.log(`🎵 [TONEJS-INIT] ToneJS initialization result: ${success}`);

          if (success) {
            // Ensure ToneJS context is resumed (required for user interaction)
            console.log('🎵 [TONEJS-INIT] Resuming ToneJS audio context...');
            const audioReady = await this.audioEngine.resumeAudioContext();
            console.log(`🎵 [TONEJS-INIT] ToneJS audio context ready: ${audioReady}`);

            if (audioReady) {
              this.audioInitialized = true;
              console.log('🎵 [TONEJS-INIT] ToneJS keyboard audio engine initialized and ready');
            } else {
              console.warn('🎵 [TONEJS-INIT] ToneJS audio context not ready after initialization');
              return false;
            }
          } else {
            console.warn('🎵 [TONEJS-INIT] ToneJS audio engine initialization failed - keyboard will work without sound');
            return false;
          }
        } catch (error) {
          console.error('Error initializing ToneJS keyboard audio:', error);
          // Try to enable fallback audio
          try {
            await this.audioEngine.tryFallbackAudio();
            console.log('Fallback audio enabled');
            return true;
          } catch (fallbackError) {
            console.error('Fallback audio also failed:', fallbackError);
            return false;
          }
        }

        return this.audioInitialized;
      }

      /**
       * Create and render the virtual piano keyboard
       * @param {HTMLElement} containerElement - The container element to render the keyboard in
       */
      createKeyboard(containerElement) {
        if (!containerElement) {
          console.error('Container element not provided for keyboard creation');
          return;
        }

        this.keyboardContainer = containerElement;

        // Clear any existing keyboard content
        containerElement.innerHTML = '';

        // Create the new robust keyboard layout where black keys are contained within white keys
        this.createRobustKeyboardLayout(containerElement);

        console.log(`Virtual piano keyboard created with ${this.keyLayout.length} keys`);
      }

      /**
       * Create the new robust keyboard layout where black keys are positioned between white keys
       * @param {HTMLElement} containerElement - Container to append the keyboard to
       */
      createRobustKeyboardLayout(containerElement) {
        const whiteKeys = this.keyLayout.filter(key => !this.isBlackKey(key));
        
        whiteKeys.forEach((whiteKeyData, index) => {
          // Create white key container
          const whiteKeyContainer = document.createElement('div');
          whiteKeyContainer.className = 'piano-key-container';
          
          // Create the white key element
          const whiteKeyElement = this.createKeyElement(whiteKeyData, 'white');
          whiteKeyContainer.appendChild(whiteKeyElement);
          
          // Check if there should be a black key after this white key
          const blackKeyAfter = this.findBlackKeyAfter(whiteKeyData.note);
          
          if (blackKeyAfter) {
            // Create the black key element positioned between this white key and the next
            const blackKeyElement = this.createKeyElement(blackKeyAfter, 'black');
            whiteKeyContainer.appendChild(blackKeyElement);
          }
          
          containerElement.appendChild(whiteKeyContainer);
        });
      }

      /**
       * Find the black key that should be positioned after a given white key
       * @param {string} whiteKeyNote - The white key note (e.g., 'C4', 'D4')
       * @returns {Object|null} The black key data that comes after this white key, or null if none exists
       */
      findBlackKeyAfter(whiteKeyNote) {
        // Extract note name and octave
        const noteName = whiteKeyNote.slice(0, -1);
        const octave = whiteKeyNote.slice(-1);
        
        // Black keys exist after: C, D, F, G, A (but not after E and B)
        const hasBlackKeyAfter = ['C', 'D', 'F', 'G', 'A'].includes(noteName);
        
        if (hasBlackKeyAfter) {
          const sharpNote = `${noteName}#${octave}`;
          return this.keyLayout.find(key => key.note === sharpNote);
        }
        
        return null;
      }

      /**
       * Create an individual piano key element (for the new robust layout)
       * @param {Object} keyData - Key configuration object
       * @param {string} keyType - 'white' or 'black'
       * @returns {HTMLElement} The created key element
       */
      createKeyElement(keyData, keyType) {
        const keyElement = document.createElement('div');
        keyElement.className = `piano-key ${keyType}`;
        keyElement.setAttribute('data-note', keyData.note);
        keyElement.textContent = keyData.label;

        // Add mouse event handlers for press/hold/release
        keyElement.addEventListener('mousedown', (event) => this.handleKeyDown(event, keyData));
        keyElement.addEventListener('mouseup', (event) => this.handleKeyUp(event, keyData));
        keyElement.addEventListener('mouseenter', (event) => this.handleKeyHover(event, keyData, true));
        keyElement.addEventListener('mouseleave', (event) => this.handleKeyLeave(event, keyData));

        // Add touch event handlers with better touch support for sustained notes
        keyElement.addEventListener('touchstart', (event) => this.handleKeyDown(event, keyData), {passive: false});
        keyElement.addEventListener('touchend', (event) => this.handleKeyUp(event, keyData), {passive: false});
        keyElement.addEventListener('touchmove', (event) => this.handleTouchMove(event, keyData), {passive: false});

        // Add keyboard accessibility support for sustained notes
        keyElement.addEventListener('keydown', (event) => this.handleKeyboardInput(event, keyData));
        keyElement.addEventListener('keyup', (event) => this.handleKeyboardInput(event, keyData));
        keyElement.addEventListener('focus', (event) => this.handleKeyFocus(event, keyData, true));
        keyElement.addEventListener('blur', (event) => this.handleKeyFocus(event, keyData, false));

        // Prevent context menu on right click
        keyElement.addEventListener('contextmenu', (event) => event.preventDefault());

        // Prevent text selection
        keyElement.addEventListener('selectstart', (event) => event.preventDefault());

        // Store key element reference
        this.keys.set(keyData.note, keyElement);

        return keyElement;
      }

      /**
       * Handle key hover events for visual feedback
       * @param {Event} event - The hover event
       * @param {Object} keyData - Key configuration object
       * @param {boolean} isEntering - True if entering, false if leaving
       */
      handleKeyHover(event, keyData, isEntering) {
        const keyElement = this.keys.get(keyData.note);
        if (!keyElement) return;
      }

      /**
       * Handle touch move events to prevent accidental key presses and stuck notes
       * @param {TouchEvent} event - The touch move event
       * @param {Object} keyData - Key configuration object
       */
      handleTouchMove(event, keyData) {
        event.preventDefault();

        // If touch moves significantly, consider it a scroll/drag gesture
        const touch = event.touches[0];
        if (touch) {
          const keyElement = this.keys.get(keyData.note);
          if (!keyElement) return;

          const rect = keyElement.getBoundingClientRect();

          // Check if touch is still within key bounds with tolerance
          const tolerance = 10; // pixels
          const isWithinKey = (
            touch.clientX >= (rect.left - tolerance) &&
            touch.clientX <= (rect.right + tolerance) &&
            touch.clientY >= (rect.top - tolerance) &&
            touch.clientY <= (rect.bottom + tolerance)
          );

          // If touch moved outside key bounds, release it to prevent stuck notes
          if (!isWithinKey && (this.pressedKeys.has(keyData.note) || this.pendingOperations.has(keyData.note))) {
            console.log(`🎹 [ASYNC-SERIALIZE] Touch moved outside key bounds, releasing: ${keyData.note}`);
            this.handleKeyRelease(event, keyData, 'touch-leave');
          }
        }
      }

      /**
       * Handle keyboard input for accessibility
       * @param {KeyboardEvent} event - The keyboard event
       * @param {Object} keyData - Key configuration object
       */
      async handleKeyboardInput(event, keyData) {
        // Handle Enter and Space for sustained notes (keydown starts, keyup releases)
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();

          if (event.type === 'keydown' && !event.repeat) {
            // Start sustained note on keydown (if not already pressed)
            await this.handleKeyDown(event, keyData);
          } else if (event.type === 'keyup') {
            // Release sustained note on keyup
            await this.handleKeyUp(event, keyData);
          }
        }

        // Handle arrow keys for navigation
        if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
          event.preventDefault();
          this.navigateKeys(keyData.note, event.key === 'ArrowRight');
        }
      }

      /**
       * Handle key focus for accessibility
       * @param {Event} event - The focus event
       * @param {Object} keyData - Key configuration object
       * @param {boolean} isFocusing - True if focusing, false if blurring
       */
      handleKeyFocus(event, keyData, isFocusing) {
        const keyElement = this.keys.get(keyData.note);
        if (!keyElement) return;

        if (isFocusing) {
          keyElement.style.outline = '2px solid #007bff';
          keyElement.style.outlineOffset = '2px';
        } else {
          keyElement.style.outline = '';
          keyElement.style.outlineOffset = '';
        }
      }

      /**
       * Navigate between keys using keyboard
       * @param {string} currentNote - Currently focused note
       * @param {boolean} forward - True for forward navigation, false for backward
       */
      navigateKeys(currentNote, forward) {
        const whiteKeys = this.keyLayout.filter(key => !this.isBlackKey(key)).map(key => key.note);
        const currentIndex = whiteKeys.indexOf(currentNote);

        if (currentIndex === -1) return;

        let nextIndex;
        if (forward) {
          nextIndex = (currentIndex + 1) % whiteKeys.length;
        } else {
          nextIndex = (currentIndex - 1 + whiteKeys.length) % whiteKeys.length;
        }

        const nextKey = this.keys.get(whiteKeys[nextIndex]);
        if (nextKey) {
          nextKey.focus();
        }
      }

      /**
       * Handle key press events (mouse click or touch)
       * @param {Event} event - The interaction event
       * @param {Object} keyData - Key configuration object
       */
      /**
       * Enhanced key down handler with proper async event serialization
       * @param {Event} event - The key down event (mousedown/touchstart)
       * @param {Object} keyData - Key configuration object
       */
      async handleKeyDown(event, keyData) {
        event.preventDefault();
        event.stopPropagation();

        const startTime = performance.now();
        const note = keyData.note;

        // Check if there's already a pending operation for this key
        if (this.pendingOperations.has(note)) {
          console.log(`🎹 [ASYNC-SERIALIZE] Key ${note} has pending operation, waiting...`);
          await this.pendingOperations.get(note);
        }

        // Check if key is already pressed after waiting for pending operations
        if (this.pressedKeys.has(note)) {
          console.log(`🎹 [ENHANCED] Key already pressed, ignoring: ${note}`);
          return;
        }

        // Initialize key state tracking
        this.keyStates.set(note, {isPressed: false, pendingRelease: false});

        // Create a serialized operation promise
        const keyDownOperation = this.performKeyDownOperation(event, keyData, startTime);
        this.pendingOperations.set(note, keyDownOperation);

        try {
          await keyDownOperation;
        } finally {
          // Clean up the pending operation
          this.pendingOperations.delete(note);
        }
      }

      /**
       * Perform the actual key down operation with proper serialization
       * @param {Event} event - The key down event
       * @param {Object} keyData - Key configuration object
       * @param {number} startTime - Performance start time
       */
      async performKeyDownOperation(event, keyData, startTime) {
        const note = keyData.note;
        const eventType = event.type;

        console.log(`🎹 [ASYNC-SERIALIZE] Starting key down operation for: ${note}`);

        // Initialize audio on first user interaction (required by browsers)
        if (!this.audioInitialized) {
          console.log(`🎹 [ASYNC-SERIALIZE] Initializing audio for: ${note}`);
          await this.initializeAudio();
        }

        // Check if a release was requested while we were initializing
        const keyState = this.keyStates.get(note);
        if (keyState && keyState.pendingRelease) {
          console.log(`🎹 [ASYNC-SERIALIZE] Release was requested during initialization for: ${note}, aborting press`);
          this.keyStates.delete(note);
          return;
        }

        // Start sustained audio for the pressed key
        console.log(`🎹 [ASYNC-SERIALIZE] Starting sustained note for: ${note}`);
        const audioSuccess = await this.startSustainedNote(note);

        // Check again if a release was requested while starting audio
        const keyStateAfterAudio = this.keyStates.get(note);
        if (keyStateAfterAudio && keyStateAfterAudio.pendingRelease) {
          console.log(`🎹 [ASYNC-SERIALIZE] Release was requested during audio start for: ${note}, releasing immediately`);
          if (audioSuccess) {
            await this.stopSustainedNote(note);
          }
          this.keyStates.delete(note);
          return;
        }

        if (audioSuccess) {
          // Mark key as successfully pressed
          if (keyStateAfterAudio) {
            keyStateAfterAudio.isPressed = true;
          }

          // Add visual feedback for key press with enhanced styling
          const keyElement = this.keys.get(note);
          if (keyElement) {
            // Add pressed state with immediate visual feedback
            keyElement.classList.add('pressed');
            this.pressedKeys.add(note);

            // Add subtle animation for better feedback
            keyElement.style.filter = 'brightness(0.9)';
          }

          // Track performance metrics
          const responseTime = performance.now() - startTime;
          console.log(`🎹 [ASYNC-SERIALIZE] Key pressed successfully (${eventType}): ${note} (${keyData.frequency}Hz) - Response time: ${responseTime.toFixed(2)}ms`);

          // Trigger key press handler - let the app handle all feedback logic
          if (this.onKeyPressed) {
            this.onKeyPressed(keyData);
          }
        } else {
          console.warn(`🎹 [ASYNC-SERIALIZE] Failed to start sustained note for: ${note}`);
          this.keyStates.delete(note);
        }
      }

      /**
       * Enhanced key up handler with proper async event serialization
       * @param {Event} event - The key up event (mouseup/touchend)
       * @param {Object} keyData - Key configuration object
       */
      async handleKeyUp(event, keyData) {
        event.preventDefault();
        event.stopPropagation();

        const eventType = event.type;
        const note = keyData.note;

        console.log(`🎹 [ASYNC-SERIALIZE] Key up event (${eventType}): ${note}`);

        // Check if there's a pending key down operation
        if (this.pendingOperations.has(note)) {
          console.log(`🎹 [ASYNC-SERIALIZE] Key ${note} has pending down operation, marking for release...`);

          // Mark that a release is pending
          const keyState = this.keyStates.get(note);
          if (keyState) {
            keyState.pendingRelease = true;
          } else {
            this.keyStates.set(note, {isPressed: false, pendingRelease: true});
          }

          // Wait for the pending operation to complete
          await this.pendingOperations.get(note);

          // The key down operation should have handled the release if it was marked as pending
          console.log(`🎹 [ASYNC-SERIALIZE] Pending operation completed for: ${note}`);
          return;
        }

        // No pending operation, proceed with normal release
        await this.handleKeyRelease(event, keyData, 'key-up');
      }

      /**
       * Enhanced mouse leave handler to prevent stuck notes with async serialization
       * @param {Event} event - The mouse leave event
       * @param {Object} keyData - Key configuration object
       */
      async handleKeyLeave(event, keyData) {
        const note = keyData.note;

        // Only release if the key is currently pressed or has pending operations (prevents stuck notes)
        if (this.pressedKeys.has(note) || this.pendingOperations.has(note)) {
          console.log(`🎹 [ASYNC-SERIALIZE] Mouse left key while pressed/pending, releasing to prevent stuck note: ${note}`);
          await this.handleKeyRelease(event, keyData, 'mouse-leave');
        }

        // Handle normal hover leave
        this.handleKeyHover(event, keyData, false);
      }

      /**
       * Start sustained audio for a specific note (for key press and hold)
       * @param {string} noteName - Name of the note to sustain (e.g., 'C4', 'D4')
       * @returns {Promise<boolean>} True if note was started successfully, false otherwise
       */
      async startSustainedNote(noteName) {
        console.log(`🎵 [TONEJS] Starting sustained note: ${noteName}`);
        console.log(`🎵 [TONEJS] Audio initialized: ${this.audioInitialized}`);
        console.log(`🎵 [TONEJS] Audio engine enabled: ${this.audioEngine.isAudioEnabled}`);

        try {
          // Check ToneJS audio engine status
          const audioStatus = this.audioEngine.getStatus();
          console.log(`🎵 [TONEJS] Audio engine status:`, audioStatus);

          // Start sustained note using ToneJS (no duration = sustained until release)
          await this.audioEngine.sustainNote(noteName, 0.8); // 0.8 velocity
          console.log(`🎵 [TONEJS] Sustained note started for: ${noteName}`);
          return true;
        } catch (error) {
          console.error(`🎵 [TONEJS-ERROR] Failed to start sustained note for ${noteName}:`, error);
          return false;
        }
      }

      /**
       * Stop sustained audio for a specific note (for key release)
       * @param {string} noteName - Name of the note to release (e.g., 'C4', 'D4')
       * @returns {Promise<boolean>} True if note was released successfully, false otherwise
       */
      async stopSustainedNote(noteName) {
        console.log(`🎵 [TONEJS] Stopping sustained note: ${noteName}`);

        try {
          // Release sustained note using ToneJS
          await this.audioEngine.releaseNote(noteName);
          console.log(`🎵 [TONEJS] Sustained note released for: ${noteName}`);
          return true;
        } catch (error) {
          console.error(`🎵 [TONEJS-ERROR] Failed to release sustained note for ${noteName}:`, error);
          return false;
        }
      }

      /**
       * Play audio for a specific note (compatibility method for quick clicks)
       * @param {string} noteName - Name of the note to play (e.g., 'C4', 'D4')
       * @returns {Promise<void>}
       */
      async playNoteAudio(noteName) {
        console.log(`🎵 [TONEJS] Playing note audio: ${noteName}`);

        try {
          // For quick clicks, play note with short duration
          await this.audioEngine.playNoteByName(noteName, 0.3); // 0.3 second duration
          console.log(`🎵 [TONEJS] Note audio completed for: ${noteName}`);
        } catch (error) {
          console.error(`🎵 [TONEJS-ERROR] Failed to play note audio for ${noteName}:`, error);
        }
      }

      /**
       * Enhanced key release handler with proper async serialization
       * @param {Event} event - The release event (can be null for timeout)
       * @param {Object} keyData - Key configuration object
       * @param {string} source - Source of the release event for debugging
       */
      async handleKeyRelease(event, keyData, source = 'unknown') {
        const note = keyData.note;
        const keyElement = this.keys.get(note);

        console.log(`🎹 [ASYNC-SERIALIZE] Key release requested (${source}): ${note}`);

        // Check if there's a pending operation for this key
        if (this.pendingOperations.has(note)) {
          console.log(`🎹 [ASYNC-SERIALIZE] Key ${note} has pending operation during release, waiting...`);
          await this.pendingOperations.get(note);
        }

        // Only proceed if the key is actually pressed
        if (!keyElement || !this.pressedKeys.has(note)) {
          console.log(`🎹 [ASYNC-SERIALIZE] Key ${note} not in pressed state, skipping release`);
          // Clean up any remaining state tracking
          this.keyStates.delete(note);
          return;
        }

        // Create a serialized release operation
        const keyReleaseOperation = this.performKeyReleaseOperation(keyData, source);
        this.pendingOperations.set(note, keyReleaseOperation);

        try {
          await keyReleaseOperation;
        } finally {
          // Clean up the pending operation and state tracking
          this.pendingOperations.delete(note);
          this.keyStates.delete(note);
        }
      }

      /**
       * Perform the actual key release operation with proper serialization
       * @param {Object} keyData - Key configuration object
       * @param {string} source - Source of the release event for debugging
       */
      async performKeyReleaseOperation(keyData, source) {
        const note = keyData.note;
        const keyElement = this.keys.get(note);

        console.log(`🎹 [ASYNC-SERIALIZE] Performing key release operation for: ${note}`);

        try {
          // Stop sustained audio for the released key
          const audioSuccess = await this.stopSustainedNote(note);

          if (audioSuccess || true) { // Always clean up visual state even if audio fails
            // Remove pressed state with enhanced visual feedback
            if (keyElement) {
              keyElement.classList.remove('pressed');
              keyElement.style.transform = '';
              keyElement.style.filter = '';
            }

            this.pressedKeys.delete(note);

            // Notify intersection line renderer about key release
            if (this.onKeyReleased) {
              this.onKeyReleased(keyData);
            }

            console.log(`🎹 [ASYNC-SERIALIZE] Key released successfully (${source}): ${note} (${this.pressedKeys.size} keys remaining)`);

            // Trigger any additional key release handlers
            if (this.onKeyReleased) {
              this.onKeyReleased(keyData);
            }
          } else {
            console.warn(`🎹 [ASYNC-SERIALIZE] Failed to stop sustained note for: ${note}`);
          }
        } catch (error) {
          console.error(`🎹 [ASYNC-SERIALIZE-ERROR] Error releasing key ${note}:`, error);

          // Force cleanup even if audio fails
          if (keyElement) {
            keyElement.classList.remove('pressed');
            keyElement.style.transform = '';
            keyElement.style.filter = '';
          }
          this.pressedKeys.delete(note);
        }
      }

      /**
       * Enhanced polyphonic key press handler with improved performance
       * @param {Array} keyNotes - Array of note names to press simultaneously
       * @returns {Promise<boolean>} True if all keys were pressed successfully
       */
      async handleMultipleKeyPress(keyNotes) {
        console.log(`🎵 [ENHANCED-POLY] Starting multiple keys: ${keyNotes.join(', ')}`);

        // Initialize audio if needed
        if (!this.audioInitialized) {
          await this.initializeAudio();
        }

        const startTime = performance.now();
        let successCount = 0;

        // Start sustained notes for all keys simultaneously with error handling
        const promises = keyNotes.map(async (note) => {
          try {
            if (!this.pressedKeys.has(note)) {
              const audioSuccess = await this.startSustainedNote(note);

              if (audioSuccess) {
                // Add visual feedback with enhanced styling
                const keyElement = this.keys.get(note);
                if (keyElement) {
                  keyElement.classList.add('pressed');
                  keyElement.style.filter = 'brightness(0.9)';
                  this.pressedKeys.add(note);
                }
                successCount++;
                return true;
              }
            }
            return false;
          } catch (error) {
            console.error(`🎵 [ENHANCED-POLY-ERROR] Failed to press key ${note}:`, error);
            return false;
          }
        });

        const results = await Promise.all(promises);
        const responseTime = performance.now() - startTime;

        console.log(`🎵 [ENHANCED-POLY] Multiple keys processed: ${successCount}/${keyNotes.length} successful (${responseTime.toFixed(2)}ms)`);

        return successCount === keyNotes.length;
      }

      /**
       * Enhanced polyphonic key release handler with improved cleanup
       * @param {Array} keyNotes - Array of note names to release simultaneously
       * @returns {Promise<boolean>} True if all keys were released successfully
       */
      async handleMultipleKeyRelease(keyNotes) {
        console.log(`🎵 [ENHANCED-POLY] Releasing multiple keys: ${keyNotes.join(', ')}`);

        const startTime = performance.now();
        let successCount = 0;

        // Release sustained notes for all keys simultaneously with error handling
        const promises = keyNotes.map(async (note) => {
          try {
            if (this.pressedKeys.has(note)) {
              const audioSuccess = await this.stopSustainedNote(note);

              if (audioSuccess) {
                // Remove visual feedback with enhanced cleanup
                const keyElement = this.keys.get(note);
                if (keyElement) {
                  keyElement.classList.remove('pressed');
                  keyElement.style.transform = '';
                  keyElement.style.filter = '';
                  this.pressedKeys.delete(note);
                }
                successCount++;
                return true;
              }
            }
            return false;
          } catch (error) {
            console.error(`🎵 [ENHANCED-POLY-ERROR] Failed to release key ${note}:`, error);

            // Force cleanup even if audio fails
            const keyElement = this.keys.get(note);
            if (keyElement) {
              keyElement.classList.remove('pressed');
              keyElement.style.transform = '';
              keyElement.style.filter = '';
              this.pressedKeys.delete(note);
            }
            return false;
          }
        });

        const results = await Promise.all(promises);
        const responseTime = performance.now() - startTime;

        console.log(`🎵 [ENHANCED-POLY] Multiple keys released: ${successCount}/${keyNotes.length} successful (${responseTime.toFixed(2)}ms)`);

        return successCount === keyNotes.length;
      }

      /**
       * Enhanced emergency cleanup for all pressed keys with memory management
       * @returns {Promise<boolean>} True if all keys were released successfully
       */
      async releaseAllKeys() {
        if (this.pressedKeys.size === 0) {
          console.log(`🎵 [ENHANCED-CLEANUP] No keys to release`);
          return true;
        }

        console.log(`🎵 [ENHANCED-CLEANUP] Emergency release of all ${this.pressedKeys.size} pressed keys: ${Array.from(this.pressedKeys).join(', ')}`);

        const keysToRelease = Array.from(this.pressedKeys);
        const startTime = performance.now();

        // Use enhanced multiple key release
        const success = await this.handleMultipleKeyRelease(keysToRelease);

        // Force cleanup any remaining keys (safety measure)
        if (this.pressedKeys.size > 0) {
          console.warn(`🎵 [ENHANCED-CLEANUP] Force cleaning remaining keys: ${Array.from(this.pressedKeys).join(', ')}`);

          this.pressedKeys.forEach(note => {
            const keyElement = this.keys.get(note);
            if (keyElement) {
              keyElement.classList.remove('pressed');
              keyElement.style.transform = '';
              keyElement.style.filter = '';
            }
          });

          this.pressedKeys.clear();
        }

        const responseTime = performance.now() - startTime;
        console.log(`🎵 [ENHANCED-CLEANUP] All keys cleanup completed in ${responseTime.toFixed(2)}ms`);

        return success;
      }

      /**
       * Enhanced chord playing with improved polyphonic support and performance tracking
       * @param {Array} chordNotes - Array of note names forming a chord
       * @param {number} duration - Duration to hold the chord (optional)
       * @returns {Promise<boolean>} True if chord was played successfully
       */
      async playChord(chordNotes, duration = null) {
        console.log(`🎵 [ENHANCED-CHORD] Playing chord: ${chordNotes.join(', ')} ${duration ? `(${duration}s duration)` : '(sustained)'}`);

        // Initialize audio if needed
        if (!this.audioInitialized) {
          await this.initializeAudio();
        }

        const startTime = performance.now();
        let success = false;

        try {
          if (duration) {
            // Play chord for specific duration using ToneJS polyphonic capabilities
            const promises = chordNotes.map(note =>
              this.audioEngine.playNote(note, 0.8, `${duration}s`)
            );
            const results = await Promise.all(promises);
            success = results.every(result => result !== false);

            console.log(`🎵 [ENHANCED-CHORD] Timed chord completed: ${chordNotes.join(', ')}`);
          } else {
            // Start sustained chord using enhanced multiple key press
            success = await this.handleMultipleKeyPress(chordNotes);
            console.log(`🎵 [ENHANCED-CHORD] Sustained chord started: ${chordNotes.join(', ')}`);
          }

          const responseTime = performance.now() - startTime;
          console.log(`🎵 [ENHANCED-CHORD] Chord processing time: ${responseTime.toFixed(2)}ms`);

          return success;
        } catch (error) {
          console.error(`🎵 [ENHANCED-CHORD-ERROR] Failed to play chord:`, error);
          return false;
        }
      }

      /**
       * Release all currently pressed keys
       */
      releaseAllKeys() {
        const pressedKeysCopy = new Set(this.pressedKeys);
        pressedKeysCopy.forEach(note => {
          const keyData = this.keyLayout.find(key => key.note === note);
          if (keyData) {
            this.handleKeyRelease(null, keyData);
          }
        });

        console.log('All keys released');
      }

      /**
       * Get current key state for a specific key
       * @param {string} keyNote - Note name to check
       * @returns {string} Key state: 'normal', 'pressed', 'active', or 'correct'
       */
      getKeyState(keyNote) {
        const keyElement = this.keys.get(keyNote);

        if (!keyElement) return 'normal';

        if (keyElement.classList.contains('correct')) return 'correct';
        if (keyElement.classList.contains('pressed')) return 'pressed';
        if (keyElement.classList.contains('active')) return 'active';

        return 'normal';
      }

      /**
       * Enhanced performance monitoring and memory management
       * @returns {Object} Performance metrics and memory usage statistics
       */
      getPerformanceMetrics() {
        const audioStatus = this.audioEngine ? this.audioEngine.getStatus() : {};

        return {
          pressedKeys: this.pressedKeys.size,
          totalKeys: this.keys.size,
          audioInitialized: this.audioInitialized,
          sustainedNotes: audioStatus.sustainedNotes || 0,
          memoryEstimate: {
            pressedKeys: this.pressedKeys.size * 0.1, // MB estimate per pressed key
            audioEngine: audioStatus.sustainedNotes ? audioStatus.sustainedNotes * 0.2 : 0, // MB estimate per sustained note
            total: (this.pressedKeys.size * 0.1) + (audioStatus.sustainedNotes ? audioStatus.sustainedNotes * 0.2 : 0)
          },
          eventListeners: this.keys.size * 8, // Approximate number of event listeners
          audioContextState: typeof Tone !== 'undefined' ? Tone.context.state : 'unavailable'
        };
      }

      /**
       * Enhanced cleanup method for memory management and stuck note prevention
       * @returns {Promise<boolean>} True if cleanup was successful
       */
      async performCleanup() {
        console.log(`🎹 [ENHANCED-CLEANUP] Starting comprehensive cleanup...`);

        const startTime = performance.now();
        let success = true;

        try {
          // Release all pressed keys
          if (this.pressedKeys.size > 0) {
            const releaseSuccess = await this.releaseAllKeys();
            success = success && releaseSuccess;
          }

          // Clean up any stuck visual states
          this.keys.forEach((keyElement, note) => {
            keyElement.classList.remove('pressed', 'active', 'correct', 'incorrect');
            keyElement.style.transform = '';
            keyElement.style.filter = '';
          });

          // Clear tracking sets
          this.pressedKeys.clear();
          this.activeKeys.clear();

          const responseTime = performance.now() - startTime;
          console.log(`🎹 [ENHANCED-CLEANUP] Comprehensive cleanup completed in ${responseTime.toFixed(2)}ms`);

          return success;
        } catch (error) {
          console.error(`🎹 [ENHANCED-CLEANUP-ERROR] Cleanup failed:`, error);
          return false;
        }
      }

      /**
       * Enhanced diagnostic method for troubleshooting
       * @returns {Object} Comprehensive diagnostic information
       */
      getDiagnostics() {
        const audioStatus = this.audioEngine ? this.audioEngine.getStatus() : {};
        const performanceMetrics = this.getPerformanceMetrics();

        return {
          keyboard: {
            initialized: !!this.keyboardContainer,
            totalKeys: this.keys.size,
            pressedKeys: Array.from(this.pressedKeys),
            activeKeys: Array.from(this.activeKeys)
          },
          audio: {
            initialized: this.audioInitialized,
            engineStatus: audioStatus,
            toneJSAvailable: typeof Tone !== 'undefined',
            contextState: typeof Tone !== 'undefined' ? Tone.context.state : 'unavailable'
          },
          performance: performanceMetrics,
          eventHandlers: {
            mouseEvents: ['mousedown', 'mouseup', 'mouseleave'],
            touchEvents: ['touchstart', 'touchend', 'touchmove'],
            keyboardEvents: ['keydown', 'keyup'],
            totalListeners: this.keys.size * 8
          },
          callbacks: {
            onKeyPressed: typeof this.onKeyPressed === 'function',
            onKeyReleased: typeof this.onKeyReleased === 'function',
          }
        };
      }

      /**
       * Set key state programmatically
       * @param {string} keyNote - Note name to set state for
       * @param {string} state - State to set: 'normal', 'pressed', 'active', or 'correct'
       * @param {number} duration - Duration to maintain state (optional)
       */
      setKeyState(keyNote, state, duration = null) {
        const keyElement = this.keys.get(keyNote);

        if (!keyElement) return;

        // Clear all state classes first
        keyElement.classList.remove('pressed', 'active', 'correct');

        // Add the new state class
        if (state !== 'normal') {
          keyElement.classList.add(state);

          // Update internal state tracking
          if (state === 'pressed') {
            this.pressedKeys.add(keyNote);
          } else if (state === 'active') {
            this.activeKeys.add(keyNote);
          }
        }

        // Remove state after duration if specified
        if (duration && state !== 'normal') {
          setTimeout(() => {
            keyElement.classList.remove(state);
            if (state === 'pressed') {
              this.pressedKeys.delete(keyNote);
            } else if (state === 'active') {
              this.activeKeys.delete(keyNote);
            }
          }, duration);
        }
      }

      /**
       * Callback for when a key is pressed (can be overridden)
       * @param {Object} keyData - Key configuration object
       */
      onKeyPressed(keyData) {
        // This method can be overridden by external code to handle key presses
        // For example, to play audio or provide learning feedback
      }

      /**
       * Callback for when a key is released (can be overridden)
       * @param {Object} keyData - Key configuration object
       */
      onKeyReleased(keyData) {
        // This method can be overridden by external code to handle key releases
      }

      /**
       * Highlight a specific key (used for staff synchronization)
       * @param {string} keyNote - Note name to highlight (e.g., 'C4', 'D4')
       * @param {number} duration - Duration to keep the key highlighted (optional)
       */
      highlightKey(keyNote, duration = null) {
        const keyElement = this.keys.get(keyNote);

        if (keyElement) {
          keyElement.classList.add('active');
          this.activeKeys.add(keyNote);

          // Remove highlight after duration if specified
          if (duration) {
            setTimeout(() => {
              keyElement.classList.remove('active');
              this.activeKeys.delete(keyNote);
            }, duration);
          }

          console.log(`Key highlighted: ${keyNote}`);
        }
      }

      /**
       * Remove highlighting from a specific key
       * @param {string} keyNote - Note name to unhighlight
       */
      unhighlightKey(keyNote) {
        const keyElement = this.keys.get(keyNote);

        if (keyElement) {
          keyElement.classList.remove('active');
          this.activeKeys.delete(keyNote);
        }
      }

      /**
       * Clear all key highlighting
       */
      clearAllHighlights() {
        this.activeKeys.forEach(noteKey => {
          const keyElement = this.keys.get(noteKey);
          if (keyElement) {
            keyElement.classList.remove('active');
          }
        });
        this.activeKeys.clear();
      }

      /**
       * Get all available keys for external access
       * @returns {Map} Map of note names to key elements
       */
      getKeys() {
        return this.keys;
      }

      /**
       * Get currently active (highlighted) keys
       * @returns {Set} Set of currently active key note names
       */
      getActiveKeys() {
        return this.activeKeys;
      }

      /**
       * Get currently pressed keys
       * @returns {Set} Set of currently pressed key note names
       */
      getPressedKeys() {
        return this.pressedKeys;
      }

      /**
       * Check if a specific key is currently pressed
       * @param {string} keyNote - Note name to check
       * @returns {boolean} True if key is pressed
       */
      isKeyPressed(keyNote) {
        return this.pressedKeys.has(keyNote);
      }

      /**
       * Check if a specific key is currently active (highlighted)
       * @param {string} keyNote - Note name to check
       * @returns {boolean} True if key is active
       */
      isKeyActive(keyNote) {
        return this.activeKeys.has(keyNote);
      }

      /**
       * Get count of currently pressed keys
       * @returns {number} Number of pressed keys
       */
      getPressedKeyCount() {
        return this.pressedKeys.size;
      }

      /**
       * Get count of currently active keys
       * @returns {number} Number of active keys
       */
      getActiveKeyCount() {
        return this.activeKeys.size;
      }

      /**
       * Reset all key states to normal
       */
      resetAllKeyStates() {
        // Clear all pressed keys
        this.releaseAllKeys();

        // Clear all active keys
        this.clearAllHighlights();

        // Remove any remaining state classes
        this.keys.forEach((keyElement, note) => {
          keyElement.classList.remove('pressed', 'active', 'correct');
          keyElement.style.opacity = '';
          keyElement.style.outline = '';
          keyElement.style.outlineOffset = '';
        });

        console.log('All key states reset to normal');
      }

      /**
       * Enable or disable all keyboard interactions
       * @param {boolean} enabled - True to enable, false to disable
       */
      setInteractionEnabled(enabled) {
        this.keys.forEach((keyElement, note) => {
          if (enabled) {
            keyElement.style.pointerEvents = '';
            keyElement.removeAttribute('disabled');
            keyElement.setAttribute('tabindex', '0');
          } else {
            keyElement.style.pointerEvents = 'none';
            keyElement.setAttribute('disabled', 'true');
            keyElement.setAttribute('tabindex', '-1');
          }
        });

        console.log(`Keyboard interactions ${enabled ? 'enabled' : 'disabled'}`);
      }

      /**
       * Get keyboard interaction statistics
       * @returns {Object} Statistics about keyboard usage
       */
      getInteractionStats() {
        return {
          totalKeys: this.keys.size,
          pressedKeys: this.pressedKeys.size,
          activeKeys: this.activeKeys.size,
          whiteKeys: this.keyLayout.filter(key => !this.isBlackKey(key)).length,
          blackKeys: this.keyLayout.filter(key => this.isBlackKey(key)).length,
          keyStates: Array.from(this.keys.keys()).map(note => ({
            note: note,
            state: this.getKeyState(note)
          }))
        };
      }

      /**
       * Get audio engine status and capabilities
       * @returns {Object} Audio engine status information
       */
      getAudioStatus() {
        return this.audioEngine.getStatus();
      }

      /**
       * Enable or disable audio playback
       * @param {boolean} enabled - True to enable, false to disable
       */
      setAudioEnabled(enabled) {
        this.audioEngine.setAudioEnabled(enabled);
        console.log(`Keyboard audio ${enabled ? 'enabled' : 'disabled'}`);
      }

      // ===== MIDI INTEGRATION METHODS =====

      /**
       * Handle MIDI note pressed events from external MIDI controller
       * Enhanced with improved learning feedback integration
       * @param {Object} noteData - MIDI note data from MIDIController
       */
      async handleMIDINotePressed(noteData) {
        const {note, velocity, rawVelocity, channel, source, timestamp, deviceName} = noteData;

        console.log(`🎹 [MIDI-INTEGRATION] MIDI Note Pressed: ${note} (vel: ${velocity.toFixed(3)}, raw: ${rawVelocity}, ch: ${channel}) from ${deviceName}`);

        // Map MIDI note to keyboard note if needed
        const keyboardNote = this.mapMIDINoteToKeyboard(note);
        if (!keyboardNote) {
          console.warn(`🎹 [MIDI-INTEGRATION] MIDI note ${note} not found in keyboard layout`);
          return;
        }

        // Find the key data for this note
        const keyData = this.keyLayout.find(key => key.note === keyboardNote);
        if (!keyData) {
          console.warn(`🎹 [MIDI-INTEGRATION] Key data not found for: ${keyboardNote}`);
          return;
        }

        // Check if key is already pressed to avoid conflicts
        if (this.pressedKeys.has(keyboardNote)) {
          console.log(`🎹 [MIDI-INTEGRATION] Key ${keyboardNote} already pressed, ignoring MIDI input`);
          return;
        }

        // Initialize audio if needed
        if (!this.audioInitialized) {
          console.log(`🎹 [MIDI-INTEGRATION] Initializing audio for MIDI input: ${keyboardNote}`);
          await this.initializeAudio();
        }

        try {
          // Start sustained note with MIDI velocity
          const audioSuccess = await this.startSustainedNote(keyboardNote, velocity);

          if (audioSuccess) {
            // Add enhanced MIDI-specific visual feedback
            const keyElement = this.keys.get(keyboardNote);
            if (keyElement) {
              // Add MIDI-specific visual styling with velocity-based intensity
              keyElement.classList.add('pressed', 'midi-pressed');
              keyElement.style.filter = 'brightness(0.85)';

              // Velocity-based visual feedback intensity (Requirements 9.11)
              const glowIntensity = Math.max(0.4, velocity);
              const glowSize = 8 + (velocity * 4); // 8-12px glow based on velocity
              keyElement.style.boxShadow = `0 0 ${glowSize}px rgba(111, 66, 193, ${glowIntensity})`;

              this.pressedKeys.add(keyboardNote);
            }

            console.log(`🎹 [MIDI-INTEGRATION] MIDI key pressed successfully: ${keyboardNote} (velocity: ${velocity.toFixed(3)})`);

            // Process MIDI learning feedback with enhanced velocity handling (Requirements 10.7, 9.10, 9.11)
            if (this.onMIDILearningFeedback) {
              const midiLearningResult = this.onMIDILearningFeedback({
                ...keyData,
                source: 'midi',
                velocity: velocity,
                rawVelocity: rawVelocity,
                channel: channel,
                timestamp: timestamp,
                deviceName: deviceName
              });

              // Apply enhanced MIDI-specific visual feedback based on learning result
              if (midiLearningResult !== undefined) {
                this.applyMIDILearningVisualFeedback(keyboardNote, midiLearningResult, velocity, keyElement);
              }
            }

            // Trigger key press handler with comprehensive MIDI source information
            if (this.onKeyPressed) {
              this.onKeyPressed({
                ...keyData,
                source: 'midi',
                velocity: velocity,
                rawVelocity: rawVelocity,
                channel: channel,
                timestamp: timestamp,
                deviceName: deviceName
              });
            }
          } else {
            console.warn(`🎹 [MIDI-INTEGRATION] Failed to start sustained note for MIDI input: ${keyboardNote}`);
          }
        } catch (error) {
          console.error(`🎹 [MIDI-INTEGRATION] Error handling MIDI note pressed:`, error);
        }
      }

      /**
       * Apply enhanced MIDI-specific visual feedback based on learning result
       * @param {string} keyboardNote - The keyboard note that was pressed
       * @param {boolean} isCorrect - Whether the key press was correct
       * @param {number} velocity - MIDI velocity (0-1 range)
       * @param {HTMLElement} keyElement - The key element for visual feedback
       */
      applyMIDILearningVisualFeedback(keyboardNote, isCorrect, velocity, keyElement) {
        if (!keyElement) return;

        // Remove any existing learning feedback classes
        keyElement.classList.remove('correct-C', 'correct-D', 'correct-E', 'correct-F', 'correct-G', 'correct-A', 'correct-B', 'incorrect-gray');

        if (isCorrect) {
          // Apply unique color feedback for correct MIDI key presses (Requirements 10.7)
          const correctClass = `correct-${keyboardNote[0]}`;
          keyElement.classList.add(correctClass);

          // Enhanced velocity-based visual intensity for MIDI input (Requirements 9.11)
          const glowIntensity = Math.max(0.6, velocity);
          const glowSize = 12 + (velocity * 8); // 12-20px glow based on velocity
          const scaleIntensity = 1.05 + (velocity * 0.15); // 1.05-1.2 scale based on velocity

          const noteColor = this.getNoteColor(keyboardNote);

          // Apply enhanced visual feedback with MIDI-specific styling
          keyElement.style.boxShadow = `0 0 ${glowSize}px rgba(111, 66, 193, ${glowIntensity}), 0 0 ${glowSize * 1.5}px ${noteColor}80`;
          keyElement.style.borderColor = noteColor;

          // Enhanced animation duration based on velocity
          const animationDuration = 500 + (velocity * 300); // 500-800ms based on velocity

          setTimeout(() => {
            keyElement.classList.remove(correctClass);
            keyElement.style.boxShadow = '';
            keyElement.style.borderColor = '';
          }, animationDuration);

          console.log(`✅ [MIDI-LEARNING] Applied correct MIDI feedback: ${keyboardNote} with color ${noteColor} (velocity: ${velocity.toFixed(3)})`);
        } else {
          // Apply gray color feedback for incorrect MIDI key presses (Requirements 10.7)
          keyElement.classList.add('incorrect-gray');

          // Enhanced shake animation with velocity-based intensity
          const shakeIntensity = 2 + (velocity * 3); // 2-5px shake based on velocity
          keyElement.style.animation = `shakeKey 0.3s ease-in-out`;
          keyElement.style.setProperty('--shake-intensity', `${shakeIntensity}px`);

          setTimeout(() => {
            keyElement.classList.remove('incorrect-gray');
            keyElement.style.animation = '';
            keyElement.style.removeProperty('--shake-intensity');
          }, 300);

          console.log(`❌ [MIDI-LEARNING] Applied incorrect MIDI feedback: ${keyboardNote} (velocity: ${velocity.toFixed(3)})`);
        }
      }

      /**
       * Handle MIDI note released events from external MIDI controller
       * @param {Object} noteData - MIDI note data from MIDIController
       */
      async handleMIDINoteReleased(noteData) {
        const {note, velocity, rawVelocity, channel, source, timestamp, deviceName} = noteData;

        console.log(`🎹 [MIDI-INTEGRATION] MIDI Note Released: ${note} (vel: ${velocity.toFixed(3)}, raw: ${rawVelocity}, ch: ${channel}) from ${deviceName}`);

        // Map MIDI note to keyboard note if needed
        const keyboardNote = this.mapMIDINoteToKeyboard(note);
        if (!keyboardNote) {
          console.warn(`🎹 [MIDI-INTEGRATION] MIDI note ${note} not found in keyboard layout`);
          return;
        }

        // Find the key data for this note
        const keyData = this.keyLayout.find(key => key.note === keyboardNote);
        if (!keyData) {
          console.warn(`🎹 [MIDI-INTEGRATION] Key data not found for: ${keyboardNote}`);
          return;
        }

        // Check if key is actually pressed
        if (!this.pressedKeys.has(keyboardNote)) {
          console.log(`🎹 [MIDI-INTEGRATION] Key ${keyboardNote} not in pressed state, ignoring MIDI release`);
          return;
        }

        try {
          // Stop sustained note
          const audioSuccess = await this.stopSustainedNote(keyboardNote);

          if (audioSuccess || true) { // Always clean up visual state
            // Remove visual feedback for MIDI key release
            const keyElement = this.keys.get(keyboardNote);
            if (keyElement) {
              keyElement.classList.remove('pressed', 'midi-pressed');
              keyElement.style.transform = '';
              keyElement.style.filter = '';
              keyElement.style.boxShadow = '';

              // Handle intersection line management for MIDI key release (Requirements 10.7)
              if (this.onMIDIKeyReleased) {
                this.onMIDIKeyReleased({
                  ...keyData,
                  source: 'midi',
                  velocity: velocity,
                  rawVelocity: rawVelocity,
                  channel: channel,
                  timestamp: timestamp,
                  deviceName: deviceName
                });
              }

              this.pressedKeys.delete(keyboardNote);
            }

            console.log(`🎹 [MIDI-INTEGRATION] MIDI key released successfully: ${keyboardNote}`);

            // Trigger key release handler with MIDI source information
            if (this.onKeyReleased) {
              this.onKeyReleased({
                ...keyData,
                source: 'midi',
                velocity: velocity,
                rawVelocity: rawVelocity,
                channel: channel,
                timestamp: timestamp,
                deviceName: deviceName
              });
            }
          } else {
            console.warn(`🎹 [MIDI-INTEGRATION] Failed to stop sustained note for MIDI input: ${keyboardNote}`);
          }
        } catch (error) {
          console.error(`🎹 [MIDI-INTEGRATION] Error handling MIDI note released:`, error);
        }
      }

      /**
       * Map MIDI note names to keyboard note names
       * @param {string} midiNote - MIDI note name (e.g., 'C4', 'D#5')
       * @returns {string|null} Keyboard note name or null if not found
       */
      mapMIDINoteToKeyboard(midiNote) {
        // Direct mapping for notes that match exactly
        if (this.keys.has(midiNote)) {
          return midiNote;
        }

        // Handle common MIDI note variations and octave mappings
        const midiToKeyboardMapping = {
          // Map common MIDI octaves to keyboard layout
          'C3': 'C4',   // Lower octave mapping
          'D3': 'D4',
          'E3': 'E4',
          'F3': 'F4',
          'G3': 'G4',
          'A3': 'A4',
          'B3': 'B4',
          'C#3': 'C#4',
          'D#3': 'D#4',
          'F#3': 'F#4',
          'G#3': 'G#4',
          'A#3': 'A#4',

          // Higher octave mapping
          'C6': 'C5',
          'D6': 'D4',   // Map higher notes down if not available
          'E6': 'E4',
          'F6': 'F4',
          'G6': 'G4',
          'A6': 'A4',
          'B6': 'B4'
        };

        // Check mapping table
        if (midiToKeyboardMapping[midiNote]) {
          if (this.keys.has(midiNote)) {
            return midiNote;
          }
        }

        // Try to find the closest available note in the keyboard
        const availableNotes = Array.from(this.keys.keys());
        const closestNote = this.findClosestNote(midiNote, availableNotes);

        if (closestNote) {
          console.log(`🎹 [MIDI-INTEGRATION] Found closest note for ${midiNote} → ${closestNote}`);
          return closestNote;
        }

        console.warn(`🎹 [MIDI-INTEGRATION] No mapping found for MIDI note: ${midiNote}`);
        return null;
      }

      /**
       * Find the closest available note in the keyboard layout
       * @param {string} targetNote - Target MIDI note name
       * @param {Array} availableNotes - Array of available keyboard notes
       * @returns {string|null} Closest note or null if none found
       */
      findClosestNote(targetNote, availableNotes) {
        // Extract note name and octave from target
        const targetMatch = targetNote.match(/^([A-G]#?)(\d+)$/);
        if (!targetMatch) return null;

        const [, targetNoteName, targetOctave] = targetMatch;
        const targetOctaveNum = parseInt(targetOctave, 10);

        // Find notes with the same note name but different octaves
        const sameNoteNameOptions = availableNotes.filter(note => {
          const match = note.match(/^([A-G]#?)(\d+)$/);
          return match && match[1] === targetNoteName;
        });

        if (sameNoteNameOptions.length > 0) {
          // Return the closest octave match
          return sameNoteNameOptions.reduce((closest, current) => {
            const currentOctave = parseInt(current.match(/\d+$/)[0], 10);
            const closestOctave = parseInt(closest.match(/\d+$/)[0], 10);

            return Math.abs(currentOctave - targetOctaveNum) < Math.abs(closestOctave - targetOctaveNum)
              ? current : closest;
          });
        }

        return null;
      }

      /**
       * Enhanced startSustainedNote method with velocity support for MIDI
       * @param {string} noteName - Name of the note to sustain
       * @param {number} velocity - Note velocity (0-1), defaults to 0.8
       * @returns {Promise<boolean>} True if note was started successfully
       */
      async startSustainedNote(noteName, velocity = 0.8) {
        console.log(`🎵 [TONEJS] Starting sustained note: ${noteName} (velocity: ${velocity.toFixed(3)})`);

        try {
          // Check ToneJS audio engine status
          const audioStatus = this.audioEngine.getStatus();
          console.log(`🎵 [TONEJS] Audio engine status:`, audioStatus);

          // Start sustained note using ToneJS with specified velocity
          await this.audioEngine.sustainNote(noteName, velocity);
          console.log(`🎵 [TONEJS] Sustained note started for: ${noteName}`);
          return true;
        } catch (error) {
          console.error(`🎵 [TONEJS-ERROR] Failed to start sustained note for ${noteName}:`, error);
          return false;
        }
      }

      /**
       * Get MIDI integration status and statistics
       * @returns {Object} MIDI integration status information
       */
      getMIDIIntegrationStatus() {
        return {
          midiSupported: typeof window.midiController !== 'undefined',
          midiInitialized: window.midiController ? window.midiController.isInitialized : false,
          midiConnected: window.midiController ? window.midiController.isConnected : false,
          connectedDevice: window.midiController ? window.midiController.getConnectionStatus().connectedDevice : null,
          keyboardReady: !!this.keyboardContainer,
          audioInitialized: this.audioInitialized,
          pressedKeys: Array.from(this.pressedKeys),
          midiPressedKeys: Array.from(this.pressedKeys).filter(note => {
            const keyElement = this.keys.get(note);
            return keyElement && keyElement.classList.contains('midi-pressed');
          })
        };
      }

      /**
       * Set audio volume
       * @param {number} volume - Volume level (0.0 to 1.0)
       */
      setAudioVolume(volume) {
        this.audioEngine.setMasterVolume(volume);
        console.log(`Keyboard audio volume set to: ${volume}`);
      }

      /**
       * Ensure virtual keyboard is ready for fallback mode
       * This method is called when MIDI connection is lost
       */
      ensureVirtualKeyboardReady() {
        console.log('🎹 Ensuring virtual keyboard is ready for fallback mode');

        // Make sure audio is initialized
        if (!this.audioInitialized) {
          console.log('🎹 Audio not initialized, will initialize on next user interaction');
        }

        // Make sure keyboard is visible and functional
        if (this.keyboardContainer) {
          this.keyboardContainer.style.opacity = '1';
          this.keyboardContainer.style.pointerEvents = 'auto';
          console.log('🎹 Virtual keyboard visibility ensured');
        }

        // Clear any MIDI-specific states
        this.clearMIDIStates();

        // Show fallback notification on keyboard
        this.showFallbackNotification();

        return true;
      }

      /**
       * Clear MIDI-specific states when falling back to virtual keyboard
       */
      clearMIDIStates() {
        // Clear any MIDI-specific visual feedback
        const midiActiveKeys = this.keyboardContainer?.querySelectorAll('.midi-active, .midi-pressed');
        if (midiActiveKeys) {
          midiActiveKeys.forEach(key => {
            key.classList.remove('midi-active', 'midi-pressed', 'midi-correct', 'midi-incorrect');
          });
        }

        console.log('🎹 MIDI-specific states cleared from virtual keyboard');
      }

      /**
       * Show fallback notification on the keyboard
       */
      showFallbackNotification() {
        // Create or update fallback notification
        let notification = document.getElementById('midi-fallback-notification');

        if (!notification) {
          notification = document.createElement('div');
          notification.id = 'midi-fallback-notification';
          notification.style.cssText = `
                        position: absolute;
                        top: -40px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: #fff3cd;
                        color: #856404;
                        padding: 8px 16px;
                        border-radius: 4px;
                        border: 1px solid #ffeaa7;
                        font-size: 12px;
                        font-weight: 500;
                        z-index: 1000;
                        animation: fadeIn 0.3s ease-in;
                    `;

          if (this.keyboardContainer) {
            this.keyboardContainer.style.position = 'relative';
            this.keyboardContainer.appendChild(notification);
          }
        }

        notification.textContent = 'Using virtual keyboard - MIDI connection lost';

        // Auto-hide after 5 seconds
        setTimeout(() => {
          if (notification && notification.parentNode) {
            notification.style.animation = 'fadeOut 0.3s ease-out';
            setTimeout(() => {
              if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
              }
            }, 300);
          }
        }, 5000);

        console.log('🎹 Fallback notification displayed');
      }

      /**
       * Clean up audio resources
       */
      dispose() {
        if (this.audioEngine) {
          this.audioEngine.dispose();
          this.audioInitialized = false;
          console.log('Virtual keyboard audio resources disposed');
        }
      }
    }

    // Piano Tutor App main class
    class PianoTutorApp {
      constructor() {
        this.isPlaying = false;
        this.isPaused = false;
        this.notePositioning = new NotePositioning();
        this.positionedNotes = [];
        this.animationId = null;
        this.startTime = null;
        this.pausedTime = 0;
        this.currentPosition = 0;

        // Learning feedback trigger state - improved algorithm
        // state management:
        // - update nextNoteToPlayIndex when playback line is not in the boundries of a note
        //   and is playing
        // - update nextNoteToPlayIndex on manual navigation
        this.nextNoteToPlayIndex = 0; // Index of the next note that should be played
        this.lastTriggeredNoteIndex = null; // Keep for compatibility
        this.playbackLineElement = null; // Will be set after DOM is ready

        // Learning feedback system properties (moved from VirtualPianoKeyboard)
        this.isPlaybackActive = false;
        this.learningStats = {
          correctMatches: 0,
          incorrectAttempts: 0,
          totalAttempts: 0,
          currentStreak: 0,
          bestStreak: 0,
          accuracyRate: 0,
          lastPlayedKey: null,
          isLearningMode: false,
          // Enhanced MIDI-specific statistics
          midiAttempts: 0,
          midiCorrect: 0,
          virtualAttempts: 0,
          virtualCorrect: 0,
          inputSourceBreakdown: {
            midi: {
              attempts: 0,
              correct: 0,
              accuracy: 0,
              averageVelocity: 0,
              velocitySum: 0,
              deviceBreakdown: {},
              lastActivity: null
            },
            virtual: {attempts: 0, correct: 0, accuracy: 0}
          }
        };

        // Tempo control system
        this.currentTempo = DEFAULT_TEMPO;
        this.playbackSpeed = this.calculatePlaybackSpeed(this.currentTempo);

        console.log(`Piano Tutor App initialized with tempo: ${this.currentTempo}`);

        // Manual interaction state
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartPosition = 0;
        this.lastTouchX = 0;
        this.dragVelocity = 0;
        this.lastMoveTime = 0;

        // Initialize virtual piano keyboard
        this.virtualKeyboard = new VirtualPianoKeyboard();

        // Initialize intersection line renderer (will be set after DOM is ready)
        this.intersectionLineRenderer = null;

        // Initialize timing evaluation system (will be set after DOM is ready)
        this.timingEvaluationSystem = null;

        // Initialize progress bar controller
        this.progressBarController = new ProgressBarController(this, this);

        this.initializeControls();
        this.initializeNotes();
        this.initializeStaffInteraction();
        this.initializeVirtualKeyboard();
        this.initializeProgressBar();
      }

      /**
       * Calculate playback speed based on selected tempo
       * @param {string} tempoName - Name of the tempo marking (e.g., "Moderato")
       * @returns {number} Playback speed in pixels per millisecond
       */
      calculatePlaybackSpeed(tempoName) {
        if (!TEMPO_MARKINGS[tempoName]) {
          console.warn(`Unknown tempo: ${tempoName}. Using default tempo.`);
          tempoName = DEFAULT_TEMPO;
        }

        const tempo = TEMPO_MARKINGS[tempoName];
        const calculatedSpeed = BASE_PLAYBACK_SPEED * tempo.speedMultiplier;

        console.log(`Tempo: ${tempo.name} (${tempo.bpm} BPM) - Speed multiplier: ${tempo.speedMultiplier} - Playback speed: ${calculatedSpeed.toFixed(4)} px/ms`);

        return calculatedSpeed;
      }

      /**
       * Get current tempo information
       * @returns {Object} Current tempo object with name, BPM, and other details
       */
      getCurrentTempoInfo() {
        return TEMPO_MARKINGS[this.currentTempo];
      }

      /**
       * Get all available tempo markings
       * @returns {Object} All tempo markings with their details
       */
      getAllTempoMarkings() {
        return TEMPO_MARKINGS;
      }

      /**
       * Change the current tempo and recalculate playback speed
       * @param {string} tempoName - Name of the new tempo marking
       */
      setTempo(tempoName) {
        if (!TEMPO_MARKINGS[tempoName]) {
          console.warn(`Unknown tempo: ${tempoName}. Keeping current tempo: ${this.currentTempo}`);
          return;
        }

        const oldTempo = this.currentTempo;
        const wasPlaying = this.isPlaying;

        // Store current position for smooth transition
        const currentPositionBeforeChange = this.currentPosition;

        // Update tempo and recalculate playback speed
        this.currentTempo = tempoName;
        const newPlaybackSpeed = this.calculatePlaybackSpeed(tempoName);

        console.log(`Tempo changed from ${oldTempo} to ${tempoName}`);
        console.log(`Playback speed changed from ${this.playbackSpeed.toFixed(4)} to ${newPlaybackSpeed.toFixed(4)} px/ms`);

        // Ensure smooth transitions when changing tempo during playback
        if (wasPlaying) {
          // Pause current playback to recalculate timing
          this.handlePause();

          // Update playback speed
          this.playbackSpeed = newPlaybackSpeed;

          // Recalculate start time based on new tempo and current position
          const currentTimePosition = this.currentPosition / this.playbackSpeed;
          this.pausedTime = currentTimePosition;

          // Resume playback with new tempo
          // Note: Auto-playback removed - user controls tempo only

          console.log(`Smooth tempo transition: maintained position ${currentPositionBeforeChange.toFixed(1)}px, new time equivalent: ${currentTimePosition.toFixed(1)}ms`);
        } else {
          // Not playing, just update the speed for future playback
          this.playbackSpeed = newPlaybackSpeed;

          // If paused, update the timing calculations for the new tempo
          if (this.isPaused && this.currentPosition > 0) {
            const currentTimePosition = this.currentPosition / this.playbackSpeed;
            this.pausedTime = currentTimePosition;
            console.log(`Tempo changed while paused: updated time equivalent to ${currentTimePosition.toFixed(1)}ms`);
          }
        }
      }

      /**
       * Handle tempo selector change event
       * @param {Event} event - The change event from the tempo selector
       */
      handleTempoChange(event) {
        const selectedTempo = event.target.value;
        const previousTempo = this.currentTempo;

        console.log(`User selected tempo: ${selectedTempo} (previous: ${previousTempo})`);

        // Preserve manual navigation functionality with tempo changes
        // Store current interaction state
        const wasDragging = this.isDragging;

        // Apply tempo change
        this.setTempo(selectedTempo);

        // Update timing evaluation system with new tempo settings
        if (this.timingEvaluationSystem) {
          this.timingEvaluationSystem.updateTempoSettings(selectedTempo);
        }

        // Ensure manual navigation state is preserved
        if (wasDragging) {
          console.log('Tempo changed during manual navigation - preserving interaction state');
        }

        // Log successful integration
        console.log(`Tempo control integrated: ${previousTempo} → ${selectedTempo}, playback system and timing evaluation updated`);
      }

      initializeControls() {
        this.tempoSelector = document.getElementById('tempoSelector');

        // Initialize playback line element reference for improved intersection detection
        this.playbackLineElement = document.querySelector('.playback-line');

        this.tempoSelector.addEventListener('change', (event) => this.handleTempoChange(event));
      }

      initializeNotes() {
        // Calculate positions for all notes in the song
        this.positionedNotes = this.notePositioning.calculateAllNotePositions(SONG_DATA.measures);

        // Render the note rectangles
        this.renderNotes();

        // Render the measure bars
        this.renderMeasureBars();

        this.attachToFirstNote();
      }

      /**
       * Initialize touch and mouse event handlers for staff interaction
       */
      initializeStaffInteraction() {
        const staffContainer = document.querySelector('.staff');
        if (!staffContainer) {
          console.error('Staff container not found for interaction setup');
          return;
        }

        // Initialize intersection line renderer with the staff container
        const staffMainContainer = document.querySelector('.staff-container');
        if (staffMainContainer) {
          this.intersectionLineRenderer = new IntersectionLineRenderer(staffMainContainer);
          console.log('IntersectionLineRenderer initialized');
        } else {
          console.error('Staff main container not found for IntersectionLineRenderer');
        }

        // Initialize timing evaluation system
        this.timingEvaluationSystem = new TimingEvaluationSystem(this, this);
        console.log('TimingEvaluationSystem initialized');

        // Mouse event handlers
        staffContainer.addEventListener('mousedown', (event) => this.handlePointerStart(event));
        document.addEventListener('mousemove', (event) => this.handlePointerMove(event));
        document.addEventListener('mouseup', (event) => this.handlePointerEnd(event));

        // Touch event handlers
        staffContainer.addEventListener('touchstart', (event) => this.handlePointerStart(event), {passive: false});
        document.addEventListener('touchmove', (event) => this.handlePointerMove(event), {passive: false});
        document.addEventListener('touchend', (event) => this.handlePointerEnd(event));

        // Prevent context menu on right click for better interaction
        staffContainer.addEventListener('contextmenu', (event) => {
          event.preventDefault();
        });

        console.log('Staff interaction handlers initialized');
      }

      /**
       * Initialize the virtual piano keyboard
       */
      initializeVirtualKeyboard() {
        const keyboardContainer = document.getElementById('virtualKeyboard');
        if (!keyboardContainer) {
          console.error('Virtual keyboard container not found');
          return;
        }

        // Create the keyboard layout and visual structure
        this.virtualKeyboard.createKeyboard(keyboardContainer);

        // Set up keyboard interaction callbacks
        this.virtualKeyboard.onKeyPressed = (keyData) => {
          this.handleVirtualKeyPressed(keyData);
        };

        this.virtualKeyboard.onKeyReleased = (keyData) => {
          this.handleVirtualKeyReleased(keyData);
        };

        // MIDI learning feedback callback
        this.virtualKeyboard.onMIDILearningFeedback = (keyData) => {
          return this.processMIDILearningFeedback(keyData);
        };

        // MIDI key release callback for intersection line management (Requirements 10.7)
        this.virtualKeyboard.onMIDIKeyReleased = (keyData) => {
          // Handle intersection line management for MIDI key release
          if (this.intersectionLineRenderer) {
            this.intersectionLineRenderer.handleKeyRelease(keyData.note);
            console.log(`🎨 [MIDI-INTEGRATION] Intersection line handled for MIDI key release: ${keyData.note}`);
          }

          // Remove note feedback when MIDI key is released
          this.removeAllActiveFeedback();
        };

        // Initialize learning progress display
        this.updateLearningProgressDisplay();
      }

      /**
       * Handle virtual keyboard key press events
       * @param {Object} keyData - Key configuration object
       */
      handleVirtualKeyPressed(keyData) {
        console.log(`Virtual key pressed: ${keyData.note}`);

        // Process learning feedback if in learning mode
        this.processLearningFeedback(keyData);
      }

      /**
       * Handle virtual keyboard key release events
       * @param {Object} keyData - Key configuration object
       */
      handleVirtualKeyReleased(keyData) {
        console.log(`Virtual key released: ${keyData.note}`);

        // Handle intersection line management for key release
        if (this.intersectionLineRenderer) {
          this.intersectionLineRenderer.handleKeyRelease(keyData.note);
        }
        this.hideKeyboardFeedback(keyData.note);

        // Remove note feedback when key is released
        this.removeAllActiveFeedback();
      }

      /**
       * Show enhanced positive feedback with unique colors and intersection lines
       * @param {string} keyNote - Note name that was correctly pressed
       * @param {string} inputSource - Source of input ('virtual' or 'midi')
       */
      showCorrectNoteHighlight(keyNote, inputSource = 'virtual') {
        // Find the current note that should be played
        const noteElement = document.getElementById(`note-${this.nextNoteToPlayIndex}`);
        if (noteElement) {
          // Add positive feedback class to the note with input source indication
          const feedbackClass = inputSource === 'midi' ? 'correct-note-midi' : 'correct-note';
          noteElement.classList.add('correct-note', feedbackClass);

          const currentNote = this.positionedNotes[this.nextNoteToPlayIndex];
          // Calculate note duration in milliseconds for intersection line
          const noteDuration = this.calculateNoteDurationMs(currentNote.duration);

          // Show intersection line if renderer is available
          if (this.intersectionLineRenderer) {
            if (currentNote && currentNote.pitch !== 'rest') {

              // Show intersection line with unique color
              this.intersectionLineRenderer.showIntersectionLine(
                noteElement,
                currentNote.pitch,
                noteDuration
              );

              console.log(`🎨 Intersection line shown for ${currentNote.pitch} (duration: ${noteDuration}ms)`);
            }
          }

          // Store feedback info for later removal based on events
          this.storeActiveFeedback(this.nextNoteToPlayIndex, noteElement, feedbackClass);

          console.log(`✅ Correct note feedback: note-${this.nextNoteToPlayIndex} (${inputSource} input)`);
        }
      }


      /**
       * Show enhanced keyboard feedback with unique colors for each key
       * @param {string} keyNote - Note name that was pressed
       * @param {string} inputSource - Source of input ('virtual' or 'midi')
       * @param {boolean} isCorrect - Whether the key press was correct
       */
      showKeyboardFeedback(keyNote, inputSource = 'virtual', isCorrect = true) {
        const keyElement = this.virtualKeyboard.keys.get(keyNote);
        let pureKeyNote = keyNote[0];

        if (keyElement) {
          if (isCorrect) {
            // Get the base note name for color mapping (remove octave numbers)
            const colorClass = `correct-${pureKeyNote}`;

            // Add unique color class for this specific key
            keyElement.classList.add(colorClass);

            // Track key press for intersection line management
            if (this.intersectionLineRenderer) {
              this.intersectionLineRenderer.trackKeyPress(pureKeyNote);
            }

            console.log(`✅ Enhanced keyboard feedback: ${pureKeyNote} (${colorClass})`);
          } else {
            // Show gray color with shake animation for incorrect keys
            keyElement.classList.add('incorrect-gray');

            console.log(`❌ Incorrect keyboard feedback: ${pureKeyNote} (gray + shake)`);
          }
        }
      }

      hideKeyboardFeedback(keyNote) {
        const keyElement = this.virtualKeyboard.keys.get(keyNote);

        if (keyElement) {
          let pureKeyNote = keyNote[0];
          const colorClass = `correct-${pureKeyNote}`;
          keyElement.classList.remove(colorClass);
          keyElement.classList.remove('incorrect-gray');
        }
      }

      /**
       * Store active feedback for later removal based on events
       * @param {number} noteIndex - Index of the note receiving feedback
       * @param {HTMLElement} noteElement - The note element with feedback
       * @param {string} feedbackClass - The CSS class applied for feedback
       */
      storeActiveFeedback(noteIndex, noteElement, feedbackClass) {
        if (!this.activeFeedbacks) {
          this.activeFeedbacks = new Map();
        }

        this.activeFeedbacks.set(noteIndex, {
          element: noteElement,
          feedbackClass: feedbackClass,
          timestamp: Date.now()
        });
      }

      /**
       * Remove feedback from a specific note
       * @param {number} noteIndex - Index of the note to remove feedback from
       */
      removeNoteFeedback(noteIndex) {
        if (!this.activeFeedbacks || !this.activeFeedbacks.has(noteIndex)) {
          return;
        }

        const feedback = this.activeFeedbacks.get(noteIndex);
        feedback.element.classList.remove('correct-note', feedback.feedbackClass);
        this.activeFeedbacks.delete(noteIndex);

        console.log(`🔄 Removed feedback from note-${noteIndex}`);
      }

      /**
       * Check and remove feedback when playback position is out of note bounds
       */
      checkAndRemoveOutOfBoundsFeedback() {
        if (!this.activeFeedbacks || this.activeFeedbacks.size === 0) {
          return;
        }

        const playbackLineElement = this.playbackLineElement;
        if (!playbackLineElement) {
          return;
        }

        const playbackLineRect = playbackLineElement.getBoundingClientRect();

        // Check each active feedback
        for (const [noteIndex, feedback] of this.activeFeedbacks.entries()) {
          const noteElement = document.getElementById(`note-${noteIndex}`);
          if (!noteElement) {
            this.activeFeedbacks.delete(noteIndex);
            continue;
          }

          const noteRect = noteElement.getBoundingClientRect();

          // Check if playback line is outside the note's horizontal bounds
          // Add small tolerance for decimal precision in getBoundingClientRect()
          const tolerance = 0.5; // 0.5px tolerance for floating-point precision
          const isOutOfBounds = (playbackLineRect.left + tolerance) < noteRect.left ||
            (playbackLineRect.left - tolerance) > noteRect.right;

          if (isOutOfBounds) {
            this.removeNoteFeedback(noteIndex);
          }
        }
      }

      /**
       * Remove all active feedback (called when keys are released)
       */
      removeAllActiveFeedback() {
        if (!this.activeFeedbacks) {
          return;
        }

        for (const noteIndex of this.activeFeedbacks.keys()) {
          this.removeNoteFeedback(noteIndex);
        }

        console.log(`🔄 Removed all active feedback`);
      }

      /**
       * Calculate note duration in milliseconds based on note type and current tempo
       * @param {string} duration - Note duration type ('quarter', 'eighth', 'half', etc.)
       * @returns {number} Duration in milliseconds
       */
      calculateNoteDurationMs(duration) {
        // Base duration for quarter note at 60 BPM = 500ms
        const quarterNoteDuration = (60 / this.currentTempo) * 1000;

        switch (duration) {
          case 'whole': return quarterNoteDuration * 4;
          case 'half': return quarterNoteDuration * 2;
          case 'quarter': return quarterNoteDuration;
          case 'eighth': return quarterNoteDuration / 2;
          case 'sixteenth': return quarterNoteDuration / 4;
          case 'dotted quarter': return quarterNoteDuration * 1.5;
          case 'dotted half': return quarterNoteDuration * 3;
          case 'dotted eighth': return quarterNoteDuration * 0.75;
          default: return quarterNoteDuration; // Default to quarter note
        }
      }

      getExpectedNote() {
        return this.positionedNotes[this.nextNoteToPlayIndex] || null;
      }

      /**
       * Process positive feedback for correct key matches
       * Enhanced with improved statistics tracking and visual feedback
       * @param {Object} keyData - Key configuration object
       * @returns {boolean} True if the key press was correct
       */
      processLearningFeedback(keyData) {
        let expectedNote = this.getExpectedNote();
        const inputSource = keyData.source || 'virtual';

        // Use enhanced timing evaluation system for precise feedback
        if (this.timingEvaluationSystem && this.positionedNotes) {
          const playbackLineBounds = this.timingEvaluationSystem.getPlaybackLineBounds();
          const noteElements = document.querySelectorAll('.note-rectangle');

          const timingResult = this.timingEvaluationSystem.evaluateKeyPress(
            keyData.note,
            playbackLineBounds.center,
            Array.from(noteElements)
          );

          // Update learning statistics with enhanced timing information
          this.updateLearningStats(keyData.note, timingResult.isCorrect, inputSource, timingResult.timing);

          if (timingResult.isCorrect) {
            console.log(`✅ ${timingResult.message} (${inputSource} input)`);
            // Show correct note highlight on staff
            this.showCorrectNoteHighlight(keyData.note, inputSource);
            this.showKeyboardFeedback(keyData.note, inputSource, true);

            // Show timing feedback message
            this.showTimingFeedbackMessage(timingResult.timing, keyData.note);

            if (!this.playbackActive) {
              this.startPlaybackAnimation();
            }
          } else {
            console.log(`❌ ${timingResult.message} (${inputSource} input)`);

            // Show timing-specific feedback
            this.showTimingFeedbackMessage(timingResult.timing, keyData.note, timingResult.expectedNote);

            // Show visual feedback based on timing result
            if (timingResult.timing === 'incorrect') {
              // Display incorrect note visual feedback
              this.timingEvaluationSystem.displayIncorrectNote(keyData.note, playbackLineBounds.center);
              this.showIncorrectFeedback(keyData.note, inputSource);
            } else {
              // Show timing-based feedback (too early/too late)
              this.showTimingBasedFeedback(keyData.note, inputSource, timingResult.timing);
            }
          }

          // Update the learning progress display
          this.updateLearningProgressDisplay();

          return timingResult.isCorrect;
        }

        // Fallback to original logic if timing evaluation system is not available
        if (!expectedNote) {
          return false;
        }

        const isCorrect = keyData.note === expectedNote.pitch;

        // Update learning statistics with input source tracking
        this.updateLearningStats(keyData.note, isCorrect, inputSource);

        if (isCorrect) {
          console.log(`✅ Correct match! Played ${keyData.note}, expected ${expectedNote.pitch} (${inputSource} input)`);
          // Show correct note highlight on staff
          this.showCorrectNoteHighlight(keyData.note, inputSource);
          this.showKeyboardFeedback(keyData.note, inputSource, true);
          if (!this.playbackActive) {
            this.startPlaybackAnimation();
          }
        } else {
          console.log(`❌ Incorrect match! Played ${keyData.note}, expected ${expectedNote.pitch} (${inputSource} input)`);
          // Show negative visual feedback for incorrect match
          this.showIncorrectFeedback(keyData.note, inputSource);
        }

        // Update the learning progress display
        this.updateLearningProgressDisplay();

        return isCorrect;
      }

      /**
       * Process MIDI-specific learning feedback with enhanced velocity handling and intersection line integration
       * @param {Object} keyData - MIDI key data with velocity information
       * @returns {boolean} True if the key press was correct
       */
      processMIDILearningFeedback(keyData) {
        let expectedNote = this.getExpectedNote();
        // Only process feedback during playback and when expected note is set
        if (!this.isPlaybackActive || !expectedNote) {
          return false;
        }

        const isCorrect = keyData.note === expectedNote.pitch;
        const {velocity, rawVelocity, deviceName, timestamp} = keyData;

        // Enhanced MIDI statistics tracking (Requirements 10.7, 9.11)
        this.updateMIDILearningStats(keyData.note, isCorrect, {
          velocity: velocity,
          rawVelocity: rawVelocity,
          deviceName: deviceName,
          timestamp: timestamp
        });

        if (isCorrect) {
          console.log(`✅ [MIDI-LEARNING] Correct MIDI match! Played ${keyData.note}, expected ${expectedNote.pitch} (velocity: ${velocity.toFixed(3)}, device: ${deviceName})`);

          // Enhanced MIDI-specific correct feedback with velocity-based intensity
          this.showMIDICorrectFeedback(keyData.note, velocity);

          // Show correct note highlight on staff with MIDI styling
          this.showCorrectNoteHighlight(keyData.note, 'midi');
          this.showKeyboardFeedback(keyData.note, inputSource, true);

          // Integrate MIDI input with intersection line rendering system (Requirements 10.7)
          if (this.intersectionLineRenderer && this.nextNoteToPlayIndex >= 0) {
            const currentNote = this.positionedNotes[this.nextNoteToPlayIndex];
            if (currentNote && currentNote.pitch === keyData.note) {
              const noteElement = document.querySelector(`.note-rectangle[data-note-index="${this.currentHighlightedNoteIndex}"]`);
              if (noteElement) {
                // Show intersection line with MIDI-specific handling
                const noteDuration = this.calculateNoteDurationMs(currentNote.duration);
                this.intersectionLineRenderer.showIntersectionLine(
                  noteElement,
                  currentNote.pitch,
                  noteDuration
                );

                // Track MIDI key press for intersection line management
                this.intersectionLineRenderer.trackKeyPress(keyData.note);

                console.log(`🎨 [MIDI-LEARNING] Intersection line created for MIDI input: ${keyData.note}`);
              }
            }
          }
        } else {
          console.log(`❌ [MIDI-LEARNING] Incorrect MIDI match! Played ${keyData.note}, expected ${expectedNote.pitch} (velocity: ${velocity.toFixed(3)}, device: ${deviceName})`);

          // Enhanced MIDI-specific incorrect feedback with gray color (Requirements 10.7)
          this.showMIDIIncorrectFeedback(keyData.note, velocity);
        }

        // Update the learning progress display with MIDI-specific data
        this.updateLearningProgressDisplay();

        // Show MIDI-specific statistics in the progress display (Requirements 10.7)
        this.showMIDIStatistics();

        return isCorrect;
      }

      /**
       * Show enhanced MIDI-specific correct feedback with velocity-based intensity
       * @param {string} keyNote - Note name that was correctly pressed
       * @param {number} velocity - MIDI velocity (0-1 range)
       */
      showMIDICorrectFeedback(keyNote, velocity = 0.8) {
        const keyElement = this.virtualKeyboard.keys.get(keyNote);

        if (keyElement) {
          // Add MIDI-specific correct feedback with velocity-based intensity
          keyElement.classList.add('correct', 'correct-midi');

          // Velocity-based visual intensity (Requirements 9.11)
          const glowIntensity = Math.max(0.6, velocity);
          const glowSize = 10 + (velocity * 8); // 10-18px glow based on velocity
          const scaleIntensity = 1.05 + (velocity * 0.15); // 1.05-1.2 scale based on velocity

          keyElement.style.boxShadow = `0 0 ${glowSize}px rgba(111, 66, 193, ${glowIntensity})`;

          // Enhanced animation duration based on velocity
          const animationDuration = 400 + (velocity * 200); // 400-600ms based on velocity

          setTimeout(() => {
            keyElement.classList.remove('correct', 'correct-midi');
            keyElement.style.boxShadow = '';
            keyElement.style.transform = '';
          }, animationDuration);

          console.log(`✅ [MIDI-FEEDBACK] Correct MIDI key feedback: ${keyNote} (velocity: ${velocity.toFixed(3)})`);
        }
      }

      /**
       * Show enhanced MIDI-specific incorrect feedback with velocity-based intensity
       * @param {string} keyNote - Note name that was incorrectly pressed
       * @param {number} velocity - MIDI velocity (0-1 range)
       */
      showMIDIIncorrectFeedback(keyNote, velocity = 0.8) {
        const keyElement = this.virtualKeyboard.keys.get(keyNote);

        if (keyElement) {
          // Add MIDI-specific incorrect feedback with velocity-based intensity
          keyElement.classList.add('incorrect', 'incorrect-midi');

          // Velocity-based visual intensity for incorrect feedback
          const glowIntensity = Math.max(0.5, velocity * 0.8);
          const glowSize = 8 + (velocity * 4); // 8-12px glow based on velocity

          keyElement.style.boxShadow = `0 0 ${glowSize}px rgba(232, 62, 140, ${glowIntensity})`;

          setTimeout(() => {
            keyElement.classList.remove('incorrect', 'incorrect-midi');
            keyElement.style.boxShadow = '';
          }, 400);

          console.log(`❌ [MIDI-FEEDBACK] Incorrect MIDI key feedback: ${keyNote} (velocity: ${velocity.toFixed(3)})`);
        }
      }

      /**
       * Show enhanced negative visual feedback for incorrect key press
       * @param {string} keyNote - Note name that was incorrectly pressed
       * @param {string} inputSource - Source of input ('virtual' or 'midi')
       */
      showIncorrectFeedback(keyNote, inputSource = 'virtual') {
        // Use the enhanced keyboard feedback system for incorrect keys
        this.showKeyboardFeedback(keyNote, inputSource, false);
      }

      /**
       * Show timing feedback message to user based on evaluation result
       * @param {string} timing - Timing result ('correct', 'too_early', 'too_late', 'incorrect')
       * @param {string} keyNote - The pressed key note
       * @param {string} expectedNote - The expected note (for incorrect presses)
       */
      showTimingFeedbackMessage(timing, keyNote, expectedNote = null) {
        let message = '';
        let messageClass = '';

        switch (timing) {
          case 'correct':
            message = `Perfect timing! ${keyNote}`;
            messageClass = 'timing-correct';
            break;
          case 'too_early':
            message = `Too early! Wait for ${keyNote} to reach the line`;
            messageClass = 'timing-early';
            break;
          case 'too_late':
            message = `Too late! ${keyNote} has already passed`;
            messageClass = 'timing-late';
            break;
          case 'incorrect':
            message = expectedNote ?
              `Wrong note! Pressed ${keyNote}, expected ${expectedNote}` :
              `Wrong note! Pressed ${keyNote}`;
            messageClass = 'timing-incorrect';
            break;
          default:
            message = `Timing: ${timing}`;
            messageClass = 'timing-default';
        }

        // Display the message (for now, just log it - can be enhanced with UI display)
        console.log(`🎵 Timing Feedback: ${message}`);

        // TODO: Add visual message display in future enhancement
        this.displayTimingMessage(message, messageClass);
      }

      /**
       * Show timing-based visual feedback for early/late key presses
       * @param {string} keyNote - The pressed key note
       * @param {string} inputSource - Source of input ('virtual' or 'midi')
       * @param {string} timing - Timing result ('too_early', 'too_late')
       */
      showTimingBasedFeedback(keyNote, inputSource, timing) {
        const keyElement = this.virtualKeyboard.keys.get(keyNote);

        if (keyElement) {
          // Add timing-specific visual feedback
          let feedbackClass = '';
          let glowColor = '';

          switch (timing) {
            case 'too_early':
              feedbackClass = 'timing-early';
              glowColor = 'rgba(255, 193, 7, 0.8)'; // Yellow for early
              break;
            case 'too_late':
              feedbackClass = 'timing-late';
              glowColor = 'rgba(255, 87, 34, 0.8)'; // Orange for late
              break;
            default:
              feedbackClass = 'timing-neutral';
              glowColor = 'rgba(108, 117, 125, 0.8)'; // Gray for neutral
          }

          keyElement.classList.add(feedbackClass);
          keyElement.style.boxShadow = `0 0 12px ${glowColor}`;

          // Remove feedback after delay
          setTimeout(() => {
            keyElement.classList.remove(feedbackClass);
            keyElement.style.boxShadow = '';
          }, 600);

          console.log(`⏱️ Timing feedback: ${keyNote} was ${timing} (${inputSource} input)`);
        }
      }

      /**
       * Display timing message in the UI (placeholder for future UI enhancement)
       * @param {string} message - The message to display
       * @param {string} messageClass - CSS class for styling
       */
      displayTimingMessage(message, messageClass) {
        // For now, this is a placeholder - could be enhanced with actual UI display
        // such as a temporary message overlay or status bar
        console.log(`📝 UI Message: ${message} (${messageClass})`);
      }

      /**
       * Update enhanced MIDI learning statistics with velocity and device tracking
       * @param {string} keyNote - The key that was pressed
       * @param {boolean} isCorrect - Whether the key press was correct
       * @param {Object} midiData - MIDI-specific data (velocity, device, etc.)
       */
      updateMIDILearningStats(keyNote, isCorrect, midiData = {}) {
        const {velocity, rawVelocity, deviceName, timestamp} = midiData;

        // Initialize enhanced MIDI learning stats if not present
        if (!this.learningStats) {
          this.learningStats = {
            correctMatches: 0,
            incorrectAttempts: 0,
            totalAttempts: 0,
            currentStreak: 0,
            bestStreak: 0,
            accuracyRate: 0,
            lastPlayedKey: null,
            isLearningMode: false,
            // Enhanced MIDI-specific statistics
            midiAttempts: 0,
            midiCorrect: 0,
            virtualAttempts: 0,
            virtualCorrect: 0,
            inputSourceBreakdown: {
              midi: {
                attempts: 0,
                correct: 0,
                accuracy: 0,
                averageVelocity: 0,
                velocitySum: 0,
                deviceBreakdown: {},
                lastActivity: null
              },
              virtual: {attempts: 0, correct: 0, accuracy: 0}
            }
          };
        }

        // Ensure enhanced MIDI properties exist
        if (!this.learningStats.inputSourceBreakdown.midi.averageVelocity) {
          this.learningStats.inputSourceBreakdown.midi.averageVelocity = 0;
          this.learningStats.inputSourceBreakdown.midi.velocitySum = 0;
          this.learningStats.inputSourceBreakdown.midi.deviceBreakdown = {};
          this.learningStats.inputSourceBreakdown.midi.lastActivity = null;
        }

        // Update general statistics
        this.learningStats.totalAttempts++;
        this.learningStats.lastPlayedKey = keyNote;
        this.learningStats.midiAttempts++;
        this.learningStats.inputSourceBreakdown.midi.attempts++;
        this.learningStats.inputSourceBreakdown.midi.lastActivity = timestamp || Date.now();

        // Track velocity data (Requirements 9.11)
        if (velocity !== undefined) {
          this.learningStats.inputSourceBreakdown.midi.velocitySum += velocity;
          this.learningStats.inputSourceBreakdown.midi.averageVelocity =
            this.learningStats.inputSourceBreakdown.midi.velocitySum /
            this.learningStats.inputSourceBreakdown.midi.attempts;
        }

        // Track device-specific statistics
        if (deviceName) {
          if (!this.learningStats.inputSourceBreakdown.midi.deviceBreakdown[deviceName]) {
            this.learningStats.inputSourceBreakdown.midi.deviceBreakdown[deviceName] = {
              attempts: 0,
              correct: 0,
              accuracy: 0,
              averageVelocity: 0,
              velocitySum: 0
            };
          }

          const deviceStats = this.learningStats.inputSourceBreakdown.midi.deviceBreakdown[deviceName];
          deviceStats.attempts++;

          if (velocity !== undefined) {
            deviceStats.velocitySum += velocity;
            deviceStats.averageVelocity = deviceStats.velocitySum / deviceStats.attempts;
          }
        }

        if (isCorrect) {
          this.learningStats.correctMatches++;
          this.learningStats.midiCorrect++;
          this.learningStats.inputSourceBreakdown.midi.correct++;
          this.learningStats.currentStreak++;

          // Update device-specific correct count
          if (deviceName && this.learningStats.inputSourceBreakdown.midi.deviceBreakdown[deviceName]) {
            this.learningStats.inputSourceBreakdown.midi.deviceBreakdown[deviceName].correct++;
          }

          // Update best streak if current streak is better
          if (this.learningStats.currentStreak > this.learningStats.bestStreak) {
            this.learningStats.bestStreak = this.learningStats.currentStreak;
          }
        } else {
          this.learningStats.incorrectAttempts++;
          this.learningStats.currentStreak = 0; // Reset streak on incorrect attempt
        }

        // Calculate accuracy rates
        this.learningStats.accuracyRate = this.learningStats.totalAttempts > 0
          ? (this.learningStats.correctMatches / this.learningStats.totalAttempts) * 100
          : 0;

        // Calculate MIDI-specific accuracy
        if (this.learningStats.inputSourceBreakdown.midi.attempts > 0) {
          this.learningStats.inputSourceBreakdown.midi.accuracy =
            (this.learningStats.inputSourceBreakdown.midi.correct /
              this.learningStats.inputSourceBreakdown.midi.attempts) * 100;
        }

        // Calculate device-specific accuracy
        if (deviceName && this.learningStats.inputSourceBreakdown.midi.deviceBreakdown[deviceName]) {
          const deviceStats = this.learningStats.inputSourceBreakdown.midi.deviceBreakdown[deviceName];
          deviceStats.accuracy = deviceStats.attempts > 0
            ? (deviceStats.correct / deviceStats.attempts) * 100
            : 0;
        }

        console.log(`[MIDI-STATS] Learning stats updated: ${this.learningStats.correctMatches}/${this.learningStats.totalAttempts} (${this.learningStats.accuracyRate.toFixed(1)}% accuracy) - MIDI input (velocity: ${velocity?.toFixed(3) || 'N/A'}, device: ${deviceName || 'Unknown'})`);
      }

      /**
       * Update learning statistics based on user interaction (supports both virtual and MIDI input)
       * @param {string} keyNote - The key that was pressed
       * @param {boolean} isCorrect - Whether the key press was correct
       * @param {string} inputSource - Source of input ('virtual' or 'midi')
       */
      updateLearningStats(keyNote, isCorrect, inputSource = 'virtual', timing = null) {
        // Initialize learning stats if not present
        if (!this.learningStats) {
          this.learningStats = {
            correctMatches: 0,
            incorrectAttempts: 0,
            totalAttempts: 0,
            currentStreak: 0,
            bestStreak: 0,
            accuracyRate: 0,
            lastPlayedKey: null,
            isLearningMode: false,
            // MIDI-specific statistics
            midiAttempts: 0,
            midiCorrect: 0,
            virtualAttempts: 0,
            virtualCorrect: 0,
            inputSourceBreakdown: {
              midi: {attempts: 0, correct: 0, accuracy: 0},
              virtual: {attempts: 0, correct: 0, accuracy: 0}
            },
            // Timing-specific statistics
            timingStats: {
              correct: 0,
              tooEarly: 0,
              tooLate: 0,
              incorrect: 0,
              total: 0
            }
          };
        }

        // Ensure MIDI-specific properties exist for backward compatibility
        if (!this.learningStats.hasOwnProperty('midiAttempts')) {
          this.learningStats.midiAttempts = 0;
        }
        if (!this.learningStats.hasOwnProperty('midiCorrect')) {
          this.learningStats.midiCorrect = 0;
        }
        if (!this.learningStats.hasOwnProperty('virtualAttempts')) {
          this.learningStats.virtualAttempts = 0;
        }
        if (!this.learningStats.hasOwnProperty('virtualCorrect')) {
          this.learningStats.virtualCorrect = 0;
        }
        if (!this.learningStats.hasOwnProperty('inputSourceBreakdown')) {
          this.learningStats.inputSourceBreakdown = {
            midi: {attempts: 0, correct: 0, accuracy: 0},
            virtual: {attempts: 0, correct: 0, accuracy: 0}
          };
        }

        // Update attempt counters
        this.learningStats.totalAttempts++;
        this.learningStats.lastPlayedKey = keyNote;

        // Initialize timing stats if not present (backward compatibility)
        if (!this.learningStats.timingStats) {
          this.learningStats.timingStats = {
            correct: 0,
            tooEarly: 0,
            tooLate: 0,
            incorrect: 0,
            total: 0
          };
        }

        // Update timing statistics
        if (timing) {
          this.learningStats.timingStats.total++;
          switch (timing) {
            case 'correct':
              this.learningStats.timingStats.correct++;
              break;
            case 'too_early':
              this.learningStats.timingStats.tooEarly++;
              break;
            case 'too_late':
              this.learningStats.timingStats.tooLate++;
              break;
            case 'incorrect':
              this.learningStats.timingStats.incorrect++;
              break;
          }
        }

        // Track input source statistics (with safety checks)
        if (inputSource === 'midi') {
          this.learningStats.midiAttempts++;
          if (this.learningStats.inputSourceBreakdown && this.learningStats.inputSourceBreakdown.midi) {
            this.learningStats.inputSourceBreakdown.midi.attempts++;
            if (isCorrect) {
              this.learningStats.midiCorrect++;
              this.learningStats.inputSourceBreakdown.midi.correct++;
            }
          }
        } else {
          this.learningStats.virtualAttempts++;
          if (this.learningStats.inputSourceBreakdown && this.learningStats.inputSourceBreakdown.virtual) {
            this.learningStats.inputSourceBreakdown.virtual.attempts++;
            if (isCorrect) {
              this.learningStats.virtualCorrect++;
              this.learningStats.inputSourceBreakdown.virtual.correct++;
            }
          }
        }

        if (isCorrect) {
          this.learningStats.correctMatches++;
          this.learningStats.currentStreak++;

          // Update best streak if current streak is better
          if (this.learningStats.currentStreak > this.learningStats.bestStreak) {
            this.learningStats.bestStreak = this.learningStats.currentStreak;
          }
        } else {
          this.learningStats.incorrectAttempts++;
          this.learningStats.currentStreak = 0; // Reset streak on incorrect attempt
        }

        // Calculate accuracy rates
        this.learningStats.accuracyRate = this.learningStats.totalAttempts > 0
          ? (this.learningStats.correctMatches / this.learningStats.totalAttempts) * 100
          : 0;

        // Calculate input source specific accuracy rates (with safety checks)
        if (this.learningStats.inputSourceBreakdown &&
          this.learningStats.inputSourceBreakdown.midi &&
          this.learningStats.inputSourceBreakdown.midi.attempts > 0) {
          this.learningStats.inputSourceBreakdown.midi.accuracy =
            (this.learningStats.inputSourceBreakdown.midi.correct / this.learningStats.inputSourceBreakdown.midi.attempts) * 100;
        }

        if (this.learningStats.inputSourceBreakdown &&
          this.learningStats.inputSourceBreakdown.virtual &&
          this.learningStats.inputSourceBreakdown.virtual.attempts > 0) {
          this.learningStats.inputSourceBreakdown.virtual.accuracy =
            (this.learningStats.inputSourceBreakdown.virtual.correct / this.learningStats.inputSourceBreakdown.virtual.attempts) * 100;
        }

        console.log(`Learning stats updated: ${this.learningStats.correctMatches}/${this.learningStats.totalAttempts} (${this.learningStats.accuracyRate.toFixed(1)}% accuracy) - ${inputSource} input`);
      }

      /**
       * Get current learning statistics
       * @returns {Object} Current learning statistics
       */
      getLearningStats() {
        if (!this.learningStats) {
          return {
            correctMatches: 0,
            incorrectAttempts: 0,
            totalAttempts: 0,
            currentStreak: 0,
            bestStreak: 0,
            accuracyRate: 0,
            lastPlayedKey: null,
            isLearningMode: false,
            // MIDI-specific statistics
            midiAttempts: 0,
            midiCorrect: 0,
            virtualAttempts: 0,
            virtualCorrect: 0,
            inputSourceBreakdown: {
              midi: {attempts: 0, correct: 0, accuracy: 0},
              virtual: {attempts: 0, correct: 0, accuracy: 0}
            }
          };
        }

        // Ensure backward compatibility for existing stats
        const stats = {...this.learningStats};
        if (!stats.hasOwnProperty('midiAttempts')) {
          stats.midiAttempts = 0;
        }
        if (!stats.hasOwnProperty('midiCorrect')) {
          stats.midiCorrect = 0;
        }
        if (!stats.hasOwnProperty('virtualAttempts')) {
          stats.virtualAttempts = 0;
        }
        if (!stats.hasOwnProperty('virtualCorrect')) {
          stats.virtualCorrect = 0;
        }
        if (!stats.hasOwnProperty('inputSourceBreakdown')) {
          stats.inputSourceBreakdown = {
            midi: {attempts: 0, correct: 0, accuracy: 0},
            virtual: {attempts: 0, correct: 0, accuracy: 0}
          };
        }

        return stats;
      }

      /**
       * Reset learning statistics
       */
      resetLearningStats() {
        this.learningStats = {
          correctMatches: 0,
          incorrectAttempts: 0,
          totalAttempts: 0,
          currentStreak: 0,
          bestStreak: 0,
          accuracyRate: 0,
          lastPlayedKey: null,
          isLearningMode: true,
          // MIDI-specific statistics
          midiAttempts: 0,
          midiCorrect: 0,
          virtualAttempts: 0,
          virtualCorrect: 0,
          inputSourceBreakdown: {
            midi: {attempts: 0, correct: 0, accuracy: 0},
            virtual: {attempts: 0, correct: 0, accuracy: 0}
          }
        };
        this.updateLearningProgressDisplay();

        console.log('Learning statistics reset');
      }

      /**
       * Update the learning progress display with current statistics
       * Enhanced to show MIDI-specific statistics when available
       */
      updateLearningProgressDisplay() {
        // Get current statistics
        const stats = this.getLearningStats();

        // Update general DOM elements if they exist
        const correctCountElement = document.getElementById('correctCount');
        const incorrectCountElement = document.getElementById('incorrectCount');
        const totalAttemptsElement = document.getElementById('totalAttempts');
        const accuracyElement = document.getElementById('accuracyRate');
        const currentStreakElement = document.getElementById('currentStreak');

        if (correctCountElement) correctCountElement.textContent = stats.correctMatches;
        if (incorrectCountElement) incorrectCountElement.textContent = stats.incorrectAttempts;
        if (totalAttemptsElement) totalAttemptsElement.textContent = stats.totalAttempts;
        if (accuracyElement) accuracyElement.textContent = `${stats.accuracyRate.toFixed(1)}%`;
        if (currentStreakElement) currentStreakElement.textContent = stats.currentStreak;

        // Update MIDI-specific statistics if available
        const learningProgressElement = document.getElementById('learningProgress');
        const midiAccuracyElement = document.getElementById('midiAccuracy');
        const virtualAccuracyElement = document.getElementById('virtualAccuracy');

        // Show MIDI stats if there have been MIDI attempts
        const hasMIDIActivity = stats.inputSourceBreakdown &&
          stats.inputSourceBreakdown.midi &&
          stats.inputSourceBreakdown.midi.attempts > 0;

        const hasVirtualActivity = stats.inputSourceBreakdown &&
          stats.inputSourceBreakdown.virtual &&
          stats.inputSourceBreakdown.virtual.attempts > 0;

        if (hasMIDIActivity || hasVirtualActivity) {
          // Show the MIDI stats section
          if (learningProgressElement) {
            learningProgressElement.classList.add('show-midi-stats');
          }

          // Update MIDI accuracy
          if (midiAccuracyElement && hasMIDIActivity) {
            const midiAccuracy = stats.inputSourceBreakdown.midi.accuracy || 0;
            midiAccuracyElement.textContent = `${midiAccuracy.toFixed(1)}%`;
          }

          // Update virtual accuracy
          if (virtualAccuracyElement && hasVirtualActivity) {
            const virtualAccuracy = stats.inputSourceBreakdown.virtual.accuracy || 0;
            virtualAccuracyElement.textContent = `${virtualAccuracy.toFixed(1)}%`;
          }

          console.log(`[ENHANCED-DISPLAY] Learning progress updated: ${stats.correctMatches}/${stats.totalAttempts} (${stats.accuracyRate.toFixed(1)}% overall) - MIDI: ${hasMIDIActivity ? stats.inputSourceBreakdown.midi.accuracy.toFixed(1) : 'N/A'}%, Virtual: ${hasVirtualActivity ? stats.inputSourceBreakdown.virtual.accuracy.toFixed(1) : 'N/A'}%`);
        } else {
          // Hide MIDI stats if no activity
          if (learningProgressElement) {
            learningProgressElement.classList.remove('show-midi-stats');
          }

          console.log(`Learning progress display updated: ${stats.correctMatches}/${stats.totalAttempts} (${stats.accuracyRate.toFixed(1)}% accuracy)`);
        }
      }

      /**
       * Show MIDI-specific statistics in the learning progress display
       * Requirements 10.7 - Track performance statistics separately for MIDI vs virtual input
       */
      showMIDIStatistics() {
        const learningProgressElement = document.getElementById('learningProgress');
        const midiStatsElement = document.getElementById('midiStats');
        const virtualStatsElement = document.getElementById('virtualStats');

        if (!learningProgressElement || !this.learningStats) return;

        // Show MIDI-specific statistics if MIDI input has been used
        if (this.learningStats.midiAttempts > 0) {
          learningProgressElement.classList.add('show-midi-stats');

          if (midiStatsElement) {
            const midiAccuracy = this.learningStats.inputSourceBreakdown?.midi?.accuracy || 0;
            const midiAccuracyElement = document.getElementById('midiAccuracy');
            if (midiAccuracyElement) {
              midiAccuracyElement.textContent = `${midiAccuracy.toFixed(1)}%`;
            }
            midiStatsElement.style.display = 'flex';
          }

          if (virtualStatsElement) {
            const virtualAccuracy = this.learningStats.inputSourceBreakdown?.virtual?.accuracy || 0;
            const virtualAccuracyElement = document.getElementById('virtualAccuracy');
            if (virtualAccuracyElement) {
              virtualAccuracyElement.textContent = `${virtualAccuracy.toFixed(1)}%`;
            }
            virtualStatsElement.style.display = 'flex';
          }

          console.log(`📊 [MIDI-STATS] MIDI Statistics displayed - MIDI: ${this.learningStats.inputSourceBreakdown?.midi?.accuracy?.toFixed(1) || 0}%, Virtual: ${this.learningStats.inputSourceBreakdown?.virtual?.accuracy?.toFixed(1) || 0}%`);
        }
      }

      /**
       * Ensure learning feedback consistency across input methods
       * This method maintains consistent behavior for both virtual and MIDI input
       */
      ensureLearningFeedbackConsistency() {
        // Verify that learning feedback works the same way for both input types
        if (!this.learningStats) {
          this.initializeLearningStats();
        }

        let expectedNote = this.getExpectedNote();
        // Ensure MIDI and virtual input use the same expected note
        if (expectedNote) {
          console.log(`[CONSISTENCY-CHECK] Expected note: ${expectedNote.pitch}, Playback active: ${this.isPlaybackActive}`);
        }

        // Verify that both input methods trigger the same feedback mechanisms
        const consistencyCheck = {
          expectedNoteSet: !!expectedNote,
          playbackActive: this.isPlaybackActive,
          learningStatsInitialized: !!this.learningStats,
          midiStatsTracking: !!(this.learningStats && this.learningStats.inputSourceBreakdown && this.learningStats.inputSourceBreakdown.midi),
          virtualStatsTracking: !!(this.learningStats && this.learningStats.inputSourceBreakdown && this.learningStats.inputSourceBreakdown.virtual)
        };

        console.log(`[CONSISTENCY-CHECK] Learning feedback consistency:`, consistencyCheck);
        return consistencyCheck;
      }

      /**
       * Initialize learning statistics with proper structure for both input methods
       */
      initializeLearningStats() {
        this.learningStats = {
          correctMatches: 0,
          incorrectAttempts: 0,
          totalAttempts: 0,
          currentStreak: 0,
          bestStreak: 0,
          accuracyRate: 0,
          lastPlayedKey: null,
          isLearningMode: false,
          // Enhanced statistics for both input methods
          midiAttempts: 0,
          midiCorrect: 0,
          virtualAttempts: 0,
          virtualCorrect: 0,
          inputSourceBreakdown: {
            midi: {
              attempts: 0,
              correct: 0,
              accuracy: 0,
              averageVelocity: 0,
              velocitySum: 0,
              deviceBreakdown: {},
              lastActivity: null
            },
            virtual: {attempts: 0, correct: 0, accuracy: 0}
          }
        };
        console.log(`[INIT] Learning statistics initialized with MIDI and virtual tracking`);
      }

      /**
       * Set playback active state for learning feedback
       * @param {boolean} active - True if playback is active
       */
      setPlaybackActive(active) {
        this.isPlaybackActive = active;

        // Update learning mode state
        if (this.learningStats) {
          this.learningStats.isLearningMode = active;
        }

        // Ensure consistency when playback state changes
        this.ensureLearningFeedbackConsistency();

        if (!active) {
        } else {
          console.log('🎓 Learning feedback system activated - positive feedback enabled');
        }
      }

      /**
       * Handle the start of pointer interaction (mouse down or touch start)
       * @param {MouseEvent|TouchEvent} event - The pointer event
       */
      handlePointerStart(event) {
        // Prevent default browser behaviors for smooth interaction
        event.preventDefault();

        // Pause automatic playback when manual interaction begins
        // This ensures manual control takes precedence over automatic playback
        if (this.isPlaying) {
          this.handlePause();
          console.log('Automatic playback paused for manual navigation');
        }

        // Get the pointer position with error handling
        let clientX;
        if (event.type === 'touchstart') {
          if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
          } else {
            console.warn('Touch start event without touches array');
            return;
          }
        } else {
          clientX = event.clientX;
        }

        // Initialize drag state
        this.isDragging = true;
        this.dragStartX = clientX;
        this.dragStartPosition = this.currentPosition;
        this.lastTouchX = clientX;

        // Add visual feedback for interaction
        const staffContainer = document.querySelector('.staff');
        if (staffContainer) {
          staffContainer.style.cursor = 'grabbing';
        }

        console.log('Pointer interaction started at:', clientX, '- Manual navigation active');
      }

      /**
       * Handle pointer movement during drag (mouse move or touch move)
       * @param {MouseEvent|TouchEvent} event - The pointer event
       */
      handlePointerMove(event) {
        if (!this.isDragging) return;

        // Prevent default browser behaviors for smooth interaction
        event.preventDefault();

        // Get the current pointer position with error handling
        let clientX;
        if (event.type === 'touchmove') {
          if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
          } else {
            console.warn('Touch event without touches array');
            return;
          }
        } else {
          clientX = event.clientX;
        }

        // Calculate drag distance and direction from pointer events
        const dragDistance = clientX - this.dragStartX;
        const dragDirection = dragDistance > 0 ? 'right' : 'left';
        const dragVelocity = clientX - this.lastTouchX; // For momentum calculation

        // Convert drag movements to staff position changes
        // Apply sensitivity factor for more responsive control
        const dragSensitivity = 1.2; // Slightly amplify drag movements
        const adjustedDragDistance = dragDistance * dragSensitivity;

        // Update the current position based on drag distance
        // Negative drag distance moves staff left (forward in time)
        // Positive drag distance moves staff right (backward in time)
        const newPosition = this.dragStartPosition - adjustedDragDistance;

        // Apply boundary constraints
        const constrainedPosition = this.constrainPosition(newPosition);

        // Apply smooth CSS transforms for real-time staff movement
        this.currentPosition = constrainedPosition;
        this.updateStaffPositionSmooth(-this.currentPosition);

        // Store velocity and position data for momentum calculation
        this.dragVelocity = dragVelocity;
        this.lastTouchX = clientX;
        this.lastMoveTime = performance.now();

        // Optional: Update debug info during drag
        if (Math.abs(dragDistance) > 5) { // Only log significant movements
          console.debug(`Dragging ${dragDirection} - Distance: ${Math.round(dragDistance)}px, Position: ${Math.round(constrainedPosition)}px, Velocity: ${Math.round(dragVelocity)}px`);
        }
      }

      /**
       * Handle the end of pointer interaction (mouse up or touch end)
       * @param {MouseEvent|TouchEvent} event - The pointer event
       */
      handlePointerEnd(event) {
        if (!this.isDragging) return;

        // Calculate momentum based on final drag velocity
        const momentum = this.dragVelocity || 0;
        const momentumThreshold = 2; // Minimum velocity to trigger momentum


        // Reset drag state
        this.isDragging = false;

        // Remove visual feedback
        const staffContainer = document.querySelector('.staff');
        if (staffContainer) {
          staffContainer.style.cursor = 'grab';
        }

        // Add momentum and easing for natural feel
        if (Math.abs(momentum) > momentumThreshold) {
          this.applyMomentumEasing(momentum);
        } else {
          // No momentum, just ensure smooth final positioning
          this.finalizeStaffPosition();
        }

        console.debug('Pointer interaction ended at position:', this.currentPosition, 'with momentum:', momentum);
      }

      /**
       * Constrain staff position to valid boundaries
       * @param {number} position - The desired position
       * @returns {number} The constrained position
       */
      constrainPosition(position) {
        const minPosition = 0; // Beginning of song
        const maxPosition = this.getTotalSongWidth(); // End of song

        // Clamp position between min and max
        return Math.max(minPosition, Math.min(position, maxPosition));
      }

      /**
       * Update staff position with smooth CSS transforms for real-time movement
       * @param {number} xOffset - Horizontal offset in pixels (negative moves left)
       */
      updateStaffPositionSmooth(xOffset) {
        const notesContainerElement = document.querySelector('.notes-container');
        if (notesContainerElement) {
          // Use transform3d for hardware acceleration and smoother performance
          notesContainerElement.style.transform = `translate3d(${xOffset}px, 0, 0)`;

          // Temporarily remove transition during manual interaction for immediate response
          notesContainerElement.style.transition = 'none';
        }
      }

      /**
       * Apply momentum and easing after drag ends for natural feel
       * @param {number} velocity - The final drag velocity in pixels
       */
      applyMomentumEasing(velocity) {
        const momentumFactor = 0.3; // Reduce momentum strength for control
        const easingDuration = 400; // Duration of easing animation in ms
        const startTime = performance.now();
        const startPosition = this.currentPosition;


        // Calculate momentum distance with decay
        const momentumDistance = velocity * momentumFactor;
        const targetPosition = this.constrainPosition(startPosition - momentumDistance);


        // Animate with easing
        const animateMomentum = (timestamp) => {
          const elapsed = timestamp - startTime;
          const progress = Math.min(elapsed / easingDuration, 1);


          // Use easeOut cubic function for natural deceleration
          const easeOutCubic = 1 - Math.pow(1 - progress, 3);


          // Interpolate position
          const currentPos = startPosition + (targetPosition - startPosition) * easeOutCubic;
          this.currentPosition = currentPos;


          // Apply smooth positioning and update internal tracking during momentum
          this.updateStaffPositionSmooth(-this.currentPosition);


          // Continue animation until complete
          if (progress < 1) {
            requestAnimationFrame(animateMomentum);
          } else {
            // Finalize position when momentum animation completes
            this.finalizeStaffPosition();
          }
        };


        requestAnimationFrame(animateMomentum);
        console.log(`Applying momentum: velocity=${velocity.toFixed(1)}, distance=${momentumDistance.toFixed(1)}, target=${targetPosition.toFixed(1)}`);
      }

      /**
       * Finalize staff position and restore normal transition behavior
       */
      finalizeStaffPosition() {
        const notesContainerElement = document.querySelector('.notes-container');
        if (notesContainerElement) {
          // Restore transition for smooth playback animation
          notesContainerElement.style.transition = 'transform 0.1s linear';

          // Ensure final position is properly constrained
          this.currentPosition = this.constrainPosition(this.currentPosition);
          notesContainerElement.style.transform = `translate3d(${-this.currentPosition}px, 0, 0)`;
        }

        // Update internal position tracking after finalization
        this.updateInternalPositionTracking();
      }

      /**
       * Update internal position tracking during manual movement
       * This ensures playback can resume from the manually set position
       * Updated to work correctly with different tempo settings
       */
      updateInternalPositionTracking() {
        // Calculate the equivalent time position based on current staff position
        // This uses the current tempo's playback speed for accurate timing
        const timePosition = this.currentPosition / this.playbackSpeed;

        // Update the paused time to reflect the new position
        // This allows resuming playback from the manually set position
        this.pausedTime = timePosition;

        // If we were previously playing and got paused by manual interaction,
        // ensure the app is in the correct paused state
        if (!this.isPlaying && this.currentPosition > 0) {
          this.isPaused = true;
        }

        // Update based on current position during manual navigation
        this.attachToNearestNote();

        // Update learning feedback detection during manual navigation
        this.detectPlaybackLineNoteIntersection();

        // Update progress bar during manual navigation
        this.updateProgressBar();

        // Only log significant position updates to avoid spam
        if (this.currentPosition % 50 < 5 || this.currentPosition < 5) {
          const currentTempoInfo = this.getCurrentTempoInfo();
          console.log(`Position tracking: ${this.currentPosition.toFixed(1)}px → ${timePosition.toFixed(1)}ms (tempo: ${currentTempoInfo.name}, paused: ${this.isPaused})`);
        }
      }

      /**
       * Update states based on current staff position during manual navigation
       * This ensures the correct note is highlighted when user will to play
       */
      attachToNearestNote() {
        if (!this.playbackLineElement) return;

        const playbackLineRect = this.playbackLineElement.getBoundingClientRect();

        // Find the note that should be highlighted based on current position
        let closestNoteIndex = null;
        let closestDistance = Infinity;
        let closestOffset = 0;

        // Check all notes to find the one closest to the playback line
        for (let i = 0; i < this.positionedNotes.length; i++) {
          const note = this.positionedNotes[i];

          // Skip rest notes
          if (note.pitch === 'rest') continue;

          const noteElement = document.getElementById(`note-${i}`);
          if (!noteElement) continue;

          const noteRect = noteElement.getBoundingClientRect();

          // Calculate distance from note's left edge to playback line left
          let offset = noteRect.left - playbackLineRect.left;
          const distance = Math.abs(offset);

          if (distance < closestDistance) {
            closestDistance = distance;
            closestNoteIndex = i;
            closestOffset = offset;
          }

          if (playbackLineRect.right <= noteRect.left) {
            break;
          }
        }
        console.log(`attach to nearest note(index ${closestNoteIndex}), offset: ${closestOffset}`);
        this.updateNextNodeToPlayIndex(closestNoteIndex);
        this.currentPosition += closestOffset;
        this.updateStaffPosition(-this.currentPosition);
      }

      attachToFirstNote() {
        this.attachToNearestNote();
      }

      renderNotes() {
        const notesContainer = document.querySelector('.notes-container');
        if (!notesContainer) {
          console.error('Notes container not found');
          return;
        }

        // Clear any existing notes
        notesContainer.innerHTML = '';

        // Create and position each note rectangle (skip rest notes)
        this.positionedNotes.forEach((note, index) => {
          // Skip rendering rest notes - they are silent and shouldn't be visible
          if (note.pitch === 'rest') {
            return;
          }

          const noteElement = document.createElement('div');
          noteElement.className = `note-rectangle pitch-${note.pitch}`;
          noteElement.id = `note-${index}`;

          // Set position and size
          noteElement.style.left = `${note.x}px`;
          noteElement.style.top = `${note.y}px`;
          noteElement.style.width = `${note.width}px`;
          noteElement.style.backgroundColor = `${note.color}`;

          // Add data attributes for debugging and future use
          noteElement.setAttribute('data-pitch', note.pitch);
          noteElement.setAttribute('data-duration', note.duration);
          noteElement.setAttribute('data-measure', note.measureIndex + 1);
          noteElement.setAttribute('data-fingering', note.fingering);

          // Add tooltip with note information
          noteElement.title = `${note.pitch} (${note.duration}) - Measure ${note.measureIndex + 1} - Finger ${note.fingering}`;

          // Add fingering number inside the note rectangle if fingering is available
          if (note.fingering !== null && note.fingering !== undefined) {
            const fingeringElement = document.createElement('span');
            fingeringElement.className = 'fingering-number';
            fingeringElement.textContent = note.fingering.toString();
            noteElement.appendChild(fingeringElement);
          }

          notesContainer.appendChild(noteElement);
        });

        const visibleNotes = this.positionedNotes.filter(note => note.pitch !== 'rest');
        console.log(`Rendered ${visibleNotes.length} note rectangles`);

        // Update the notes container width to accommodate all notes
        const maxX = Math.max(...this.positionedNotes.map(note => note.x + note.width));
        notesContainer.style.width = `${maxX + 100}px`; // Add some padding
      }

      renderMeasureBars() {
        const notesContainer = document.querySelector('.notes-container');
        if (!notesContainer) {
          console.error('Notes container not found for measure bars');
          return;
        }

        // Get measure bar positions from the positioning system
        const measurePositions = this.notePositioning.getMeasureBarPositions();

        // Create measure bars at each measure start position
        measurePositions.forEach((xPosition, measureIndex) => {
          const measureBar = document.createElement('div');
          measureBar.className = 'measure-bar';
          measureBar.id = `measure-bar-${measureIndex}`;

          // Position the measure bar
          measureBar.style.left = `${xPosition}px`;

          // Add data attribute for debugging
          measureBar.setAttribute('data-measure', measureIndex + 1);

          // Add tooltip
          measureBar.title = `Measure ${measureIndex + 1}`;

          notesContainer.appendChild(measureBar);
        });

        console.log(`Rendered ${measurePositions.length} measure bars`);
      }

      /**
       * Update debug info with current playback state
       */
      updateDebugPlaybackState() {
        const debugElement = document.getElementById('debug-info');
        if (!debugElement) return;

        // Find the playback state section and update it
        let currentHTML = debugElement.innerHTML;

        // Add or update playback state info
        const stateInfo = `<br><strong>Playback State:</strong> ${this.isPlaying ? '<span style="color: #27ae60;">Playing</span>' :
          this.isPaused ? '<span style="color: #f39c12;">Paused</span>' :
            '<span style="color: #e74c3c;">Stopped</span>'
          }<br>`;

        // Remove existing state info if present
        currentHTML = currentHTML.replace(/<br><strong>Playback State:.*?<br>/g, '');

        // Add new state info before the closing
        debugElement.innerHTML = currentHTML + stateInfo;
      }

      /**
       * Start the animation loop using requestAnimationFrame
       * Modified to use current tempo setting for playback speed
       */
      startPlaybackAnimation() {
        // Set playing state and initialize timing
        this.isPlaying = true;
        this.isPaused = false;
        this.startTime = performance.now() - this.currentPosition / this.playbackSpeed;

        // Enable learning feedback
        this.setPlaybackActive(true);

        const animate = (timestamp) => {
          if (!this.isPlaying) return;

          // Calculate elapsed time since start
          const elapsedTime = timestamp - this.startTime;

          // Calculate new position based on current tempo's playback speed
          // This ensures the animation loop uses the current tempo setting
          this.currentPosition = elapsedTime * this.playbackSpeed;

          // Update staff position with smooth movement
          this.updateStaffPosition(-this.currentPosition);

          // Update learning feedback detection
          this.detectPlaybackLineNoteIntersection();

          // Check and remove feedback when playback position is out of note bounds
          this.checkAndRemoveOutOfBoundsFeedback();

          // Update progress bar
          this.updateProgressBar();

          // Check if we've reached the end of the song
          const totalSongWidth = this.getTotalSongWidth();
          if (this.currentPosition >= totalSongWidth) {
            return;
          }

          // Continue animation
          this.animationId = requestAnimationFrame(animate);
        };

        this.animationId = requestAnimationFrame(animate);
        console.log('Staff animation started from piano key press');
      }

      /**
       * Pause the current playback animation
       */
      handlePause() {
        if (!this.isPlaying) {
          console.log('Playback is not currently active, nothing to pause');
          return;
        }

        console.log('Pausing playback animation at position:', this.currentPosition);

        // Stop the animation
        this.isPlaying = false;
        this.isPaused = true;

        // Cancel the animation frame
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }

        // Store the current playback time for resuming
        this.pausedTime = performance.now() - this.startTime;

        // Disable learning feedback when pausing
        this.setPlaybackActive(false);

        // At pause, this.currentPosition should be updated to have the realtime
        // value. Its value was updated in the startPlaybackAnimation frame.
        let notesContainer = document.querySelector('.notes-container');
        let playbackLine = document.querySelector('.playback-line');
        let notesContainerRect = notesContainer.getBoundingClientRect();
        let playbackLineRect = playbackLine.getBoundingClientRect();
        this.currentPosition = playbackLineRect.left - notesContainerRect.left;
        // when user changes the tempo, the animation paused and the playback line 
        // should attach to the nearest note.
        this.attachToNearestNote();
        console.log(`Playback paused at position: ${this.currentPosition}px, time: ${this.pausedTime}ms`);
      }

      /**
       * Resume playback from the paused position
       */
      handleResume() {
        if (this.isPlaying) {
          console.log('Playback is already active');
          return;
        }

        if (!this.isPaused) {
          console.log('No paused playback to resume, starting from current position');
        }

        console.log('Resuming playback from position:', this.currentPosition);

        // Resume the animation
        this.startPlaybackAnimation();
      }

      /**
       * Stop and reset playback to the beginning
       */
      handleStop() {
        console.log('Stopping and resetting playback');

        // Stop any current animation
        this.isPlaying = false;
        this.isPaused = false;

        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }

        // Reset timing variables
        this.startTime = null;
        this.pausedTime = 0;
        this.currentPosition = 0;

        // Reset learning feedback state
        this.nextNoteToPlayIndex = 0;
        this.lastTriggeredNoteIndex = null;
        this.setPlaybackActive(false);

        // Reset staff position to beginning
        this.updateStaffPosition(0);

        // Reset progress bar
        this.initializeProgressBar();

        console.log('Playback stopped and reset to beginning');
      }

      /**
       * Update the staff position using CSS transform
       * @param {number} xOffset - Horizontal offset in pixels (negative moves left)
       * @param {function} onDidUpdate - Callback function to be called when the transition ends
       * If update something depends on the finish of the staff move animation,
       * you can pass a callback function to be called when the transition ends.
       */
      updateStaffPosition(xOffset, onDidUpdate = null) {
        const notesContainerElement = document.querySelector('.notes-container');
        if (notesContainerElement) {
          
          if (onDidUpdate != null) {
            const handleTransitionEnd = (e) => {
                notesContainerElement.removeEventListener('transitionend', handleTransitionEnd);
                onDidUpdate();
            };
            // .notes-container dom element has a css transform transition
            notesContainerElement.addEventListener('transitionend', handleTransitionEnd);
          }

          // Use translate3d for hardware acceleration and consistency
          notesContainerElement.style.transform = `translate3d(${xOffset}px, 0, 0)`;
        }
      }

      /**
       * Update the simple progress bar based on current playback position
       */
      updateProgressBar() {
        const totalSongWidth = this.getTotalSongWidth();
        const progressPercentage = totalSongWidth > 0 ? (this.currentPosition / totalSongWidth) * 100 : 0;

        // Clamp percentage between 0 and 100
        const clampedPercentage = Math.max(0, Math.min(100, progressPercentage));

        // Use enhanced progress bar controller if available
        if (this.progressBarController && this.progressBarController.isReady()) {
          this.progressBarController.updateProgress(this.currentPosition, totalSongWidth);
        } else {
          // Fallback to direct update
          const progressFill = document.getElementById('progressFill');
          if (progressFill) {
            progressFill.style.width = `${clampedPercentage}%`;
          }
        }
      }

      /**
       * Initialize the simple progress bar with default values
       */
      initializeProgressBar() {
        // Set initial value
        const progressFill = document.getElementById('progressFill');
        if (progressFill) {
          progressFill.style.width = '0%';
        }

        // Enhance existing progress bar with click-to-jump functionality
        if (this.progressBarController) {
          const enhanced = this.progressBarController.enhanceExistingProgressBar();
          if (enhanced) {
            console.log('✅ Progress bar enhanced with click-to-jump functionality');
          } else {
            console.warn('⚠️ Failed to enhance progress bar');
          }
        }

        console.log('Simple progress bar initialized');
      }

      /**
       * Update learning feedback trigger using improved intersection detection
       * Uses getBoundingClientRect() for accurate DOM element intersection detection
       * Optimized for O(1) performance by tracking next-to-be-played note
       */
      detectPlaybackLineNoteIntersection() {
        if (!this.virtualKeyboard || !this.playbackLineElement) return;

        let nextNoteIndex = this.nextNoteToPlayIndex;
        // If we've reached the end of the song, check if we should maintain the last note
        if (nextNoteIndex >= this.positionedNotes.length) {
          console.debug('SONG play finished!!!');
          return;
        }

        const nextNote = this.positionedNotes[nextNoteIndex];
        const noteElement = document.getElementById(`note-${nextNoteIndex}`);

        if (!noteElement) {
          console.warn(`Note element not found for index ${nextNoteIndex}`);
          return;
        }

        // Get actual DOM positions using getBoundingClientRect() for accurate intersection detection
        const noteRect = noteElement.getBoundingClientRect();
        const playbackLineRect = this.playbackLineElement.getBoundingClientRect();

        // Improved intersection algorithm: check if the left edge of note rectangle 
        // intersects with the playback line
        // Check for intersection: note's left edge in the playback line
        const intersection = noteRect.left >= playbackLineRect.left && noteRect.left <= playbackLineRect.right;

        if (intersection) {
          // Only trigger if this is a new note (prevent multiple triggers for same note)
          if (this.lastTriggeredNoteIndex !== nextNoteIndex) {
            this.lastTriggeredNoteIndex = nextNoteIndex;

            console.log(`🎯 Learning feedback triggered: note ${nextNote.pitch} (index ${nextNoteIndex}) intersects playback line`);
            console.log(`   Current highlighted note index set to: ${nextNoteIndex}`);
          }
        } else {
          console.debug(`${nextNote.pitch}(index ${nextNoteIndex}) not intersected`);
          if (this.isPlaybackActive && noteRect.right <= playbackLineRect.left) {
            this.updateNextNodeToPlayIndex();
            console.log(`next note to play index updated to ${this.nextNoteToPlayIndex}`);
          }
        }
      }

      updateNextNodeToPlayIndex(index = null) {
        if (index == null) {
          this.nextNoteToPlayIndex += 1;
        } else {
          this.nextNoteToPlayIndex = index;
        }

        // Find the next note to be played (skip rest notes) - O(1) amortized performance
        while (this.nextNoteToPlayIndex < this.positionedNotes.length &&
          this.positionedNotes[this.nextNoteToPlayIndex].pitch === 'rest') {
          this.nextNoteToPlayIndex++;
        }
        console.log(`update nextNoteToPlayIndex to ${this.nextNoteToPlayIndex}`);
      }

      /**
       * Clear all keyboard key highlighting and staff note highlighting
       */
      clearAllKeyboardHighlighting() {
        if (!this.virtualKeyboard) return;

        // Clear active state from all keys
        const allNotes = ['A3', 'B3', 'C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5'];
        allNotes.forEach(note => {
          this.virtualKeyboard.setKeyState(note, 'normal');
        });

        // Also clear any staff note highlighting
        this.clearAllStaffNoteHighlighting();
      }

      /**
       * Clear all staff note highlighting
       */
      clearAllStaffNoteHighlighting() {
        // Remove current highlighting from all notes
        const allNoteElements = document.querySelectorAll('.note-rectangle.current');
        allNoteElements.forEach(noteElement => {
          noteElement.classList.remove('current');
        });

        // Remove any correct feedback highlighting
        const correctNoteElements = document.querySelectorAll('.note-rectangle.correct-note');
        correctNoteElements.forEach(noteElement => {
          noteElement.classList.remove('correct-note');
        });
      }

      /**
       * Calculate the total width of the song for determining when playback ends
       * @returns {number} Total width in pixels
       */
      getTotalSongWidth() {
        if (this.positionedNotes.length === 0) return 0;

        // Find the rightmost note position
        const maxX = Math.max(...this.positionedNotes.map(note => note.x + note.width));
        return maxX + 200; // Add some padding for smooth ending
      }

      // Method to get positioning data for external use
      getPositionedNotes() {
        return this.positionedNotes;
      }

      // Method to get positioning system for external use
      getNotePositioning() {
        return this.notePositioning;
      }

      /**
       * Validate tempo control integration with playback system
       * @returns {Object} Validation results
       */
      validateTempoIntegration() {
        const validation = {
          isValid: true,
          issues: [],
          details: {}
        };

        // Check if tempo control is properly integrated
        try {
          // Verify current tempo is valid
          const currentTempoInfo = this.getCurrentTempoInfo();
          if (!currentTempoInfo) {
            validation.isValid = false;
            validation.issues.push('Current tempo info not found');
          } else {
            validation.details.currentTempo = currentTempoInfo.name;
            validation.details.currentBPM = currentTempoInfo.bpm;
          }

          // Verify playback speed calculation
          const calculatedSpeed = this.calculatePlaybackSpeed(this.currentTempo);
          if (Math.abs(calculatedSpeed - this.playbackSpeed) > 0.0001) {
            validation.isValid = false;
            validation.issues.push('Playback speed not synchronized with tempo');
          } else {
            validation.details.playbackSpeed = this.playbackSpeed;
          }

          // Verify animation loop uses current tempo
          validation.details.animationIntegrated = this.isPlaying ? 'Active' : 'Ready';

          // Verify manual navigation compatibility
          validation.details.manualNavigationCompatible = !this.isDragging || 'Compatible during interaction';

          console.log('Tempo integration validation:', validation);
          return validation;

        } catch (error) {
          validation.isValid = false;
          validation.issues.push(`Validation error: ${error.message}`);
          return validation;
        }
      }
    }

    /**
     * TimingEvaluationSystem class for precise timing detection
     * Evaluates user key presses for timing accuracy and provides visual feedback
     */
    class TimingEvaluationSystem {
      /**
       * @param {PianoTutorApp} staffRenderer - The staff renderer instance (PianoTutorApp)
       * @param {PianoTutorApp} playbackController - The playback controller instance (PianoTutorApp)
       */
      constructor(staffRenderer, playbackController) {
        this.staffRenderer = staffRenderer;
        this.playbackController = playbackController;
        this.staffContainer = document.querySelector('.staff-container');
        this.playbackLineElement = document.querySelector('.playback-line');

        // Timing tolerance in pixels for "correct" timing detection
        // This will be adjusted based on tempo for consistent timing across all speeds
        this.baseTolerance = 10;
        this.timingTolerance = this.baseTolerance;

        // Cache for performance optimization
        this.noteElementsCache = new Map();
        this.lastCacheUpdate = 0;
        this.cacheValidityDuration = 1000; // 1 second

        // Incorrect note elements for cleanup
        this.incorrectNoteElements = new Set();

        // Current tempo tracking for tolerance adjustment
        this.currentTempo = DEFAULT_TEMPO;

        // Performance monitoring for optimization
        this.performanceMetrics = {
          evaluationCount: 0,
          totalEvaluationTime: 0,
          averageEvaluationTime: 0,
          maxEvaluationTime: 0,
          cacheHitRate: 0,
          cacheHits: 0,
          cacheMisses: 0
        };

        console.log('TimingEvaluationSystem initialized');
      }

      /**
       * Evaluate the timing of a key press relative to the playback line
       * @param {string} keyNote - The note that was pressed (e.g., "C4", "D4")
       * @param {number} playbackLinePosition - Current position of playback line in pixels
       * @param {Array} noteElements - Array of note elements on the staff
       * @returns {Object} Evaluation result with timing and correctness information
       */
      evaluateKeyPress(keyNote, playbackLinePosition, noteElements) {
        // Performance monitoring start
        const startTime = performance.now();

        // Input validation and boundary checking
        if (!keyNote || typeof keyNote !== 'string') {
          console.warn('TimingEvaluationSystem: Invalid key note provided');
          return this.createErrorResult('Invalid key note');
        }

        if (typeof playbackLinePosition !== 'number' || isNaN(playbackLinePosition)) {
          console.warn('TimingEvaluationSystem: Invalid playback line position');
          return this.createErrorResult('Invalid playback position');
        }

        if (!noteElements || !Array.isArray(noteElements)) {
          console.warn('TimingEvaluationSystem: Invalid note elements array');
          return this.createErrorResult('Invalid note elements');
        }

        try {
          // Get expected note at current playback position
          const expectedNote = this.getExpectedNoteAtPosition(playbackLinePosition, noteElements);

          if (!expectedNote) {
            // Fallback timing detection - check if any note is reasonably close
            const fallbackResult = this.performFallbackDetection(keyNote, playbackLinePosition, noteElements);
            if (fallbackResult) {
              return fallbackResult;
            }

            return {
              timing: 'no_note',
              isCorrect: false,
              expectedNote: null,
              message: 'No note expected at current position'
            };
          }

          // Check if the pressed key matches the expected note
          const isCorrectNote = this.normalizeNoteName(keyNote) === this.normalizeNoteName(expectedNote.pitch);

          if (!isCorrectNote) {
            return {
              timing: 'incorrect',
              isCorrect: false,
              expectedNote: expectedNote.pitch,
              pressedNote: keyNote,
              message: `Incorrect note: pressed ${keyNote}, expected ${expectedNote.pitch}`
            };
          }

          // Evaluate timing for correct note with error handling
          const timingResult = this.determineTimingResult(expectedNote.element, playbackLinePosition, keyNote);

          const result = {
            timing: timingResult.timing,
            isCorrect: timingResult.timing === 'correct',
            expectedNote: expectedNote.pitch,
            pressedNote: keyNote,
            message: timingResult.message,
            noteElement: expectedNote.element
          };

          // Performance monitoring completion
          this.updatePerformanceMetrics(startTime);

          return result;

        } catch (error) {
          console.error('TimingEvaluationSystem: Error in evaluateKeyPress:', error);
          // Still update performance metrics for error cases
          this.updatePerformanceMetrics(startTime);
          return this.createErrorResult('Error evaluating key press timing');
        }
      }

      /**
       * Determine timing result based on note head position relative to playback line
       * @param {HTMLElement} noteElement - The note element to evaluate
       * @param {number} playbackLinePosition - Current playback line position
       * @param {string} keyNote - The pressed key note
       * @returns {Object} Timing evaluation result
       */
      determineTimingResult(noteElement, playbackLinePosition, keyNote) {
        if (!noteElement || !this.playbackLineElement) {
          return {
            timing: 'error',
            message: 'Missing note element or playback line'
          };
        }

        try {
          const noteHeadPosition = this.calculateNoteHeadPosition(noteElement);
          const noteBounds = this.calculateNoteBounds(noteElement);
          const playbackLineBounds = this.getPlaybackLineBounds();

          // Check if note head is within timing tolerance of playback line
          const isNoteHeadInBounds = this.checkNoteHeadInBounds(
            noteHeadPosition,
            playbackLineBounds,
            this.timingTolerance
          );

          // Check if playback line is within the note's rectangle bounds
          const isPlaybackLineInNoteBounds = this.checkPlaybackLineInNoteBounds(
            noteBounds,
            playbackLineBounds
          );

          // Determine timing based on Requirements 12.1, 12.2, 12.3
          if (isNoteHeadInBounds) {
            // Requirement 12.1: Note head is within bounds of playback line = correct
            return {
              timing: 'correct',
              message: `Perfect timing for ${keyNote}`
            };
          } else if (isPlaybackLineInNoteBounds) {
            // Requirement 12.2: Playback line is within note bounds but note head is not = too late
            return {
              timing: 'too_late',
              message: `Too late for ${keyNote} - note has already started`
            };
          } else {
            // Requirement 12.3: Note head has not yet reached playback line = too early
            return {
              timing: 'too_early',
              message: `Too early for ${keyNote} - note hasn't reached the line yet`
            };
          }

        } catch (error) {
          console.error('Error in determineTimingResult:', error);
          return {
            timing: 'error',
            message: 'Error calculating timing result'
          };
        }
      }

      /**
       * Calculate the position of a note's head (left edge) relative to the staff container
       * @param {HTMLElement} noteElement - The note element
       * @returns {number} Note head position in pixels
       */
      calculateNoteHeadPosition(noteElement) {
        if (!noteElement || !this.staffContainer) {
          throw new Error('Missing note element or staff container');
        }

        const noteRect = noteElement.getBoundingClientRect();
        const staffRect = this.staffContainer.getBoundingClientRect();

        // Note head position is the left edge of the note relative to staff container
        return noteRect.left - staffRect.left;
      }

      /**
       * Calculate the bounds (left and right edges) of a note rectangle
       * @param {HTMLElement} noteElement - The note element
       * @returns {Object} Note bounds with left and right positions
       */
      calculateNoteBounds(noteElement) {
        if (!noteElement || !this.staffContainer) {
          throw new Error('Missing note element or staff container');
        }

        const noteRect = noteElement.getBoundingClientRect();
        const staffRect = this.staffContainer.getBoundingClientRect();

        return {
          left: noteRect.left - staffRect.left,
          right: noteRect.right - staffRect.left,
          width: noteRect.width
        };
      }

      /**
       * Get the bounds of the playback line
       * @returns {Object} Playback line bounds
       */
      getPlaybackLineBounds() {
        if (!this.playbackLineElement || !this.staffContainer) {
          throw new Error('Missing playback line or staff container');
        }

        const playbackRect = this.playbackLineElement.getBoundingClientRect();
        const staffRect = this.staffContainer.getBoundingClientRect();

        return {
          left: playbackRect.left - staffRect.left,
          right: playbackRect.right - staffRect.left,
          center: (playbackRect.left + playbackRect.right) / 2 - staffRect.left,
          width: playbackRect.width
        };
      }

      /**
       * Check if note head is within acceptable timing bounds of playback line
       * @param {number} noteHeadPosition - Position of note head
       * @param {Object} playbackLineBounds - Playback line bounds
       * @param {number} tolerance - Timing tolerance in pixels
       * @returns {boolean} True if note head is within bounds
       */
      checkNoteHeadInBounds(noteHeadPosition, playbackLineBounds, tolerance) {
        const playbackCenter = playbackLineBounds.center;
        const distance = Math.abs(noteHeadPosition - playbackCenter);

        return distance <= tolerance;
      }

      /**
       * Check if playback line is within the note's rectangle bounds
       * @param {Object} noteBounds - Note rectangle bounds
       * @param {Object} playbackLineBounds - Playback line bounds
       * @returns {boolean} True if playback line intersects with note bounds
       */
      checkPlaybackLineInNoteBounds(noteBounds, playbackLineBounds) {
        const playbackCenter = playbackLineBounds.center;

        return playbackCenter >= noteBounds.left && playbackCenter <= noteBounds.right;
      }

      /**
       * Get the expected note at the current playback line position
       * @param {number} playbackLinePosition - Current playback line position
       * @param {Array} noteElements - Array of note elements
       * @returns {Object|null} Expected note data or null if no note found
       */
      getExpectedNoteAtPosition(playbackLinePosition, noteElements) {
        // Boundary checking for input parameters
        if (!noteElements || noteElements.length === 0) {
          console.warn('TimingEvaluationSystem: No note elements provided');
          return null;
        }

        if (typeof playbackLinePosition !== 'number' || isNaN(playbackLinePosition)) {
          console.warn('TimingEvaluationSystem: Invalid playback line position');
          return null;
        }

        try {
          // Use cached note elements if available and valid
          const cachedNotes = this.getCachedNoteElements(noteElements);

          if (cachedNotes.length === 0) {
            console.warn('TimingEvaluationSystem: No valid cached notes available');
            return null;
          }

          // Find the note that should be played at current position
          // Look for notes where the playback line is approaching or intersecting
          let closestNote = null;
          let closestDistance = Infinity;

          for (const noteData of cachedNotes) {
            if (!noteData || !noteData.element || noteData.pitch === 'rest') continue;

            try {
              const noteHeadPosition = this.calculateNoteHeadPosition(noteData.element);
              const playbackLineBounds = this.getPlaybackLineBounds();

              // Boundary checking for calculated positions
              if (typeof noteHeadPosition !== 'number' || isNaN(noteHeadPosition)) {
                console.warn(`TimingEvaluationSystem: Invalid note head position for ${noteData.pitch}`);
                continue;
              }

              // Check if this note is the one we should be playing
              // (playback line is within reasonable distance of note)
              const distanceToNoteHead = Math.abs(playbackLineBounds.center - noteHeadPosition);
              const isWithinReasonableDistance = distanceToNoteHead <= 50; // 50px tolerance for detection

              if (isWithinReasonableDistance && distanceToNoteHead < closestDistance) {
                closestDistance = distanceToNoteHead;
                closestNote = noteData;
              }
            } catch (noteError) {
              console.warn(`TimingEvaluationSystem: Error processing note ${noteData.pitch}:`, noteError);
              continue; // Skip this note and continue with others
            }
          }

          return closestNote;

        } catch (error) {
          console.error('TimingEvaluationSystem: Error in getExpectedNoteAtPosition:', error);
          return null;
        }
      }

      /**
       * Get cached note elements for performance optimization
       * @param {Array} noteElements - Current note elements
       * @returns {Array} Cached note data
       */
      getCachedNoteElements(noteElements) {
        const now = Date.now();

        // Check if cache is still valid
        if (now - this.lastCacheUpdate < this.cacheValidityDuration && this.noteElementsCache.size > 0) {
          // Validate cached elements are still in DOM for performance optimization
          const cachedValues = Array.from(this.noteElementsCache.values());
          const validCachedElements = cachedValues.filter(noteData => {
            try {
              return noteData.element &&
                noteData.element.parentNode &&
                document.contains(noteData.element);
            } catch (error) {
              return false; // Element is no longer valid
            }
          });

          // If most cached elements are still valid, use cache
          if (validCachedElements.length > cachedValues.length * 0.8) {
            // Cache hit
            if (this.performanceMetrics) {
              this.performanceMetrics.cacheHits++;
            }
            return validCachedElements;
          }
        }

        // Rebuild cache with error handling
        this.noteElementsCache.clear();

        try {
          noteElements.forEach((element, index) => {
            try {
              // Handle DOM element access errors gracefully
              if (element &&
                element.nodeType === Node.ELEMENT_NODE &&
                document.contains(element)) {

                const pitch = element.dataset?.pitch || element.getAttribute('data-pitch');
                if (pitch && typeof pitch === 'string') {
                  this.noteElementsCache.set(index, {
                    element: element,
                    pitch: pitch,
                    index: index
                  });
                }
              }
            } catch (elementError) {
              console.warn(`TimingEvaluationSystem: Error processing element at index ${index}:`, elementError);
              // Continue processing other elements
            }
          });
        } catch (error) {
          console.error('TimingEvaluationSystem: Error rebuilding note cache:', error);
          // Return empty array to prevent further errors
          return [];
        }

        this.lastCacheUpdate = now;
        const cachedValues = Array.from(this.noteElementsCache.values());

        // Cache miss
        if (this.performanceMetrics) {
          this.performanceMetrics.cacheMisses++;
        }

        console.log(`TimingEvaluationSystem: Cache rebuilt with ${cachedValues.length} valid elements`);
        return cachedValues;
      }

      /**
       * Display incorrect note as gray eighth note aligned with playback line
       * @param {string} keyNote - The incorrect note that was pressed
       * @param {number} playbackLinePosition - Current playback line position
       */
      displayIncorrectNote(keyNote, playbackLinePosition) {
        try {
          const playbackLineBounds = this.getPlaybackLineBounds();

          const incorrectNoteElement = this.createIncorrectNoteElement(
            keyNote,
            playbackLineBounds.left
          );

          // Add to staff container
          if (this.staffContainer && incorrectNoteElement) {
            this.staffContainer.appendChild(incorrectNoteElement);
            this.incorrectNoteElements.add(incorrectNoteElement);

            // Auto-remove after delay (Requirement 12.5, 12.6)
            this.removeIncorrectNoteAfterDelay(incorrectNoteElement, 1000);
          }

        } catch (error) {
          console.error('Error displaying incorrect note:', error);
        }
      }

      /**
       * Create visual element for incorrect note (gray eighth note)
       * @param {string} keyNote - The incorrect note
       * @param {number} xPosition - X position for the note
       * @returns {HTMLElement} The created note element
       */
      createIncorrectNoteElement(keyNote, xPosition) {
        const noteElement = document.createElement('div');
        noteElement.className = 'note-rectangle incorrect-note';
        noteElement.style.position = 'absolute';
        noteElement.style.left = `${xPosition}px`;
        let width = this.staffRenderer.notePositioning.getNoteWidth('eighth');
        noteElement.style.width = `${width}px`;
        noteElement.style.height = '22px';
        noteElement.style.borderRadius = '4px';
        noteElement.style.zIndex = '20';
        noteElement.setAttribute('data-incorrect-note', keyNote);

        // Position vertically based on note pitch
        let yPosition = this.staffRenderer.notePositioning.getVerticalPosition(keyNote);
        noteElement.style.top = `${yPosition}px`;

        return noteElement;
      }

      /**
       * Remove incorrect note element after specified delay
       * @param {HTMLElement} noteElement - The note element to remove
       * @param {number} delay - Delay in milliseconds
       */
      removeIncorrectNoteAfterDelay(noteElement, delay) {
        // Store timeout reference for cleanup
        const timeoutId = setTimeout(() => {
          try {
            if (noteElement && noteElement.parentNode && document.contains(noteElement)) {
              noteElement.parentNode.removeChild(noteElement);
              this.incorrectNoteElements.delete(noteElement);
              console.log('Removed incorrect note element after delay');
            } else {
              // Element was already removed, just clean up our reference
              this.incorrectNoteElements.delete(noteElement);
            }
          } catch (error) {
            console.warn('TimingEvaluationSystem: Error removing incorrect note element:', error);
            // Clean up reference even if removal failed
            this.incorrectNoteElements.delete(noteElement);
          }
        }, delay);

        // Store timeout reference on element for potential early cleanup
        if (noteElement) {
          noteElement._cleanupTimeoutId = timeoutId;
        }
      }

      /**
       * Clear all incorrect note elements with timeout cleanup
       */
      clearAllIncorrectNotes() {
        this.incorrectNoteElements.forEach(element => {
          try {
            // Clear any pending timeouts to prevent memory leaks
            if (element && element._cleanupTimeoutId) {
              clearTimeout(element._cleanupTimeoutId);
              delete element._cleanupTimeoutId;
            }

            // Remove element from DOM
            if (element && element.parentNode && document.contains(element)) {
              element.parentNode.removeChild(element);
            }
          } catch (error) {
            console.warn('TimingEvaluationSystem: Error clearing incorrect note element:', error);
          }
        });

        this.incorrectNoteElements.clear();
        console.log('Cleared all incorrect note elements with timeout cleanup');
      }

      /**
       * Normalize note names for comparison (handle different octave notations)
       * @param {string} noteName - The note name to normalize
       * @returns {string} Normalized note name
       */
      normalizeNoteName(noteName) {
        if (!noteName) return '';

        // Handle different note name formats
        // Convert "C5" to "C5", "C" to "C4" (default octave)
        if (noteName.length === 1) {
          return noteName + '4'; // Default to 4th octave
        }

        return noteName;
      }

      /**
       * Show timing feedback message to user
       * @param {Object} result - Timing evaluation result
       * @param {string} keyNote - The pressed key note
       */
      showTimingFeedback(result, keyNote) {
        // This method will be enhanced in subtask 15.3
        console.log(`Timing feedback: ${result.message}`);

        // For now, just log the result
        if (result.timing === 'incorrect') {
          this.displayIncorrectNote(keyNote, this.getPlaybackLineBounds().left);
        }
      }

      /**
       * Update timing tolerance based on current tempo setting
       * @param {string} tempoValue - Current tempo value (e.g., "60", "120")
       */
      updateTempoSettings(tempoValue) {
        this.currentTempo = tempoValue;

        // Adjust timing tolerance based on tempo for consistent timing evaluation
        // Faster tempos need slightly larger tolerance due to increased playback speed
        const tempoData = TEMPO_MARKINGS[tempoValue];
        if (tempoData) {
          const speedMultiplier = tempoData.speedMultiplier;
          // Scale tolerance with tempo: slower = tighter tolerance, faster = looser tolerance
          this.timingTolerance = this.baseTolerance * Math.max(0.8, Math.min(1.5, speedMultiplier));

          console.log(`Timing tolerance updated for ${tempoValue} BPM: ${this.timingTolerance.toFixed(1)}px`);
        }
      }

      /**
       * Get current timing tolerance (useful for debugging and testing)
       * @returns {number} Current timing tolerance in pixels
       */
      getCurrentTimingTolerance() {
        return this.timingTolerance;
      }

      /**
       * Create standardized error result object
       * @param {string} message - Error message
       * @returns {Object} Error result object
       */
      createErrorResult(message) {
        return {
          timing: 'error',
          isCorrect: false,
          expectedNote: null,
          message: message
        };
      }

      /**
       * Perform fallback timing detection for edge cases
       * @param {string} keyNote - The pressed key note
       * @param {number} playbackLinePosition - Current playback line position
       * @param {Array} noteElements - Array of note elements
       * @returns {Object|null} Fallback result or null if no fallback possible
       */
      performFallbackDetection(keyNote, playbackLinePosition, noteElements) {
        try {
          // Look for any note within a larger tolerance range (fallback detection)
          const fallbackTolerance = 100; // Larger tolerance for fallback
          let fallbackNote = null;
          let fallbackDistance = Infinity;

          const cachedNotes = this.getCachedNoteElements(noteElements);

          for (const noteData of cachedNotes) {
            if (!noteData || !noteData.element || noteData.pitch === 'rest') continue;

            try {
              const noteHeadPosition = this.calculateNoteHeadPosition(noteData.element);
              const playbackLineBounds = this.getPlaybackLineBounds();

              const distance = Math.abs(playbackLineBounds.center - noteHeadPosition);

              if (distance <= fallbackTolerance && distance < fallbackDistance) {
                fallbackDistance = distance;
                fallbackNote = noteData;
              }
            } catch (noteError) {
              continue; // Skip problematic notes
            }
          }

          if (fallbackNote) {
            const isCorrectNote = this.normalizeNoteName(keyNote) === this.normalizeNoteName(fallbackNote.pitch);

            if (isCorrectNote) {
              // Use fallback timing evaluation
              return {
                timing: 'correct', // Assume correct for fallback
                isCorrect: true,
                expectedNote: fallbackNote.pitch,
                pressedNote: keyNote,
                message: `Fallback detection: ${keyNote} (tolerance: ${fallbackDistance.toFixed(1)}px)`,
                noteElement: fallbackNote.element
              };
            } else {
              return {
                timing: 'incorrect',
                isCorrect: false,
                expectedNote: fallbackNote.pitch,
                pressedNote: keyNote,
                message: `Fallback detection: pressed ${keyNote}, expected ${fallbackNote.pitch}`
              };
            }
          }

          return null; // No fallback possible

        } catch (error) {
          console.warn('TimingEvaluationSystem: Fallback detection failed:', error);
          return null;
        }
      }

      /**
       * Update performance metrics for optimization monitoring
       * @param {number} startTime - Start time from performance.now()
       */
      updatePerformanceMetrics(startTime) {
        try {
          const endTime = performance.now();
          const evaluationTime = endTime - startTime;

          this.performanceMetrics.evaluationCount++;
          this.performanceMetrics.totalEvaluationTime += evaluationTime;
          this.performanceMetrics.averageEvaluationTime =
            this.performanceMetrics.totalEvaluationTime / this.performanceMetrics.evaluationCount;

          if (evaluationTime > this.performanceMetrics.maxEvaluationTime) {
            this.performanceMetrics.maxEvaluationTime = evaluationTime;
          }

          // Log performance warning if evaluation is taking too long
          if (evaluationTime > 10) { // 10ms threshold for real-time response
            console.warn(`TimingEvaluationSystem: Slow evaluation detected: ${evaluationTime.toFixed(2)}ms`);
          }

          // Update cache hit rate
          const totalCacheRequests = this.performanceMetrics.cacheHits + this.performanceMetrics.cacheMisses;
          if (totalCacheRequests > 0) {
            this.performanceMetrics.cacheHitRate =
              (this.performanceMetrics.cacheHits / totalCacheRequests) * 100;
          }

        } catch (error) {
          console.warn('TimingEvaluationSystem: Error updating performance metrics:', error);
        }
      }

      /**
       * Get current performance metrics for debugging and optimization
       * @returns {Object} Performance metrics object
       */
      getPerformanceMetrics() {
        return {
          ...this.performanceMetrics,
          cacheSize: this.noteElementsCache.size,
          cacheAge: Date.now() - this.lastCacheUpdate
        };
      }

      /**
       * Reset performance metrics
       */
      resetPerformanceMetrics() {
        this.performanceMetrics = {
          evaluationCount: 0,
          totalEvaluationTime: 0,
          averageEvaluationTime: 0,
          maxEvaluationTime: 0,
          cacheHitRate: 0,
          cacheHits: 0,
          cacheMisses: 0
        };
        console.log('TimingEvaluationSystem: Performance metrics reset');
      }

      /**
       * Dispose of the timing evaluation system and clean up resources
       */
      dispose() {
        try {
          // Log final performance metrics before disposal
          const metrics = this.getPerformanceMetrics();
          console.log('TimingEvaluationSystem: Final performance metrics:', metrics);

          // Clear all incorrect notes with timeout cleanup
          this.clearAllIncorrectNotes();

          // Clear cache and reset timing
          this.noteElementsCache.clear();
          this.lastCacheUpdate = 0;

          // Clear performance metrics
          this.performanceMetrics = null;

          // Clear DOM references to prevent memory leaks
          this.staffContainer = null;
          this.playbackLineElement = null;
          this.staffRenderer = null;
          this.playbackController = null;

          console.log('TimingEvaluationSystem disposed successfully');
        } catch (error) {
          console.error('TimingEvaluationSystem: Error during disposal:', error);
        }
      }
    }

    /**
     * ProgressBarController class for managing enhanced progress bar features
     * Provides click-to-jump functionality and integrates with playback system
     */
    class ProgressBarController {
      /**
       * @param {PianoTutorApp} staffRenderer - The staff renderer instance (PianoTutorApp)
       * @param {PianoTutorApp} playbackController - The playback controller instance (PianoTutorApp)
       */
      constructor(staffRenderer, playbackController) {
        this.staffRenderer = staffRenderer;
        this.playbackController = playbackController;
        this.progressBarElement = null;
        this.progressFillElement = null;
        this.isInteracting = false;
        this.isInitialized = false;
        this.interactionTimeout = null;

        console.log('ProgressBarController initialized');
      }

      /**
       * Enhance existing progress bar with click-to-jump functionality
       * @returns {boolean} Success status
       */
      enhanceExistingProgressBar() {
        // Get existing progress bar elements
        this.progressBarElement = document.querySelector('.simple-progress-bar');
        this.progressFillElement = document.getElementById('progressFill');

        if (!this.progressBarElement || !this.progressFillElement) {
          console.error('Existing progress bar elements not found');
          return false;
        }

        // Add interactive functionality to existing progress bar
        this.addInteractiveFeatures();
        this.isInitialized = true;

        console.log('Enhanced existing progress bar with click-to-jump functionality');
        return true;
      }

      /**
       * Add click event handlers to existing simple-progress-bar element
       */
      addInteractiveFeatures() {
        // Add click-to-jump functionality
        this.progressBarElement.addEventListener('click', (event) => {
          this.handleProgressBarClick(event);
        });

        // Add cursor pointer style for better UX
        this.progressBarElement.style.cursor = 'pointer';

        // Add responsive hover effects for visual feedback
        this.progressBarElement.addEventListener('mouseenter', () => {
          if (!this.isInteracting) {
            this.applyResponsiveHoverHeight();
          }
        });

        this.progressBarElement.addEventListener('mouseleave', () => {
          if (!this.isInteracting) {
            this.resetResponsiveHeight();
          }
        });

        // Add window resize listener to maintain responsiveness across different screen sizes
        this.resizeHandler = () => this.handleResize();
        window.addEventListener('resize', this.resizeHandler);

        console.log('Interactive features added to progress bar with responsive support');
      }

      /**
       * Apply responsive hover height based on screen size
       */
      applyResponsiveHoverHeight() {
        if (!this.progressBarElement) return;

        const isMobile = window.innerWidth <= 768;
        const hoverHeight = isMobile ? '8px' : '6px';

        this.progressBarElement.style.height = hoverHeight;
      }

      /**
       * Clean up event listeners when controller is destroyed
       */
      destroy() {
        if (this.resizeHandler) {
          window.removeEventListener('resize', this.resizeHandler);
          this.resizeHandler = null;
        }

        if (this.interactionTimeout) {
          clearTimeout(this.interactionTimeout);
          this.interactionTimeout = null;
        }

        console.log('ProgressBarController destroyed and cleaned up');
      }

      /**
       * Handle progress bar click events for jump navigation
       * Handles rapid successive clicks without position conflicts
       * @param {MouseEvent} clickEvent - The click event
       */
      handleProgressBarClick(clickEvent) {
        if (!this.isInitialized) {
          console.warn('ProgressBarController not initialized');
          return;
        }

        // Prevent rapid successive clicks from causing conflicts
        if (this.isInteracting) {
          console.debug('Ignoring click during interaction state');
          return;
        }

        const trackRect = clickEvent.currentTarget.getBoundingClientRect();
        const clickX = clickEvent.clientX - trackRect.left;
        const progressPercentage = Math.max(0, Math.min(100, (clickX / trackRect.width) * 100));

        // Set interaction state to prevent conflicts
        this.setInteractionState(true);

        // Implement position calculation from click coordinates to staff position
        const targetPosition = this.calculateStaffPositionFromProgress(progressPercentage);

        // Jump to position - ensure click navigation works during both playback and pause states
        this.jumpToPosition(targetPosition);

        // Update progress bar visual immediately
        this.progressFillElement.style.width = `${progressPercentage}%`;

        // Reset interaction state after a brief delay to handle rapid successive clicks
        this.resetInteractionStateDelayed();

        console.log(`Progress bar clicked: ${progressPercentage.toFixed(1)}% -> position ${targetPosition}px`);
      }

      /**
       * Reset interaction state with debouncing to handle rapid successive clicks
       */
      resetInteractionStateDelayed() {
        // Clear any existing timeout to prevent conflicts
        if (this.interactionTimeout) {
          clearTimeout(this.interactionTimeout);
        }

        // Set new timeout for interaction state reset
        this.interactionTimeout = setTimeout(() => {
          this.setInteractionState(false);
          this.interactionTimeout = null;
        }, 300); // Slightly longer delay for better UX
      }

      /**
       * Calculate staff position from progress percentage
       * @param {number} progressPercentage - Progress percentage (0-100)
       * @returns {number} Staff position in pixels
       */
      calculateStaffPositionFromProgress(progressPercentage) {
        const totalStaffWidth = this.playbackController.getTotalSongWidth();
        const targetOffset = (progressPercentage / 100) * totalStaffWidth;

        // Convert to position for staff movement (staff moves right to left)
        return targetOffset;
      }

      /**
       * Jump to specific position in the song
       * Implements jumpToPosition method to update staff position immediately
       * Coordinates with PlaybackController to update internal position tracking
       * Handles boundary validation to prevent navigation beyond song limits
       * Updates current note index when jumping to new positions
       * @param {number} targetPosition - Target position in pixels
       */
      jumpToPosition(targetPosition) {
        // Handle boundary validation to prevent navigation beyond song limits
        const totalSongWidth = this.playbackController.getTotalSongWidth();
        const constrainedPosition = Math.max(0, Math.min(targetPosition, totalSongWidth));

        if (constrainedPosition !== targetPosition) {
          console.log(`Position constrained from ${targetPosition}px to ${constrainedPosition}px (bounds: 0-${totalSongWidth}px)`);
        }

        // Pause current playback if active
        if (this.playbackController.isPlaying) {
          this.playbackController.handlePause();
          console.log('Playback paused for progress bar navigation');
        }

        // Update staff position immediately
        this.playbackController.currentPosition = constrainedPosition;
        this.playbackController.updateStaffPosition(-constrainedPosition, () => {
        // Coordinate with PlaybackController to update internal position tracking
        // This ensures progress bar updates don't interfere with normal playback progress
        // Note: updateInternalPositionTracking() handles note index updates internally
          this.playbackController.updateInternalPositionTracking();
        });

        console.log(`Jumped to position: ${constrainedPosition}px`);
      }

      /**
       * Set interaction state to prevent conflicts during user clicks
       * Implements interaction state tracking to prevent conflicts during user clicks
       * Adds visual feedback classes for interaction states
       * Ensures smooth transitions between normal and interaction states
       * Maintains progress bar responsiveness across different screen sizes
       * @param {boolean} isInteracting - True if user is interacting
       */
      setInteractionState(isInteracting) {
        this.isInteracting = isInteracting;

        if (this.progressBarElement) {
          if (isInteracting) {
            this.progressBarElement.classList.add('interacting');
            // Apply responsive height based on screen size
            this.applyResponsiveInteractionHeight();
          } else {
            this.progressBarElement.classList.remove('interacting');
            // Reset to default responsive height
            this.resetResponsiveHeight();
          }
        }

        // Ensure smooth transitions between normal and interaction states
        this.ensureSmoothTransitions(isInteracting);
      }

      /**
       * Apply responsive height during interaction based on screen size
       */
      applyResponsiveInteractionHeight() {
        if (!this.progressBarElement) return;

        const isMobile = window.innerWidth <= 768;
        const interactionHeight = isMobile ? '8px' : '6px';

        this.progressBarElement.style.height = interactionHeight;
      }

      /**
       * Reset to default responsive height
       */
      resetResponsiveHeight() {
        if (!this.progressBarElement) return;

        const isMobile = window.innerWidth <= 768;
        const defaultHeight = isMobile ? '6px' : '4px';

        this.progressBarElement.style.height = defaultHeight;
      }

      /**
       * Ensure smooth transitions between normal and interaction states
       * @param {boolean} isInteracting - Current interaction state
       */
      ensureSmoothTransitions(isInteracting) {
        if (!this.progressBarElement) return;

        // Add transition class for smooth state changes
        this.progressBarElement.classList.add('state-transitioning');

        // Remove transition class after animation completes
        setTimeout(() => {
          if (this.progressBarElement) {
            this.progressBarElement.classList.remove('state-transitioning');
          }
        }, 200); // Match CSS transition duration

        // Update cursor style for better UX
        this.progressBarElement.style.cursor = isInteracting ? 'grabbing' : 'pointer';
      }

      /**
       * Handle window resize to maintain responsiveness
       */
      handleResize() {
        if (this.isInteracting) {
          this.applyResponsiveInteractionHeight();
        } else {
          this.resetResponsiveHeight();
        }
      }

      /**
       * Update progress display (called by playback controller)
       * Ensures progress bar updates don't interfere with normal playback progress
       * @param {number} currentPosition - Current playback position
       * @param {number} totalDuration - Total song duration
       */
      updateProgress(currentPosition, totalDuration) {
        if (!this.progressFillElement || this.isInteracting) {
          return; // Don't update during user interaction to prevent conflicts
        }

        const progressPercentage = totalDuration > 0 ?
          Math.max(0, Math.min(100, (currentPosition / totalDuration) * 100)) : 0;

        // Use requestAnimationFrame for smooth updates that don't interfere with playback
        requestAnimationFrame(() => {
          if (this.progressFillElement && !this.isInteracting) {
            this.progressFillElement.style.width = `${progressPercentage}%`;
          }
        });
      }

      /**
       * Check if controller is properly initialized
       * @returns {boolean} Initialization status
       */
      isReady() {
        return this.isInitialized && this.progressBarElement && this.progressFillElement;
      }

      /**
       * Validate progress bar interaction state management
       * @returns {Object} Validation results
       */
      validateInteractionStateManagement() {
        const validation = {
          isValid: true,
          issues: [],
          details: {}
        };

        try {
          // Check if elements are properly initialized
          if (!this.isReady()) {
            validation.isValid = false;
            validation.issues.push('Progress bar controller not properly initialized');
            return validation;
          }

          // Check interaction state tracking
          validation.details.interactionStateTracking = this.isInteracting ? 'Active' : 'Ready';
          validation.details.hasInteractionTimeout = this.interactionTimeout !== null;

          // Check visual feedback classes
          const hasInteractingClass = this.progressBarElement.classList.contains('interacting');
          validation.details.visualFeedbackActive = hasInteractingClass;

          // Check responsive behavior
          const currentHeight = window.getComputedStyle(this.progressBarElement).height;
          validation.details.currentHeight = currentHeight;
          validation.details.screenWidth = window.innerWidth;
          validation.details.isMobileView = window.innerWidth <= 768;

          // Check event listeners
          validation.details.hasResizeHandler = this.resizeHandler !== null;

          console.log('Progress bar interaction state validation:', validation);
          return validation;

        } catch (error) {
          validation.isValid = false;
          validation.issues.push(`Validation error: ${error.message}`);
          return validation;
        }
      }
    }

    // Initialize the Piano Tutor App when the page loads
    window.addEventListener('DOMContentLoaded', async function () {
      console.log('Piano Tutor App initialized successfully');
      window.pianoApp = new PianoTutorApp();

      // Initialize MIDI system
      console.log('Initializing MIDI system...');
      window.midiController = new MIDIController();
      window.midiDeviceManager = new MIDIDeviceManager();

      // Set up MIDI event callbacks - integrate with virtual keyboard
      window.midiController.onNotePressed = (noteData) => {
        console.log('MIDI Note Pressed:', noteData);
        // Forward MIDI input to virtual keyboard
        if (window.pianoApp && window.pianoApp.virtualKeyboard) {
          window.pianoApp.virtualKeyboard.handleMIDINotePressed(noteData);
        }
      };

      window.midiController.onNoteReleased = (noteData) => {
        console.log('MIDI Note Released:', noteData);
        // Forward MIDI input to virtual keyboard
        if (window.pianoApp && window.pianoApp.virtualKeyboard) {
          window.pianoApp.virtualKeyboard.handleMIDINoteReleased(noteData);
        }
      };

      // Attempt to initialize MIDI
      try {
        const midiInitialized = await window.midiController.initializeMIDI();
        if (midiInitialized) {
          console.log('✅ MIDI system initialized successfully');

          // Set up fallback handler for graceful degradation
          window.midiController.onFallbackToVirtual = (fallbackInfo) => {
            console.warn('🎹 MIDI connection lost, falling back to virtual keyboard', fallbackInfo);

            // MIDI connection lost - fallback notification removed

            // Ensure virtual keyboard is ready
            if (window.pianoApp && window.pianoApp.virtualKeyboard) {
              window.pianoApp.virtualKeyboard.ensureVirtualKeyboardReady();
            }
          };

          // Initialize MIDI device manager UI
          const deviceManagerInitialized = window.midiDeviceManager.initialize(window.midiController);
          if (deviceManagerInitialized) {
            console.log('✅ MIDI device manager initialized successfully');
          } else {
            console.warn('⚠️ MIDI device manager initialization failed');
          }

          console.log('Available MIDI devices:', window.midiController.getAvailableDevices());
          console.log('Connection status:', window.midiController.getConnectionStatus());
          console.log('MIDI preferences:', window.midiController.getPreferences());
        } else {
          console.warn('⚠️ MIDI system initialization failed');
        }
      } catch (error) {
        console.error('❌ MIDI initialization error:', error);
      }

      // Validate tempo control integration
      const validation = window.pianoApp.validateTempoIntegration();
      console.log('Tempo integration validation:', validation);
      if (validation.isValid) {
        console.log('✅ Tempo control integration validated successfully');
        console.log('Integration details:', validation.details);
      } else {
        console.warn('⚠️ Tempo control integration issues found:', validation.issues);
      }

      // Add global click handler to initialize audio on first user interaction
      let audioInitialized = false;
      document.addEventListener('click', async function initAudioOnClick() {
        if (!audioInitialized && window.pianoApp && window.pianoApp.virtualKeyboard) {
          console.log('🎵 [GLOBAL] First user click detected, initializing audio...');
          try {
            const success = await window.pianoApp.virtualKeyboard.initializeAudio();
            if (success) {
              console.log('🎵 [GLOBAL] Audio initialized successfully on user click');
              audioInitialized = true;

              // Remove this event listener after successful initialization
              document.removeEventListener('click', initAudioOnClick);
            } else {
              console.warn('🎵 [GLOBAL] Audio initialization failed on user click');
            }
          } catch (error) {
            console.error('🎵 [GLOBAL] Error initializing audio on user click:', error);
          }
        }
      });
    });
  </script>
</body>

</html>
