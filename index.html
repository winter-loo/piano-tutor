<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano Tutor App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f8f9fa;
            color: #333;
            overflow-x: hidden;
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            color: #7f8c8d;
        }

        .staff-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 40px 20px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            min-height: 200px;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: none;
            -webkit-touch-callout: none;
        }

        .playback-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            background-color: #e74c3c;
            left: 120px;
            z-index: 10;
            opacity: 0.8;
        }

        /* Static staff lines that remain fixed during animation */
        .staff-lines {
            position: absolute;
            top: 60px;
            /* 40px margin + 20px staff top */
            left: 0;
            right: 0;
            height: 80px;
            z-index: 1;
        }

        .staff-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background-color: #2c3e50;
        }

        /* Animated content container - only this moves */
        .staff {
            position: relative;
            /* make some room to prevent hidden */
            height: 140px;
            margin-left: 70px;
            overflow: hidden;
            transition: transform 0.1s linear;
            z-index: 2;
        }

        /* Smooth transitions for notes container during manual interaction */
        .notes-container {
            transition: transform 0.1s linear;
            will-change: transform; /* Optimize for transform animations */
        }

        .staff-line:nth-child(1) {
            top: 0;
        }

        .staff-line:nth-child(2) {
            top: 20px;
        }

        .staff-line:nth-child(3) {
            top: 40px;
        }

        .staff-line:nth-child(4) {
            top: 60px;
        }

        .staff-line:nth-child(5) {
            top: 80px;
        }

        .treble-clef {
            position: absolute;
            left: 20px;
            top: 0px;
            font-size: 10rem;
            color: #2c3e50;
            z-index: 4;
        }

        .notes-container {
            position: absolute;
            left: 30px;
            top: 0;
            height: 120px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            min-width: 100px;
        }

        .control-btn:hover {
            background-color: #2980b9;
        }

        .control-btn:active {
            transform: translateY(1px);
        }

        .control-btn.play {
            background-color: #27ae60;
        }

        .control-btn.play:hover {
            background-color: #229954;
        }

        .control-btn.pause {
            background-color: #f39c12;
        }

        .control-btn.pause:hover {
            background-color: #e67e22;
        }

        .control-btn.reset {
            background-color: #e74c3c;
        }

        .control-btn.reset:hover {
            background-color: #c0392b;
        }

        .control-btn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .control-btn:disabled:hover {
            background-color: #bdc3c7;
            transform: none;
        }

        .control-btn.active {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            transform: scale(0.98);
        }

        /* Tempo control styles */
        .tempo-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin: 0 10px;
        }

        .tempo-label {
            font-size: 0.9rem;
            color: #2c3e50;
            font-weight: 600;
            margin: 0;
        }

        .tempo-selector {
            background-color: #34495e;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            min-width: 160px;
            text-align: center;
            font-weight: 500;
        }

        .tempo-selector:hover {
            background-color: #2c3e50;
        }

        .tempo-selector:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(52, 73, 94, 0.3);
        }

        .tempo-display {
            font-size: 0.8rem;
            color: #7f8c8d;
            text-align: center;
            margin: 0;
            line-height: 1.2;
        }

        .info-panel {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 20px;
            text-align: center;
        }

        .info-panel h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .info-panel p {
            color: #7f8c8d;
            line-height: 1.6;
        }

        /* Note rectangle styles */
        .note-rectangle {
            position: absolute;
            height: 16px;
            border-radius: 2px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }

        /* Note colors based on pitch */
        .note-rectangle.pitch-C {
            background-color: #e74c3c;
            border-color: #c0392b;
        }

        .note-rectangle.pitch-D {
            background-color: #f39c12;
            border-color: #e67e22;
        }

        .note-rectangle.pitch-F {
            background-color: #27ae60;
            border-color: #229954;
        }

        .note-rectangle.pitch-G {
            background-color: #3498db;
            border-color: #2980b9;
        }

        .note-rectangle.pitch-A {
            background-color: #9b59b6;
            border-color: #8e44ad;
        }

        .note-rectangle.pitch-C5 {
            background-color: #e67e22;
            border-color: #d35400;
        }

        /* Note highlighting for current playback */
        .note-rectangle.current {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.6);
            z-index: 5;
        }

        /* Fingering number display inside note rectangles */
        .fingering-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 11px;
            font-family: Arial, sans-serif;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 6;
            line-height: 1;
        }

        /* Measure bar styles */
        .measure-bar {
            position: absolute;
            top: 20px;
            height: 80px;
            width: 1px;
            background-color: #2c3e50;
            z-index: 3;
        }

        @media (max-width: 768px) {
            .app-container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .staff-container {
                padding: 20px 10px;
            }

            .controls {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }

            .control-btn {
                width: 200px;
            }

            .tempo-control {
                margin: 0;
                width: 200px;
            }

            .tempo-selector {
                width: 100%;
                min-width: auto;
            }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <header class="header">
            <h1>Piano Tutor App</h1>
            <p>Learn to play "Different Colors" by Walk the Moon</p>
        </header>

        <div class="staff-container">
            <div class="playback-line"></div>

            <!-- Static staff lines that don't move -->
            <div class="staff-lines">
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
            </div>

            <!-- Static treble clef that doesn't move -->
            <div class="treble-clef">ùÑû</div>

            <!-- Animated content container -->
            <div class="staff">
                <div class="notes-container">
                    <!-- Notes will be dynamically added here -->
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn play" id="playBtn">Play</button>
            <button class="control-btn pause" id="pauseBtn">Pause</button>
            <button class="control-btn reset" id="resetBtn">Reset</button>
            
            <div class="tempo-control">
                <label class="tempo-label" for="tempoSelector">Tempo</label>
                <select class="tempo-selector" id="tempoSelector">
                    <option value="40">40 BPM</option>
                    <option value="60">60 BPM</option>
                    <option value="76">76 BPM</option>
                    <option value="108">108 BPM</option>
                    <option value="120" selected>120 BPM</option>
                    <option value="168">168 BPM</option>
                    <option value="180">180 BPM</option>
                    <option value="200">200 BPM</option>
                </select>
                <p class="tempo-display" id="tempoDisplay">120 BPM</p>
            </div>
        </div>

        <div class="info-panel">
            <h3>How to Use</h3>
            <p>
                Watch the red line as the musical staff moves underneath it.
                Each note will be highlighted as it passes through the line,
                showing you the timing and sequence for playing the song.
            </p>
            <div id="debug-info" style="margin-top: 20px; font-family: monospace; font-size: 0.9em; text-align: left;">
                <!-- Debug information will be displayed here -->
            </div>
        </div>
    </div>

    <script>
        // Hardcoded note data structure for "Different Colors" by Walk the Moon
        const SONG_DATA = {
            title: "Different Colors",
            artist: "Walk the Moon",
            measures: [
                {
                    number: 1,
                    notes: [
                        { pitch: "D", duration: "quarter", fingering: 2 },
                        { pitch: "F", duration: "quarter", fingering: 4 },
                        { pitch: "C", duration: "quarter", fingering: 1 },
                        { pitch: "rest", duration: "quarter", fingering: null }
                    ]
                },
                {
                    number: 2,
                    notes: [
                        { pitch: "G", duration: "quarter", fingering: 5 },
                        { pitch: "A", duration: "eighth", fingering: 1 },
                        { pitch: "G", duration: "eighth", fingering: 5 },
                        { pitch: "F", duration: "quarter", fingering: 4 },
                        { pitch: "rest", duration: "quarter", fingering: null }
                    ]
                },
                {
                    number: 3,
                    notes: [
                        { pitch: "D", duration: "quarter", fingering: 2 },
                        { pitch: "F", duration: "quarter", fingering: 4 },
                        { pitch: "C", duration: "quarter", fingering: 1 },
                        { pitch: "rest", duration: "quarter", fingering: null }
                    ]
                },
                {
                    number: 4,
                    notes: [
                        { pitch: "G", duration: "quarter", fingering: 5 },
                        { pitch: "A", duration: "eighth", fingering: 1 },
                        { pitch: "G", duration: "eighth", fingering: 5 },
                        { pitch: "F", duration: "quarter", fingering: 4 },
                        { pitch: "rest", duration: "quarter", fingering: null }
                    ]
                },
                {
                    number: 5,
                    notes: [
                        { pitch: "A", duration: "quarter", fingering: 1 },
                        { pitch: "C5", duration: "quarter", fingering: 3 },
                        { pitch: "A", duration: "dotted_quarter", fingering: 1 },
                        { pitch: "F", duration: "eighth", fingering: 4 }
                    ]
                },
                {
                    number: 6,
                    notes: [
                        { pitch: "A", duration: "dotted_quarter", fingering: 1 },
                        { pitch: "G", duration: "eighth", fingering: 5 },
                        { pitch: "F", duration: "half", fingering: 4 }
                    ]
                },
                {
                    number: 7,
                    notes: [
                        { pitch: "A", duration: "quarter", fingering: 1 },
                        { pitch: "C5", duration: "quarter", fingering: 3 },
                        { pitch: "A", duration: "dotted_quarter", fingering: 1 },
                        { pitch: "F", duration: "eighth", fingering: 4 }
                    ]
                },
                {
                    number: 8,
                    notes: [
                        { pitch: "A", duration: "dotted_quarter", fingering: 1 },
                        { pitch: "G", duration: "eighth", fingering: 5 },
                        { pitch: "F", duration: "half", fingering: 4 }
                    ]
                },
                {
                    number: 9,
                    notes: [
                        { pitch: "A", duration: "quarter", fingering: 1 },
                        { pitch: "C5", duration: "quarter", fingering: 3 },
                        { pitch: "A", duration: "dotted_quarter", fingering: 1 },
                        { pitch: "F", duration: "eighth", fingering: 4 }
                    ]
                },
                {
                    number: 10,
                    notes: [
                        { pitch: "A", duration: "quarter", fingering: 1 },
                        { pitch: "G", duration: "quarter", fingering: 5 },
                        { pitch: "F", duration: "half", fingering: 4 }
                    ]
                },
                {
                    number: 11,
                    notes: [
                        { pitch: "D", duration: "quarter", fingering: 2 },
                        { pitch: "F", duration: "quarter", fingering: 4 },
                        { pitch: "C", duration: "quarter", fingering: 1 },
                        { pitch: "rest", duration: "quarter", fingering: null }
                    ]
                },
                {
                    number: 12,
                    notes: [
                        { pitch: "G", duration: "quarter", fingering: 5 },
                        { pitch: "A", duration: "eighth", fingering: 1 },
                        { pitch: "G", duration: "eighth", fingering: 5 },
                        { pitch: "F", duration: "half", fingering: 4 }
                    ]
                }
            ]
        };

        // Note duration values in milliseconds (for timing calculations)
        const NOTE_DURATIONS = {
            "eighth": 250,
            "quarter": 500,
            "dotted_quarter": 750,
            "half": 1000
        };

        // Discrete BPM tempo values with corresponding playback speed multipliers
        const TEMPO_MARKINGS = {
            "40": {
                name: "40 BPM",
                bpm: 40,
                speedMultiplier: 0.33 // 40/120 ‚âà 0.33
            },
            "60": {
                name: "60 BPM",
                bpm: 60,
                speedMultiplier: 0.50 // 60/120 = 0.50
            },
            "76": {
                name: "76 BPM",
                bpm: 76,
                speedMultiplier: 0.63 // 76/120 ‚âà 0.63
            },
            "108": {
                name: "108 BPM",
                bpm: 108,
                speedMultiplier: 0.90 // 108/120 = 0.90
            },
            "120": {
                name: "120 BPM",
                bpm: 120,
                speedMultiplier: 1.0 // 120/120 = 1.0 (reference tempo)
            },
            "168": {
                name: "168 BPM",
                bpm: 168,
                speedMultiplier: 1.40 // 168/120 = 1.40
            },
            "180": {
                name: "180 BPM",
                bpm: 180,
                speedMultiplier: 1.50 // 180/120 = 1.50
            },
            "200": {
                name: "200 BPM",
                bpm: 200,
                speedMultiplier: 1.67 // 200/120 ‚âà 1.67
            }
        };

        // Default tempo setting - 120 BPM as specified in requirements
        const DEFAULT_TEMPO = "120";

        // Base playback speed in pixels per millisecond at default tempo (120 BPM)
        const BASE_PLAYBACK_SPEED = 0.05;

        // Note positioning system for treble clef staff
        class NotePositioning {
            constructor() {
                // Staff configuration
                this.staffTop = 20; // Top of staff lines container
                this.staffLineSpacing = 20; // Distance between staff lines
                this.staffHeight = 80; // Total height of staff lines area

                // Staff line positions (y-coordinates from staff container top)
                this.staffLines = {
                    1: this.staffTop + 0,  // Top line (F5)
                    2: this.staffTop + 20, // Second line (D5) 
                    3: this.staffTop + 40, // Middle line (B4)
                    4: this.staffTop + 60, // Fourth line (G4)
                    5: this.staffTop + 80  // Bottom line (E4)
                };

                // Note pitch to position mapping
                this.notePositions = {
                    "A3": 6 * this.staffLineSpacing + 12,
                    "B3": 6 * this.staffLineSpacing + 2,
                    "C": 5 * this.staffLineSpacing + 12,  // C4 (middle C) - ledger line below staff
                    "D": 5 * this.staffLineSpacing + 2,   // D4 - below staff space
                    "E": 4 * this.staffLineSpacing + 12,
                    "F": 4 * this.staffLineSpacing + 2,
                    "G": 3 * this.staffLineSpacing + 12,  // G4 - fourth line
                    "A": 3 * this.staffLineSpacing + 2,   // A4 - third space
                    "B": 2 * this.staffLineSpacing + 12,
                    "C5": 2 * this.staffLineSpacing + 2,  // C5 - second space
                    "D5": 1 * this.staffLineSpacing + 12,
                    "E5": 1 * this.staffLineSpacing + 2,
                    "F5": 0 * this.staffLineSpacing + 12,
                    "G5": 0 * this.staffLineSpacing + 2,
                    "A5": 0 * this.staffLineSpacing - 8,
                    "B5": -1 * this.staffLineSpacing - 8,
                };
            }

            /**
             * Get the vertical position for a note on the staff
             * @param {string} pitch - Note pitch (e.g., "D", "F", "C", "G", "A", "C5")
             * @returns {number} Y-coordinate position from top of staff container
             */
            getVerticalPosition(pitch) {
                if (!this.notePositions.hasOwnProperty(pitch)) {
                    console.warn(`Unknown pitch: ${pitch}. Using default position.`);
                    return this.staffLines[3]; // Default to middle line
                }
                return this.notePositions[pitch];
            }

            /**
             * Get note width based on duration
             * @param {string} duration - Note duration type
             * @returns {number} Width in pixels for the note rectangle
             */
            getNoteWidth(duration) {
                const widthMap = {
                    "eighth": 20,
                    "quarter": 40,
                    "dotted_quarter": 60,
                    "half": 80
                };
                return widthMap[duration] || 40; // Default to quarter note width
            }

            /**
             * Check if a note position is on a staff line (vs space)
             * @param {string} pitch - Note pitch
             * @returns {boolean} True if note is on a staff line
             */
            isOnStaffLine(pitch) {
                const position = this.getVerticalPosition(pitch);
                return Object.values(this.staffLines).includes(position);
            }

            /**
             * Calculate positions for all notes in the song
             * @param {Array} measures - Array of measure objects with notes
             * @returns {Array} Array of positioned note objects
             */
            calculateAllNotePositions(measures) {
                const positionedNotes = [];
                let noteIndex = 0;
                let cumulativeX = 0;
                const noteSpacing = 20; // 20 pixels between notes
                const measureBarMargin = 10; // 10 pixels from measure bar to notes
                this.measurePositions = []; // Track measure start positions

                measures.forEach((measure, measureIndex) => {
                    // Record the start position of this measure
                    this.measurePositions.push(cumulativeX);

                    // Add margin after measure bar for first note in measure
                    if (measureIndex > 0) {
                        cumulativeX += measureBarMargin;
                    }

                    measure.notes.forEach((note, noteInMeasureIndex) => {
                        const noteWidth = this.getNoteWidth(note.duration);

                        const positionData = {
                            ...note,
                            measureIndex: measureIndex,
                            noteIndex: noteIndex,
                            x: cumulativeX,
                            y: this.getVerticalPosition(note.pitch),
                            width: noteWidth,
                            height: 16,
                            isOnLine: this.isOnStaffLine(note.pitch)
                        };

                        positionedNotes.push(positionData);

                        // Move to next note position
                        cumulativeX += noteWidth + noteSpacing;
                        noteIndex++;
                    });

                    // Remove the last note spacing and add margin before next measure bar
                    cumulativeX -= noteSpacing;
                    cumulativeX += measureBarMargin;
                });

                return positionedNotes;
            }

            /**
             * Get measure bar positions
             * @returns {Array} Array of x-positions for measure bars
             */
            getMeasureBarPositions() {
                return this.measurePositions || [];
            }
        }

        // Piano Tutor App main class
        class PianoTutorApp {
            constructor() {
                this.isPlaying = false;
                this.isPaused = false;
                this.notePositioning = new NotePositioning();
                this.positionedNotes = [];
                this.animationId = null;
                this.startTime = null;
                this.pausedTime = 0;
                this.currentPosition = 0;
                
                // Tempo control system
                this.currentTempo = DEFAULT_TEMPO;
                this.playbackSpeed = this.calculatePlaybackSpeed(this.currentTempo);
                
                console.log(`Piano Tutor App initialized with tempo: ${this.currentTempo}`);


                // Manual interaction state
                this.isDragging = false;
                this.dragStartX = 0;
                this.dragStartPosition = 0;
                this.lastTouchX = 0;
                this.dragVelocity = 0;
                this.lastMoveTime = 0;


                this.initializeControls();
                this.initializeNotePositioning();
                this.initializeStaffInteraction();
            }

            /**
             * Calculate playback speed based on selected tempo
             * @param {string} tempoName - Name of the tempo marking (e.g., "Moderato")
             * @returns {number} Playback speed in pixels per millisecond
             */
            calculatePlaybackSpeed(tempoName) {
                if (!TEMPO_MARKINGS[tempoName]) {
                    console.warn(`Unknown tempo: ${tempoName}. Using default tempo.`);
                    tempoName = DEFAULT_TEMPO;
                }

                const tempo = TEMPO_MARKINGS[tempoName];
                const calculatedSpeed = BASE_PLAYBACK_SPEED * tempo.speedMultiplier;
                
                console.log(`Tempo: ${tempo.name} (${tempo.bpm} BPM) - Speed multiplier: ${tempo.speedMultiplier} - Playback speed: ${calculatedSpeed.toFixed(4)} px/ms`);
                
                return calculatedSpeed;
            }

            /**
             * Get current tempo information
             * @returns {Object} Current tempo object with name, BPM, and other details
             */
            getCurrentTempoInfo() {
                return TEMPO_MARKINGS[this.currentTempo];
            }

            /**
             * Get all available tempo markings
             * @returns {Object} All tempo markings with their details
             */
            getAllTempoMarkings() {
                return TEMPO_MARKINGS;
            }

            /**
             * Change the current tempo and recalculate playback speed
             * @param {string} tempoName - Name of the new tempo marking
             */
            setTempo(tempoName) {
                if (!TEMPO_MARKINGS[tempoName]) {
                    console.warn(`Unknown tempo: ${tempoName}. Keeping current tempo: ${this.currentTempo}`);
                    return;
                }

                const oldTempo = this.currentTempo;
                const wasPlaying = this.isPlaying;
                
                // Store current position for smooth transition
                const currentPositionBeforeChange = this.currentPosition;
                
                // Update tempo and recalculate playback speed
                this.currentTempo = tempoName;
                const newPlaybackSpeed = this.calculatePlaybackSpeed(tempoName);
                
                console.log(`Tempo changed from ${oldTempo} to ${tempoName}`);
                console.log(`Playback speed changed from ${this.playbackSpeed.toFixed(4)} to ${newPlaybackSpeed.toFixed(4)} px/ms`);
                
                // Ensure smooth transitions when changing tempo during playback
                if (wasPlaying) {
                    // Pause current playback to recalculate timing
                    this.handlePause();
                    
                    // Update playback speed
                    this.playbackSpeed = newPlaybackSpeed;
                    
                    // Maintain current position during tempo changes
                    this.currentPosition = currentPositionBeforeChange;
                    
                    // Recalculate start time based on new tempo and current position
                    const currentTimePosition = this.currentPosition / this.playbackSpeed;
                    this.pausedTime = currentTimePosition;
                    
                    // Resume playback with new tempo
                    this.handlePlay();
                    
                    console.log(`Smooth tempo transition: maintained position ${currentPositionBeforeChange.toFixed(1)}px, new time equivalent: ${currentTimePosition.toFixed(1)}ms`);
                } else {
                    // Not playing, just update the speed for future playback
                    this.playbackSpeed = newPlaybackSpeed;
                    
                    // If paused, update the timing calculations for the new tempo
                    if (this.isPaused && this.currentPosition > 0) {
                        const currentTimePosition = this.currentPosition / this.playbackSpeed;
                        this.pausedTime = currentTimePosition;
                        console.log(`Tempo changed while paused: updated time equivalent to ${currentTimePosition.toFixed(1)}ms`);
                    }
                }
                
                // Update tempo display and debug info
                this.updateTempoDisplay();
                this.displayDebugInfo();
            }

            /**
             * Handle tempo selector change event
             * @param {Event} event - The change event from the tempo selector
             */
            handleTempoChange(event) {
                const selectedTempo = event.target.value;
                const previousTempo = this.currentTempo;
                
                console.log(`User selected tempo: ${selectedTempo} (previous: ${previousTempo})`);
                
                // Preserve manual navigation functionality with tempo changes
                // Store current interaction state
                const wasDragging = this.isDragging;
                
                // Apply tempo change
                this.setTempo(selectedTempo);
                
                // Ensure manual navigation state is preserved
                if (wasDragging) {
                    console.log('Tempo changed during manual navigation - preserving interaction state');
                }
                
                // Log successful integration
                console.log(`Tempo control integrated: ${previousTempo} ‚Üí ${selectedTempo}, playback system updated`);
            }

            /**
             * Update the tempo display with current tempo information
             */
            updateTempoDisplay() {
                if (!this.tempoDisplay) {
                    console.warn('Tempo display element not found');
                    return;
                }

                const tempoInfo = this.getCurrentTempoInfo();
                if (tempoInfo) {
                    this.tempoDisplay.textContent = `${tempoInfo.bpm} BPM`;
                } else {
                    this.tempoDisplay.textContent = 'Unknown tempo';
                }
            }

            initializeControls() {
                this.playBtn = document.getElementById('playBtn');
                this.pauseBtn = document.getElementById('pauseBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.tempoSelector = document.getElementById('tempoSelector');
                this.tempoDisplay = document.getElementById('tempoDisplay');

                this.playBtn.addEventListener('click', () => this.handlePlay());
                this.pauseBtn.addEventListener('click', () => this.handlePause());
                this.resetBtn.addEventListener('click', () => this.handleReset());
                this.tempoSelector.addEventListener('change', (event) => this.handleTempoChange(event));

                // Add keyboard shortcuts
                document.addEventListener('keydown', (event) => this.handleKeydown(event));

                // Initialize button states and tempo display
                this.updateButtonStates();
                this.updateTempoDisplay();
            }

            initializeNotePositioning() {
                // Calculate positions for all notes in the song
                this.positionedNotes = this.notePositioning.calculateAllNotePositions(SONG_DATA.measures);

                // Render the note rectangles
                this.renderNoteRectangles();

                // Render the measure bars
                this.renderMeasureBars();

                // Display debug information on the page
                this.displayDebugInfo();
            }

            /**
             * Initialize touch and mouse event handlers for staff interaction
             */
            initializeStaffInteraction() {
                const staffContainer = document.querySelector('.staff-container');
                if (!staffContainer) {
                    console.error('Staff container not found for interaction setup');
                    return;
                }

                // Mouse event handlers
                staffContainer.addEventListener('mousedown', (event) => this.handlePointerStart(event));
                document.addEventListener('mousemove', (event) => this.handlePointerMove(event));
                document.addEventListener('mouseup', (event) => this.handlePointerEnd(event));

                // Touch event handlers
                staffContainer.addEventListener('touchstart', (event) => this.handlePointerStart(event), { passive: false });
                document.addEventListener('touchmove', (event) => this.handlePointerMove(event), { passive: false });
                document.addEventListener('touchend', (event) => this.handlePointerEnd(event));

                // Prevent context menu on right click for better interaction
                staffContainer.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });

                console.log('Staff interaction handlers initialized');
            }

            /**
             * Handle the start of pointer interaction (mouse down or touch start)
             * @param {MouseEvent|TouchEvent} event - The pointer event
             */
            handlePointerStart(event) {
                // Prevent default browser behaviors for smooth interaction
                event.preventDefault();

                // Pause automatic playback when manual interaction begins
                // This ensures manual control takes precedence over automatic playback
                if (this.isPlaying) {
                    this.handlePause();
                    console.log('Automatic playback paused for manual navigation');
                }

                // Get the pointer position with error handling
                let clientX;
                if (event.type === 'touchstart') {
                    if (event.touches && event.touches.length > 0) {
                        clientX = event.touches[0].clientX;
                    } else {
                        console.warn('Touch start event without touches array');
                        return;
                    }
                } else {
                    clientX = event.clientX;
                }

                // Initialize drag state
                this.isDragging = true;
                this.dragStartX = clientX;
                this.dragStartPosition = this.currentPosition;
                this.lastTouchX = clientX;

                // Add visual feedback for interaction
                const staffContainer = document.querySelector('.staff-container');
                if (staffContainer) {
                    staffContainer.style.cursor = 'grabbing';
                }

                console.log('Pointer interaction started at:', clientX, '- Manual navigation active');
            }

            /**
             * Handle pointer movement during drag (mouse move or touch move)
             * @param {MouseEvent|TouchEvent} event - The pointer event
             */
            handlePointerMove(event) {
                if (!this.isDragging) return;

                // Prevent default browser behaviors for smooth interaction
                event.preventDefault();

                // Get the current pointer position with error handling
                let clientX;
                if (event.type === 'touchmove') {
                    if (event.touches && event.touches.length > 0) {
                        clientX = event.touches[0].clientX;
                    } else {
                        console.warn('Touch event without touches array');
                        return;
                    }
                } else {
                    clientX = event.clientX;
                }

                // Calculate drag distance and direction from pointer events
                const dragDistance = clientX - this.dragStartX;
                const dragDirection = dragDistance > 0 ? 'right' : 'left';
                const dragVelocity = clientX - this.lastTouchX; // For momentum calculation

                // Convert drag movements to staff position changes
                // Apply sensitivity factor for more responsive control
                const dragSensitivity = 1.2; // Slightly amplify drag movements
                const adjustedDragDistance = dragDistance * dragSensitivity;

                // Update the current position based on drag distance
                // Negative drag distance moves staff left (forward in time)
                // Positive drag distance moves staff right (backward in time)
                const newPosition = this.dragStartPosition - adjustedDragDistance;

                // Apply boundary constraints
                const constrainedPosition = this.constrainPosition(newPosition);

                // Apply smooth CSS transforms for real-time staff movement
                this.currentPosition = constrainedPosition;
                this.updateStaffPositionSmooth(-this.currentPosition);

                // Store velocity and position data for momentum calculation
                this.dragVelocity = dragVelocity;
                this.lastTouchX = clientX;
                this.lastMoveTime = performance.now();

                // Continuously update internal position tracking during manual movement
                // This ensures the position is always synchronized for potential playback resumption
                if (Math.abs(dragDistance) > 10) { // Only update for significant movements to avoid excessive calls
                    this.updateInternalPositionTracking();
                }

                // Optional: Update debug info during drag
                if (Math.abs(dragDistance) > 5) { // Only log significant movements
                    console.log(`Dragging ${dragDirection} - Distance: ${Math.round(dragDistance)}px, Position: ${Math.round(constrainedPosition)}px, Velocity: ${Math.round(dragVelocity)}px`);
                }
            }

            /**
             * Handle the end of pointer interaction (mouse up or touch end)
             * @param {MouseEvent|TouchEvent} event - The pointer event
             */
            handlePointerEnd(event) {
                if (!this.isDragging) return;

                // Calculate momentum based on final drag velocity
                const momentum = this.dragVelocity || 0;
                const momentumThreshold = 2; // Minimum velocity to trigger momentum


                // Reset drag state
                this.isDragging = false;

                // Remove visual feedback
                const staffContainer = document.querySelector('.staff-container');
                if (staffContainer) {
                    staffContainer.style.cursor = 'grab';
                }

                // Add momentum and easing for natural feel
                if (Math.abs(momentum) > momentumThreshold) {
                    this.applyMomentumEasing(momentum);
                } else {
                    // No momentum, just ensure smooth final positioning
                    this.finalizeStaffPosition();
                }

                // Update internal position tracking for playback resumption
                // This ensures that when playback resumes, it starts from the manually set position
                this.updateInternalPositionTracking();

                console.log('Pointer interaction ended at position:', this.currentPosition, 'with momentum:', momentum);
            }

            /**
             * Constrain staff position to valid boundaries
             * @param {number} position - The desired position
             * @returns {number} The constrained position
             */
            constrainPosition(position) {
                const minPosition = 0; // Beginning of song
                const maxPosition = this.getTotalSongWidth(); // End of song

                // Clamp position between min and max
                return Math.max(minPosition, Math.min(position, maxPosition));
            }

            /**
             * Update staff position with smooth CSS transforms for real-time movement
             * @param {number} xOffset - Horizontal offset in pixels (negative moves left)
             */
            updateStaffPositionSmooth(xOffset) {
                const notesContainerElement = document.querySelector('.notes-container');
                if (notesContainerElement) {
                    // Use transform3d for hardware acceleration and smoother performance
                    notesContainerElement.style.transform = `translate3d(${xOffset}px, 0, 0)`;


                    // Temporarily remove transition during manual interaction for immediate response
                    notesContainerElement.style.transition = 'none';
                }
            }

            /**
             * Apply momentum and easing after drag ends for natural feel
             * @param {number} velocity - The final drag velocity in pixels
             */
            applyMomentumEasing(velocity) {
                const momentumFactor = 0.3; // Reduce momentum strength for control
                const easingDuration = 400; // Duration of easing animation in ms
                const startTime = performance.now();
                const startPosition = this.currentPosition;


                // Calculate momentum distance with decay
                const momentumDistance = velocity * momentumFactor;
                const targetPosition = this.constrainPosition(startPosition - momentumDistance);


                // Animate with easing
                const animateMomentum = (timestamp) => {
                    const elapsed = timestamp - startTime;
                    const progress = Math.min(elapsed / easingDuration, 1);


                    // Use easeOut cubic function for natural deceleration
                    const easeOutCubic = 1 - Math.pow(1 - progress, 3);


                    // Interpolate position
                    const currentPos = startPosition + (targetPosition - startPosition) * easeOutCubic;
                    this.currentPosition = currentPos;


                    // Apply smooth positioning and update internal tracking during momentum
                    this.updateStaffPositionSmooth(-this.currentPosition);


                    // Continue animation until complete
                    if (progress < 1) {
                        requestAnimationFrame(animateMomentum);
                    } else {
                        // Finalize position when momentum animation completes
                        this.finalizeStaffPosition();
                    }
                };


                requestAnimationFrame(animateMomentum);
                console.log(`Applying momentum: velocity=${velocity.toFixed(1)}, distance=${momentumDistance.toFixed(1)}, target=${targetPosition.toFixed(1)}`);
            }

            /**
             * Finalize staff position and restore normal transition behavior
             */
            finalizeStaffPosition() {
                const notesContainerElement = document.querySelector('.notes-container');
                if (notesContainerElement) {
                    // Restore transition for smooth playback animation
                    notesContainerElement.style.transition = 'transform 0.1s linear';

                    // Ensure final position is properly constrained
                    this.currentPosition = this.constrainPosition(this.currentPosition);
                    notesContainerElement.style.transform = `translate3d(${-this.currentPosition}px, 0, 0)`;
                }

                // Update internal position tracking after finalization
                this.updateInternalPositionTracking();
            }

            /**
             * Update internal position tracking during manual movement
             * This ensures playback can resume from the manually set position
             * Updated to work correctly with different tempo settings
             */
            updateInternalPositionTracking() {
                // Calculate the equivalent time position based on current staff position
                // This uses the current tempo's playback speed for accurate timing
                const timePosition = this.currentPosition / this.playbackSpeed;

                // Update the paused time to reflect the new position
                // This allows resuming playback from the manually set position
                this.pausedTime = timePosition;

                // If we were previously playing and got paused by manual interaction,
                // ensure the app is in the correct paused state
                if (!this.isPlaying && this.currentPosition > 0) {
                    this.isPaused = true;
                }

                // Update button states to reflect the current state
                this.updateButtonStates();

                // Only log significant position updates to avoid spam
                if (this.currentPosition % 50 < 5 || this.currentPosition < 5) {
                    const currentTempoInfo = this.getCurrentTempoInfo();
                    console.log(`Position tracking: ${this.currentPosition.toFixed(1)}px ‚Üí ${timePosition.toFixed(1)}ms (tempo: ${currentTempoInfo.name}, paused: ${this.isPaused})`);
                }
            }

            renderNoteRectangles() {
                const notesContainer = document.querySelector('.notes-container');
                if (!notesContainer) {
                    console.error('Notes container not found');
                    return;
                }

                // Clear any existing notes
                notesContainer.innerHTML = '';

                // Create and position each note rectangle (skip rest notes)
                this.positionedNotes.forEach((note, index) => {
                    // Skip rendering rest notes - they are silent and shouldn't be visible
                    if (note.pitch === 'rest') {
                        return;
                    }

                    const noteElement = document.createElement('div');
                    noteElement.className = `note-rectangle pitch-${note.pitch}`;
                    noteElement.id = `note-${index}`;

                    // Set position and size
                    noteElement.style.left = `${note.x}px`;
                    noteElement.style.top = `${note.y}px`;
                    noteElement.style.width = `${note.width}px`;
                    noteElement.style.height = `${note.height}px`;

                    // Add data attributes for debugging and future use
                    noteElement.setAttribute('data-pitch', note.pitch);
                    noteElement.setAttribute('data-duration', note.duration);
                    noteElement.setAttribute('data-measure', note.measureIndex + 1);
                    noteElement.setAttribute('data-fingering', note.fingering);

                    // Add tooltip with note information
                    noteElement.title = `${note.pitch} (${note.duration}) - Measure ${note.measureIndex + 1} - Finger ${note.fingering}`;

                    // Add fingering number inside the note rectangle if fingering is available
                    if (note.fingering !== null && note.fingering !== undefined) {
                        const fingeringElement = document.createElement('span');
                        fingeringElement.className = 'fingering-number';
                        fingeringElement.textContent = note.fingering.toString();
                        noteElement.appendChild(fingeringElement);
                    }

                    notesContainer.appendChild(noteElement);
                });

                const visibleNotes = this.positionedNotes.filter(note => note.pitch !== 'rest');
                console.log(`Rendered ${visibleNotes.length} note rectangles`);

                // Update the notes container width to accommodate all notes
                const maxX = Math.max(...this.positionedNotes.map(note => note.x + note.width));
                notesContainer.style.width = `${maxX + 100}px`; // Add some padding
            }

            renderMeasureBars() {
                const notesContainer = document.querySelector('.notes-container');
                if (!notesContainer) {
                    console.error('Notes container not found for measure bars');
                    return;
                }

                // Get measure bar positions from the positioning system
                const measurePositions = this.notePositioning.getMeasureBarPositions();

                // Create measure bars at each measure start position
                measurePositions.forEach((xPosition, measureIndex) => {
                    const measureBar = document.createElement('div');
                    measureBar.className = 'measure-bar';
                    measureBar.id = `measure-bar-${measureIndex}`;

                    // Position the measure bar
                    measureBar.style.left = `${xPosition}px`;

                    // Add data attribute for debugging
                    measureBar.setAttribute('data-measure', measureIndex + 1);

                    // Add tooltip
                    measureBar.title = `Measure ${measureIndex + 1}`;

                    notesContainer.appendChild(measureBar);
                });

                console.log(`Rendered ${measurePositions.length} measure bars`);
            }

            displayDebugInfo() {
                const debugElement = document.getElementById('debug-info');
                if (!debugElement) return;

                const uniquePitches = [...new Set(this.positionedNotes.map(note => note.pitch))];

                let debugHTML = '<strong>Piano Tutor App Ready!</strong><br><br>';
                debugHTML += `Total notes: ${this.positionedNotes.length}<br><br>`;

                debugHTML += '<strong>Note Colors by Pitch:</strong><br>';
                debugHTML += '‚Ä¢ C notes: <span style="color: #e74c3c;">Red</span><br>';
                debugHTML += '‚Ä¢ D notes: <span style="color: #f39c12;">Orange</span><br>';
                debugHTML += '‚Ä¢ F notes: <span style="color: #27ae60;">Green</span><br>';
                debugHTML += '‚Ä¢ G notes: <span style="color: #3498db;">Blue</span><br>';
                debugHTML += '‚Ä¢ A notes: <span style="color: #9b59b6;">Purple</span><br>';
                debugHTML += '‚Ä¢ C5 notes: <span style="color: #e67e22;">Dark Orange</span><br><br>';

                debugHTML += '<strong>Fingering Guide:</strong><br>';
                debugHTML += '‚Ä¢ White numbers inside each note show recommended finger positions<br>';
                debugHTML += '‚Ä¢ Finger numbers: 1=Thumb, 2=Index, 3=Middle, 4=Ring, 5=Pinky<br><br>';

                debugHTML += '<strong>Animation Controls:</strong><br>';
                debugHTML += '‚Ä¢ Click Play to start staff movement<br>';
                debugHTML += '‚Ä¢ Click Pause to pause animation<br>';
                debugHTML += '‚Ä¢ Click Reset to return to beginning<br>';
                debugHTML += '‚Ä¢ Press Spacebar to toggle play/pause<br>';
                debugHTML += '‚Ä¢ Press R to reset<br><br>';

                debugHTML += '<strong>Manual Navigation:</strong><br>';
                debugHTML += '‚Ä¢ Click and drag on the staff to navigate manually<br>';
                debugHTML += '‚Ä¢ Touch and swipe on mobile devices<br>';
                debugHTML += '‚Ä¢ Drag left to move forward in the song<br>';
                debugHTML += '‚Ä¢ Drag right to move backward in the song<br>';
                debugHTML += '‚Ä¢ Manual interaction pauses automatic playback<br>';
                debugHTML += '‚Ä¢ Playback resumes from manually set position<br>';
                debugHTML += '‚Ä¢ Position is maintained after manual interaction ends<br><br>';

                // Add tempo information
                const currentTempoInfo = this.getCurrentTempoInfo();
                debugHTML += '<strong>Current Tempo:</strong><br>';
                debugHTML += `‚Ä¢ ${currentTempoInfo.name}<br>`;
                debugHTML += `‚Ä¢ Playback speed: ${this.playbackSpeed.toFixed(4)} px/ms<br>`;
                debugHTML += `‚Ä¢ Speed multiplier: ${currentTempoInfo.speedMultiplier}x<br>`;
                debugHTML += `‚Ä¢ Integration status: ${this.isPlaying ? 'Active in playback' : 'Ready for playback'}<br><br>`;

                debugHTML += '<strong>Available Tempos:</strong><br>';
                Object.values(TEMPO_MARKINGS).forEach(tempo => {
                    const isActive = tempo.bpm.toString() === this.currentTempo ? ' <strong>(Active)</strong>' : '';
                    debugHTML += `‚Ä¢ ${tempo.name} (${tempo.speedMultiplier}x speed)${isActive}<br>`;
                });

                debugElement.innerHTML = debugHTML;
            }

            /**
             * Update debug info with current playback state
             */
            updateDebugPlaybackState() {
                const debugElement = document.getElementById('debug-info');
                if (!debugElement) return;

                // Find the playback state section and update it
                let currentHTML = debugElement.innerHTML;

                // Add or update playback state info
                const stateInfo = `<br><strong>Playback State:</strong> ${this.isPlaying ? '<span style="color: #27ae60;">Playing</span>' :
                        this.isPaused ? '<span style="color: #f39c12;">Paused</span>' :
                            '<span style="color: #e74c3c;">Stopped</span>'
                    }<br>`;

                // Remove existing state info if present
                currentHTML = currentHTML.replace(/<br><strong>Playback State:.*?<br>/g, '');

                // Add new state info before the closing
                debugElement.innerHTML = currentHTML + stateInfo;
            }

            /**
             * Handle keyboard shortcuts for playback control
             * @param {KeyboardEvent} event - The keyboard event
             */
            handleKeydown(event) {
                // Prevent shortcuts when user is typing in input fields
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                    return;
                }

                switch (event.code) {
                    case 'Space':
                        event.preventDefault();
                        if (this.isPlaying) {
                            this.handlePause();
                        } else {
                            this.handlePlay();
                        }
                        break;
                    case 'KeyR':
                        event.preventDefault();
                        this.handleReset();
                        break;
                }
            }

            /**
             * Update button states based on current playback state
             */
            updateButtonStates() {
                if (!this.playBtn || !this.pauseBtn || !this.resetBtn) return;

                if (this.isPlaying) {
                    // Playing state: disable play, enable pause and reset
                    this.playBtn.disabled = true;
                    this.playBtn.classList.remove('active');
                    this.pauseBtn.disabled = false;
                    this.pauseBtn.classList.add('active');
                    this.resetBtn.disabled = false;
                } else if (this.isPaused) {
                    // Paused state: enable play and reset, disable pause
                    this.playBtn.disabled = false;
                    this.playBtn.classList.remove('active');
                    this.pauseBtn.disabled = true;
                    this.pauseBtn.classList.remove('active');
                    this.resetBtn.disabled = false;
                } else {
                    // Stopped/Reset state: enable play, disable pause and reset
                    this.playBtn.disabled = false;
                    this.playBtn.classList.remove('active');
                    this.pauseBtn.disabled = true;
                    this.pauseBtn.classList.remove('active');
                    this.resetBtn.disabled = this.currentPosition === 0; // Only disable reset if at beginning
                }
            }

            /**
             * Start or resume playback animation
             * Updated to work correctly with tempo changes and manual navigation
             */
            handlePlay() {
                if (this.isPlaying) return; // Already playing

                const currentTempoInfo = this.getCurrentTempoInfo();
                console.log(`Starting playback animation from position: ${this.currentPosition} (tempo: ${currentTempoInfo.name})`);
                
                this.isPlaying = true;
                this.isPaused = false;

                // If resuming from pause or manual position, adjust start time
                // This allows resuming playback from manually set position with current tempo
                if (this.pausedTime > 0 || this.currentPosition > 0) {
                    // Calculate the time equivalent of current position using current tempo's playback speed
                    const currentTimePosition = this.currentPosition / this.playbackSpeed;
                    this.startTime = performance.now() - currentTimePosition;
                    console.log(`Resuming from position: ${this.currentPosition}px, time equivalent: ${currentTimePosition.toFixed(1)}ms (tempo: ${currentTempoInfo.name})`);
                } else {
                    this.startTime = performance.now();
                    console.log(`Starting from beginning with tempo: ${currentTempoInfo.name}`);
                }

                // Update button states
                this.updateButtonStates();
                this.updateDebugPlaybackState();

                this.startAnimation();
            }

            /**
             * Pause playback animation
             */
            handlePause() {
                if (!this.isPlaying) return; // Not playing

                console.log('Pausing playback animation at position:', this.currentPosition);
                this.isPlaying = false;
                this.isPaused = true;

                // Store the current playback time for resuming
                // This maintains staff position after manual interaction ends
                this.pausedTime = performance.now() - this.startTime;

                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }

                // Update button states
                this.updateButtonStates();
                this.updateDebugPlaybackState();
            }

            /**
             * Reset playback to beginning
             */
            handleReset() {
                console.log('Resetting playback');

                // Stop any current animation
                this.isPlaying = false;
                this.isPaused = false;

                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }

                // Reset timing variables
                this.startTime = null;
                this.pausedTime = 0;
                this.currentPosition = 0;

                // Reset staff position to beginning
                this.updateStaffPosition(0);

                // Update button states
                this.updateButtonStates();
                this.updateDebugPlaybackState();
            }

            /**
             * Start the animation loop using requestAnimationFrame
             * Modified to use current tempo setting for playback speed
             */
            startAnimation() {
                if (!this.isPlaying) return;

                const animate = (timestamp) => {
                    if (!this.isPlaying) return;

                    // Calculate elapsed time since start
                    const elapsedTime = timestamp - this.startTime;

                    // Calculate new position based on current tempo's playback speed
                    // This ensures the animation loop uses the current tempo setting
                    this.currentPosition = elapsedTime * this.playbackSpeed;

                    // Update staff position with smooth movement
                    this.updateStaffPosition(-this.currentPosition);

                    // Check if we've reached the end of the song
                    const totalSongWidth = this.getTotalSongWidth();
                    if (this.currentPosition >= totalSongWidth) {
                        console.log('Playback complete - auto resetting');
                        this.handleReset();
                        return;
                    }

                    // Continue animation
                    this.animationId = requestAnimationFrame(animate);
                };

                this.animationId = requestAnimationFrame(animate);
            }

            /**
             * Update the staff position using CSS transform
             * @param {number} xOffset - Horizontal offset in pixels (negative moves left)
             */
            updateStaffPosition(xOffset) {
                const notesContainerElement = document.querySelector('.notes-container');
                if (notesContainerElement) {
                    // Use translate3d for hardware acceleration and consistency
                    notesContainerElement.style.transform = `translate3d(${xOffset}px, 0, 0)`;
                }
            }

            /**
             * Calculate the total width of the song for determining when playback ends
             * @returns {number} Total width in pixels
             */
            getTotalSongWidth() {
                if (this.positionedNotes.length === 0) return 0;

                // Find the rightmost note position
                const maxX = Math.max(...this.positionedNotes.map(note => note.x + note.width));
                return maxX + 200; // Add some padding for smooth ending
            }

            // Method to get positioning data for external use
            getPositionedNotes() {
                return this.positionedNotes;
            }

            // Method to get positioning system for external use
            getNotePositioning() {
                return this.notePositioning;
            }

            /**
             * Validate tempo control integration with playback system
             * @returns {Object} Validation results
             */
            validateTempoIntegration() {
                const validation = {
                    isValid: true,
                    issues: [],
                    details: {}
                };

                // Check if tempo control is properly integrated
                try {
                    // Verify current tempo is valid
                    const currentTempoInfo = this.getCurrentTempoInfo();
                    if (!currentTempoInfo) {
                        validation.isValid = false;
                        validation.issues.push('Current tempo info not found');
                    } else {
                        validation.details.currentTempo = currentTempoInfo.name;
                        validation.details.currentBPM = currentTempoInfo.bpm;
                    }

                    // Verify playback speed calculation
                    const calculatedSpeed = this.calculatePlaybackSpeed(this.currentTempo);
                    if (Math.abs(calculatedSpeed - this.playbackSpeed) > 0.0001) {
                        validation.isValid = false;
                        validation.issues.push('Playback speed not synchronized with tempo');
                    } else {
                        validation.details.playbackSpeed = this.playbackSpeed;
                    }

                    // Verify animation loop uses current tempo
                    validation.details.animationIntegrated = this.isPlaying ? 'Active' : 'Ready';

                    // Verify manual navigation compatibility
                    validation.details.manualNavigationCompatible = !this.isDragging || 'Compatible during interaction';

                    console.log('Tempo integration validation:', validation);
                    return validation;

                } catch (error) {
                    validation.isValid = false;
                    validation.issues.push(`Validation error: ${error.message}`);
                    return validation;
                }
            }
        }

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const app = new PianoTutorApp();
            console.log('Piano Tutor App initialized successfully');

            // Validate tempo control integration
            const validation = app.validateTempoIntegration();
            if (validation.isValid) {
                console.log('‚úÖ Tempo control integration validated successfully');
                console.log('Integration details:', validation.details);
            } else {
                console.warn('‚ö†Ô∏è Tempo control integration issues found:', validation.issues);
            }

            // Make app available globally for debugging
            window.pianoApp = app;
        });
    </script>
</body>

</html>
