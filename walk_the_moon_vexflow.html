<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Different Colors - Walk the Moon (VexFlow)</title>
    <script src="./vexflow-debug.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #666;
            font-size: 16px;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .controls button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .controls button:hover {
            background-color: #45a049;
        }
        
        .measures-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .measure-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .measure-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            text-align: center;
        }
        
        .note-sequence {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
            text-align: center;
        }
        
        #vexflow-container {
            width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Different Colors - Walk the Moon</h1>
        <p>12 Measures with Accurate Note Durations (VexFlow)</p>
    </div>
    
    <div class="controls">
        <button onclick="playAllMeasures()">Play All Measures</button>
        <button onclick="exportToMusicXML()">Export to MusicXML</button>
    </div>
    
    <div id="vexflow-container"></div>
    
    <script>
        // Note data for each measure with durations
        const measureData = [
            { measure: 1, notes: [
                { pitch: 'D/4', duration: 'q' },
                { pitch: 'F/4', duration: 'q' },
                { pitch: 'C/4', duration: 'q' }
            ]},
            { measure: 2, notes: [
                { pitch: 'G/4', duration: 'q' },
                { pitch: 'A/4', duration: '8' },
                { pitch: 'G/4', duration: '8' },
                { pitch: 'F/4', duration: 'q' }
            ]},
            { measure: 3, notes: [
                { pitch: 'D/4', duration: 'q' },
                { pitch: 'F/4', duration: 'q' },
                { pitch: 'C/4', duration: 'q' }
            ]},
            { measure: 4, notes: [
                { pitch: 'G/4', duration: 'q' },
                { pitch: 'A/4', duration: '8' },
                { pitch: 'G/4', duration: '8' },
                { pitch: 'F/4', duration: 'q' }
            ]},
            { measure: 5, notes: [
                { pitch: 'A/4', duration: 'q' },
                { pitch: 'C/5', duration: 'q' },
                { pitch: 'A/4', duration: 'qd' },
                { pitch: 'F/4', duration: '8' }
            ]},
            { measure: 6, notes: [
                { pitch: 'A/4', duration: 'qd' },
                { pitch: 'G/4', duration: '8' },
                { pitch: 'F/4', duration: 'h' }
            ]},
            { measure: 7, notes: [
                { pitch: 'A/4', duration: 'q' },
                { pitch: 'C/5', duration: 'q' },
                { pitch: 'A/4', duration: 'qd' },
                { pitch: 'F/4', duration: '8' }
            ]},
            { measure: 8, notes: [
                { pitch: 'A/4', duration: 'qd' },
                { pitch: 'G/4', duration: '8' },
                { pitch: 'F/4', duration: 'h' }
            ]},
            { measure: 9, notes: [
                { pitch: 'A/4', duration: 'q' },
                { pitch: 'C/5', duration: 'q' },
                { pitch: 'A/4', duration: 'qd' },
                { pitch: 'F/4', duration: '8' }
            ]},
            { measure: 10, notes: [
                { pitch: 'A/4', duration: 'qd' },
                { pitch: 'G/4', duration: '8' },
                { pitch: 'F/4', duration: 'h' }
            ]},
            { measure: 11, notes: [
                { pitch: 'D/4', duration: 'q' },
                { pitch: 'F/4', duration: 'q' },
                { pitch: 'C/4', duration: 'q' }
            ]},
            { measure: 12, notes: [
                { pitch: 'G/4', duration: 'q' },
                { pitch: 'A/4', duration: '8' },
                { pitch: 'G/4', duration: '8' },
                { pitch: 'F/4', duration: 'q' }
            ]}
        ];

        let audioContext;

        function init() {
            // Check if VexFlow loaded
            if (typeof Vex === 'undefined') {
                console.error('VexFlow library failed to load');
                document.getElementById('vexflow-container').innerHTML = 
                    '<p style="color: red; text-align: center; padding: 50px;">VexFlow library failed to load. Please check your internet connection.</p>';
                return;
            }
            
            renderAllMeasures();
            initAudio();
        }

        function renderAllMeasures() {
            const VF = Vex.Flow;
            const container = document.getElementById('vexflow-container');
            container.innerHTML = '';
            
            const div = document.createElement('div');
            div.style.width = '100%';
            div.style.height = 'auto';
            container.appendChild(div);

            const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
            renderer.resize(1200, 1000);
            const context = renderer.getContext();

            let yPosition = 50;
            const measuresPerRow = 3; // Reduced for better visual separation
            const measureWidth = 300; // Increased width for better spacing

            // Process each measure individually
            for (let i = 0; i < measureData.length; i++) {
                const measure = measureData[i];
                
                // Calculate position
                const row = Math.floor(i / measuresPerRow);
                const col = i % measuresPerRow;
                const xPosition = 50 + (col * measureWidth);
                const currentYPosition = 50 + (row * 150);
                
                // Create stave for this measure
                const stave = new VF.Stave(xPosition, currentYPosition, measureWidth);
                
                // Add clef and time signature to first measure
                if (i === 0) {
                    stave.addClef('treble').addTimeSignature('4/4');
                }
                
                // Add barlines to separate measures
                if (i > 0) {
                    stave.setBegBarType(VF.Barline.type.SINGLE);
                }
                if (i === measureData.length - 1) {
                    stave.setEndBarType(VF.Barline.type.END);
                } else {
                    stave.setEndBarType(VF.Barline.type.SINGLE);
                }
                
                // Add measure number
                stave.setText(measure.measure.toString(), VF.Modifier.Position.ABOVE);
                
                stave.setContext(context).draw();

                const notes = [];

                // Convert measure notes to VexFlow format
                measure.notes.forEach(noteData => {
                    const note = new VF.StaveNote({
                        clef: 'treble',
                        keys: [vexPitch],
                        duration: noteData.duration
                    });

                    // Add dots for dotted notes
                    if (noteData.duration.includes('d')) {
                        note.addModifier(new VF.Dot(), 0);
                    }

                    notes.push(note);
                });

                // Calculate total duration for this measure
                let totalBeats = 0;
                measure.notes.forEach(noteData => {
                    switch(noteData.duration) {
                        case '8': totalBeats += 0.5; break;
                        case 'q': totalBeats += 1; break;
                        case 'qd': totalBeats += 1.5; break;
                        case 'h': totalBeats += 2; break;
                        case 'w': totalBeats += 4; break;
                    }
                });

                // Add rest to complete measure if needed
                if (totalBeats < 4) {
                    const restBeats = 4 - totalBeats;
                    console.log(`Measure ${measure.measure}: ${totalBeats} beats, adding ${restBeats} beat rest`);
                    
                    let restDuration = 'qr';
                    if (restBeats === 2) restDuration = 'hr';
                    else if (restBeats === 1) restDuration = 'qr';
                    else if (restBeats === 0.5) restDuration = '8r';
                    else if (restBeats === 1.5) restDuration = 'qdr';
                    
                    const rest = new VF.StaveNote({
                        clef: 'treble',
                        keys: ['b/4'],
                        duration: restDuration
                    });
                    notes.push(rest);
                }
                
                console.log(`Measure ${measure.measure} final notes:`, notes.map(n => ({ duration: n.getDuration(), keys: n.getKeys() })));

                // Create voice and add notes for this single measure
                const voice = new VF.Voice({ num_beats: 4, beat_value: 4 });
                voice.setStrict(false);
                voice.addTickables(notes);

                // Format and draw this measure
                const formatter = new VF.Formatter().joinVoices([voice]).format([voice], measureWidth - 20);
                voice.draw(context, stave);
            }
        }

        function addMeasureLabels(context) {
            let yPosition = 40;
            const measuresPerRow = 4;

            for (let i = 0; i < measureData.length; i += measuresPerRow) {
                for (let j = i; j < Math.min(i + measuresPerRow, measureData.length); j++) {
                    const xPosition = 50 + ((j - i) * 366);
                    context.fillText(`Measure ${j + 1}`, xPosition, yPosition);
                }
                yPosition += 150;
            }
        }

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Web Audio API not supported');
            }
        }

        function playNote(pitch, duration = 0.5) {
            if (!audioContext) return;
            
            // Convert VexFlow pitch to frequency
            const pitchMap = {
                'C/4': 261.63, 'D/4': 293.66, 'E/4': 329.63, 'F/4': 349.23,
                'G/4': 392.00, 'A/4': 440.00, 'B/4': 493.88, 'C/5': 523.25
            };
            
            const frequency = pitchMap[pitch] || 440;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playAllMeasures() {
            if (!audioContext) {
                initAudio();
            }
            
            let currentTime = 0;
            
            measureData.forEach(measure => {
                measure.notes.forEach(noteObj => {
                    setTimeout(() => playNote(noteObj.pitch), currentTime * 1000);
                    
                    // Duration-based timing
                    let noteDuration = 0.6;
                    switch(noteObj.duration) {
                        case '8': noteDuration = 0.3; break;
                        case 'q': noteDuration = 0.6; break;
                        case 'qd': noteDuration = 0.9; break;
                        case 'h': noteDuration = 1.2; break;
                        case 'w': noteDuration = 2.4; break;
                    }
                    
                    currentTime += noteDuration;
                });
                currentTime += 0.2;
            });
        }

        function exportToMusicXML() {
            let xml = `<?xml version="1.0" encoding="UTF-8"?>
<score-partwise version="3.1">
    <work>
        <work-title>Different Colors - Walk the Moon</work-title>
    </work>
    <part-list>
        <score-part id="P1">
            <part-name>Piano</part-name>
        </score-part>
    </part-list>
    <part id="P1">`;

            measureData.forEach(measure => {
                xml += `
        <measure number="${measure.measure}">
            <attributes>
                <divisions>4</divisions>
                <key>
                    <fifths>0</fifths>
                </key>
                <time>
                    <beats>4</beats>
                    <beat-type>4</beat-type>
                </time>
                <clef>
                    <sign>G</sign>
                    <line>2</line>
                </clef>
            </attributes>`;

                measure.notes.forEach(noteObj => {
                    const pitchParts = noteObj.pitch.split('/');
                    const pitch = pitchParts[0];
                    const octave = pitchParts[1];
                    
                    let xmlDuration = '1';
                    let xmlType = 'quarter';
                    let isDotted = false;
                    
                    switch(noteObj.duration) {
                        case '8': xmlDuration = '2'; xmlType = 'eighth'; break;
                        case 'q': xmlDuration = '4'; xmlType = 'quarter'; break;
                        case 'qd': xmlDuration = '6'; xmlType = 'quarter'; isDotted = true; break;
                        case 'h': xmlDuration = '8'; xmlType = 'half'; break;
                        case 'w': xmlDuration = '16'; xmlType = 'whole'; break;
                    }
                    
                    xml += `
            <note>
                <pitch>
                    <step>${pitch}</step>
                    <octave>${octave}</octave>
                </pitch>
                <duration>${xmlDuration}</duration>
                <type>${xmlType}</type>`;
                    
                    if (isDotted) {
                        xml += `
                <dot/>`;
                    }
                    
                    xml += `
            </note>`;
                });
                
                xml += `
        </measure>`;
            });

            xml += `
    </part>
</score-partwise>`;

            const blob = new Blob([xml], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'walk_the_moon_vexflow.xml';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
